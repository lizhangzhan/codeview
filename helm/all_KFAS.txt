####$$$$ KFAS/ChangeLog
Changes from Version 1.0.4 to 1.0.4-1:
 * Corrected R dependency from 3.0.0 to 3.1.0, which is needed for some package tests.
 * Adjusted tolerance parameters in tests for better portability (test should now only fail in case 
   of clearly bogus answers).

Changes from Version 1.0.3 to 1.0.4:
 * Tweaked the underlying algorithms for increased numerical stability of filtering and smoothing 
   in KFS. Note that it is still possible that exact diffuse initialization fails due to to numerical
   issues whereas traditional 'big value' approach works and vice versa.
 * Corrected a bug in residuals.KFS which threw an error when computing recursive residuals without 
   diffuse initialization.
 * Corrected output of LogLik method for non-Gaussian models: It now returns -Inf only when the 
   approximation algoritm failedcompletely (resulting NA), and issues only warning about 
   non-convergence in other cases.
 * Added checks of degenerate model to LogLik method. If all elements in R, Q and H/u are zero, or 
   they contain any non-finite values, -Inf is returned.
 * Fixed a bug in approximation algorithm which caused the approximation to fail for seemingly 
   random models.
 * Fixed a bug in SSMcycle which caused error with common components.
 * Fixed bug in SSMcycle which resulted erroneus system matrix T in all cases.
 * Fixed a bug in SSMseasonal which caused error in SSModel when using common components.
 * SSMseasonal with trigonometric seasonal now works properly when period is odd.  
 * Fixed a bug in coef.KFS which caused function to return smoothed states even with argument 
   filtered=TRUE if they were present in KFS object.
 * Added argument "maxiter" to predict.SSModel and changed its default value in all functions to 50.
 * Corrected a bug in function ldl which caused the decomposition of semidefinite matrices to fail 
   silently.
 * Changed variable mu to m for mean filtering for non-Gaussian models without simulation just like 
   in other cases.
 * Changed convergence criterion in Gaussian approximation algorithm from linear predictor based to 
   deviance based.
 * Properly exported assigment using subset method. See ?subset.SSModel for details.

Changes from Version 1.0.2 to 1.0.3:
 * Changed default filtering option for Gaussian models back to "state" (was previously "none").
 * Argument "invlink" in KFS is obsolete, proper argument is now "mean". For backwards compatibility,
  "invlink" still works.
 * Naming of output components of KFS were unified to follow the logic of state filtering and 
   smoothing: Now mean filtering returns an array m, and mean smoothing returns an array muhat, 
   signal filtering returns an array t, and signal smoothing returns an array thetahat. 
   Also, signal filtering and smoothing for Gaussian models returns m and muhat, not t and thetahat.
 * Fixed several bugs concerning the linearization of Gamma and Negative binomial distribution,
   which resulted false standard errors, among other problems.
 * Corrected bug in computing standardization for pearson and deviance residuals, 
   and added separate method rstandard for standardized residuals.
 * Added method hatvalues for computing hat values from KFS output.
 * Added method fitted for extraction of fitted values from KFS output.
 * Added method coef for extraction of fitted state values from KFS output.
 * Added method deviance for computation of deviance from KFS output.
 * Mean estimates for Poisson distribution now contains the effect of offset. Note that linear 
   predictor theta still does not contain offset term, i.e. mu=exp(theta)*offset.
 * Fixed a bug in SSMregression. In earlier versions missing values were removed from model matrix 
   which caused error in constructing system matrices.
 * Fixed a bug in SSMregression relating state names when type=="common".
 * Fixed a bug in approxSSM which caused the approximation to fail if system matrix Z contained 
   missing values.
 * LogLik.SSModel now produces error if linearization of non-Gaussian model did not converge.
 * When using formula list in SSMregression, option to use list of datasets is now also supported.
 * Naming convention for common regression coefficients with formula lists was changed. 
   Names for the states are now taken from the first dataset in data list.
 * Fixed a bug in SSModel which caused error when formula contained interaction terms and custom parts.
 * Broken SSMcycle with type="distinct" was fixed.
 * Fixed a bug regarding simulateSSM with missing observations in diffuse phase, which caused 
   variances of simulated values to be much larger than expected.

Changes from Version 1.0.0 to 1.0.2:
 * Fixed a bug in SSMarima which caused function to fail if there was 
   no ar part and stationarity option was TRUE.
 * Fixed a bug regarding the deviance residuals for Gaussian model.
 * Fixed a bugs in logLik.SSModel and transformSSM relating to the model transformation. 
 * Fixed a bug in KFS signal smoothing regarding the multivariate model with
   missing observations with time invariant Z and non-diagonal H.
 * SSModel should now keep the time series attributes of the response variable.
 * F is now set to 0 if F is smaller than the machine epsilon.
 * transformSSM now keeps the proper dimnames of the system matrices.
 * Changed the variable mu to muhat so it is similar to alphahat, thetahat etc.
 * KFS now always returns the log-likelihood for the Gaussian models.
 * Fixed a bug in residuals.KFS concerning the standardized deviance residuals.
 * Fixed a bug in predict.SSModel concerning the interval computation for 
   non-Gaussian models without simulation.
 * Fixed a bug in SSMregression and SSMcustom where a test of equality of 
   integer and double variables was done using function identical instead of ==.
 * Fixed a bug in predict.SSModel regarding the standard error computations 
   without simulation for non-Gaussian models.
 * Added filtering for non-Gaussian models.
 * Changed the filtering and smoothing options on KFS.
 * Added option to simulate from predictive distributions.
 * Other minor bug typo fixes.####$$$$ KFAS/DESCRIPTION
Package: KFAS
Version: 1.0.4-1
Date: 2014-06-06
Title: Kalman Filter and Smoother for Exponential Family State Space
        Models.
Author: Jouni Helske <jouni.helske@jyu.fi>
Maintainer: Jouni Helske <jouni.helske@jyu.fi>
Depends: R (>= 3.1.0)
Imports: stats
Suggests: MASS, testthat
Description: Package KFAS provides functions for Kalman filtering, smoothing,
    forecasting and simulation of multivariate exponential family state space
    models with exact diffuse initialization when distributions of some or all
    elements of initial state vector are unknown.
License: GPL (>= 2)
Packaged: 2014-06-06 14:17:23 UTC; Helske
NeedsCompilation: yes
Repository: CRAN
Date/Publication: 2014-06-06 17:31:27
####$$$$ KFAS/MD5
cf03ec5e2f09e39266daaf09dae78c96 *ChangeLog
2802baf5149e5a9e502b3729e017acae *DESCRIPTION
8d227f331472f1b80e12c5212fbc386e *NAMESPACE
84f4e176a760eb02fccc2a38b85149bb *R/KFAS-package.R
7a99820ec7a7401fcf865cc11b25f896 *R/KFS.R
971ac7a37ef32e73547078367147a813 *R/SSMarima.R
4e36bf919105ca6f0777ce5822dd2ef0 *R/SSMcustom.R
c3b40ebfe4624d112c3070ffc1ef572c *R/SSMcycle.R
838710f108f59d85adda8ef93e3cbc1f *R/SSModel.R
185a5daf89ad88204a2d381617399966 *R/SSMregression.R
59af2d61ffec1e6312399ea7c9791256 *R/SSMseasonal.R
01f4c7d790160be625e772a56043cbc2 *R/SSMtrend.R
ba2a7dd2b07adc9617f82b4e38e8949e *R/approxSSM.R
f085733aded2e30a35df976536705efc *R/artransform.R
7c5bdf8189be6fb45cbed6bebfb54f6b *R/checkModel.R
b08f480a4a7bd7e5b46df38bb7f590a0 *R/coef.KFS.R
1953ea8493cb6c07ab0ada06bec02eb3 *R/deviance.KFS.R
98043e09b8e18212294e97db82669adb *R/extract.SSModel.R
7c65ef48666563368dba0cedc3c4f000 *R/fitSSM.R
95ecd5fbc9d5dd704b05c1f8e6bcc2c9 *R/fitted.KFS.R
9f88d90449d99d0b5590341debd9e8ce *R/hatvalues.KFS.R
bcfb47da3951044098e73572c25e0a51 *R/importanceSSM.R
6ddc611b9b820396cbaa953d198e1b9c *R/interval.R
7c0ef66c107881b96b9b7fc55ddfd09e *R/ldl.R
d62ae6c64a4174cd3d8e73a25be40125 *R/logLik.SSModel.R
6c5332a716461c32405add70a7b4de01 *R/predict.SSModel.R
9b46c4d041cf98ba30a69bf312b58b9d *R/print.objects.R
3693f929027a32c49cdd046a7d026ffb *R/residuals.KFS.R
a0b7c3f26b1a2df8ae2de5613c2cb877 *R/rstandard.KFS.R
8d1dfc3a8b2694f1984280fff08163c2 *R/signals.R
feef168d7cb90ee137eba730f7f7123a *R/simulateSSM.R
19535b8cbc7b66d3968b1ce50b195fc6 *R/subset.SSModel.R
17f408856125c7e270ebe1380ba0ba48 *R/transformSSM.R
41808b6fb5597b9e331efeb146b1a428 *README.md
85993fe9d3165948f23ee4d023dd8e78 *data/GlobalTemp.rda
30f3f80fe83502869ff93a6662c56c5e *data/boat.rda
cae765cd5662c7c2ed49ce79fc54114c *data/sexratio.rda
71d29603e1be9c08347c89ffd9582cbe *man/Extract.SSModel.Rd
003466ac2fbcb59f7016143d7eb01332 *man/GlobalTemp.Rd
b5585f6af1d3aaef93a36c694a0fdbc5 *man/KFAS.Rd
df7e60d867233e8d261aa033824b6f62 *man/KFS.Rd
7b3e7dc710149d3f3d6d7f1e21c32be6 *man/SSModel.Rd
c702f974705e9cb633afcd881be8fd12 *man/approxSSM.Rd
46e7faecfb9908b838bd332f0b876196 *man/artransform.Rd
4687ee686c817e1cf62153adee7e700b *man/boat.Rd
4148ce0c99230395c17e0123244966ea *man/checkModel.Rd
6dc8ba19fa2b07ff107457e555bd7858 *man/coef.KFS.Rd
88befadfd96d84fc72b901b842b31f70 *man/deviance.KFS.Rd
968ac00e1b493c147024615814919921 *man/fitSSM.Rd
81efaf5fc440d6583be2df01a919c4b0 *man/fitted.KFS.Rd
c85653a0591d43a20489038889fdc43a *man/hatvalues.KFS.Rd
8a375314d585c8a6008087cb302cfecd *man/importanceSSM.Rd
89ae827d4ee2c6c80899987b665897f5 *man/ldl.Rd
31007603d90cf81fa4452116e45245ff *man/logLik.SSModel.Rd
fc0ae292b5e06c50727755339947ed42 *man/predict.SSModel.Rd
12a30667eea81e8d7ac790958a46c57f *man/print.KFS.Rd
3988a453fdc228e77c25bd948eb125a4 *man/print.SSModel.Rd
57a1c67660f295e71c69f3a21290ba1b *man/residuals.KFS.Rd
6d6814524f9817e12d40c2b162f3e862 *man/rstandard.KFS.Rd
c8d613ecf373d20127d7813f280f6531 *man/sexratio.Rd
c88054748cfa92534660256adb741d0d *man/signal.Rd
edbe1424aca064f5674fa0c66bb40dc3 *man/simulateSSM.Rd
41a4708432180dbca1c4236e8bcebd67 *man/transformSSM.Rd
415cb7ed6d87a75c5794917a85e3af96 *src/Makevars
24ad133e2264d3be5a17bd48fbd94ded *src/approx.f95
de1d3788c2169ce2160a139d29fd222e *src/artransform.f95
d6ac9a5fddf72c13336874e7d1522147 *src/covmeanw.f95
f2d1f8ab8b41ac5931d19e21f193387a *src/declarations.h
c3cbeb6b6fd8118540819b6d1427e8d1 *src/deviance.f95
eefeb5bc1290d902a55afd8d5512a3b2 *src/filtersimfast.f95
b45e2b505424a0b25da90172a6923479 *src/gloglik.f95
bcfffcf18f15aa7dad8189df9207419d *src/glogliku.f95
627fbc3a3c187d020af0c0a132a60c2d *src/gsmoothall.f95
58d9b1fb7bc4b5d16275571dab4fac9e *src/init.c
e21b34f35505ad7f47c4a2aef9c4565f *src/isample.f95
a1fb57eeda6b62b9ea323211e31ca47e *src/isamplefilter.f95
5a300e3ebf378e8584b0631e11d14d45 *src/kfilter.f95
add443506aeb61d151ca920329129e14 *src/kfstheta.f95
efc07a09999e2a6fcebbbbef7727beb5 *src/ldl.f95
8f7f9b0248c734c6d43ecd6eee111dcc *src/ldlssm.f95
ef58b1cd6e3455bdc8690f2bbdcf6024 *src/ngfilter.f95
bb001ad4911ff4f32df61dafe24c3747 *src/ngloglik.f95
ac239290951fda3006b1f9be42cde694 *src/ngsmooth.f95
f0968eda670f7a75427d79cfb21e62be *src/predict.f95
8549681a6da98dfe2af49a74fd52a4f7 *src/simfilter.f95
2e0e674256f5398e509ee1e94778f238 *src/simgaussian.f95
61e625d5a1e835b20bd1f681eb50038b *src/smoothsim.f95
6d00a9c67c54a4aacfeef3fcefb98242 *src/smoothsimfast.f95
cfa0086dd519fd2054a93f7259fe4885 *tests/test-all.R
064bac99060c9c6876c0ea055ab7f6e3 *tests/testthat/testBasics.R
135e2470d9aa866429019b2194629df4 *tests/testthat/testGLM.R
44eb03a352ddb2893713f1d6b4a1e4ff *tests/testthat/testSSMarima.R
9c4d44e390c1599865fb914792736f46 *tests/testthat/testStruct.R
####$$$$ KFAS/NAMESPACE
S3method("[",SSModel)
S3method("[<-",SSModel)
S3method("subset<-",SSModel)
S3method(coef,KFS)
S3method(deviance,KFS)
S3method(fitted,KFS)
S3method(hatvalues,KFS)
S3method(logLik,SSModel)
S3method(predict,SSModel)
S3method(print,KFS)
S3method(print,SSModel)
S3method(residuals,KFS)
S3method(rstandard,KFS)
S3method(subset,SSModel)
export("subset<-")
export(KFS)
export(SSMarima)
export(SSMcustom)
export(SSMcycle)
export(SSModel)
export(SSMregression)
export(SSMseasonal)
export(SSMtrend)
export(approxSSM)
export(artransform)
export(fitSSM)
export(importanceSSM)
export(is.SSModel)
export(ldl)
export(signal)
export(simulateSSM)
export(transformSSM)
import(stats)
useDynLib(KFAS,.registration=TRUE)
####$$$$ KFAS/README.md
KFAS: R Package for Exponential Family State Space Models
==========================================================================

Package KFAS provides tools for modelling exponential family state space models such as
structural time series, ARIMA models, generalized linear models and generalized linear mixed models.

Main features
--------------------------------------------------------------------------

- Kalman filtering
- Fixed interval smoothing (Kalman smoothing)
- Simulation smoothing of Gaussian models
- Importance sampling of non-Gaussian models
- Exact diffuse initialization
- Multivariate models with mixed distributions

Most of the algorithms are based on book "Time Series Analysis by State Space Methods" and related articles by J. Durbin and S.J. Koopman.

Current version of KFAS in CRAN is 1.0.4-1. 
See
* help(KFAS) in R for examples
* [ChangeLog](https://github.com/helske/KFAS/blob/master/ChangeLog) for upcoming, already completed changes
* [TODO](https://github.com/helske/KFAS/blob/master/TODO) for future changes

####$$$$ KFAS\data/boat.rda
‹      r‰0âŠàb```b`âgd`b2Y˜€#'ˆ“”ŸXÂÀÀÌdog€‚ú ’}±´ýìú`âè4.{ÐÕkºyè|t{	ñ)¸ü+ÐýEª»p™GÈ^J!ÿ+O¬½¤¦ORÝCmšRàJ¤¦3bõãr/©ù‡Üp¢vz¥Ô\JãP¸’/ŽR¦3— )P‘Îì0g
XÃü4­(ZX“s‹‹$A¦È? ßç¶I  ####$$$$ KFAS\data/GlobalTemp.rda
‹      u•?LTAÆ×{ñEÔDjl±Õš,…
ˆ…§`bòÎ¼«°=j####$$$$ KFAS\data/sexratio.rda
‹      m™ytTåÆ'	«Yë9·”ENÙKe‰‚DÖV¤ˆ„–ÃR–@B‘Š`J¡.4€-°MáàT@« 5ÍJ€È6“É,wæÎÉ6Éd¬`C~OúÇ?à™ç}ŸwùÞ™{ïw¿Ì›ºpì°ÙlÑ¶[”-:¦íc§è¶ÿ¢llÝÛ°[òò×7&¦¬Zo³Å<Øö¯W\ÑÊímv[\Q$£‹;ÙÚ±äEì%¹qàA°ø‚t{e¯@_6
}ÙÓøKVÀKW¢+»ƒ®Ô/MO@_ö…â3•oªòÜ’®‡òíí‰BýUtŽ8Ð9####$$$$ KFAS\man/approxSSM.Rd
\name{approxSSM}
\alias{approxSSM}
\title{Linear Gaussian Approximation for Exponential Family State Space Model}
\usage{
approxSSM(model, theta, maxiter = 50, tol = 1e-15)
}
\arguments{
  \item{model}{A non-Gaussian state space model object of
  class \code{SSModel}.}

  \item{theta}{Initial values for conditional mode theta.}

  \item{maxiter}{The maximum number of iterations used in
  approximation Default is 50.}

  \item{tol}{Tolerance parameter for convergence checks.
  Iterations are continued until
  \eqn{tol>abs(dev_{old}-dev_{new})/(abs(dev_{new})+0.1))}.}
}
\value{
An object which contains the approximating Gaussian state
space model with following additional components:
\item{thetahat}{Mode of \eqn{p(\theta|y)}. }
\item{iterations}{Number of iterations used. }
}
\description{
Function \code{approxSMM} computes the linear Gaussian
approximation of a state space model where observations
follow an exponential family distribution.
}
\details{
The linear Gaussian approximating model is defined by
\deqn{\tilde y_t = Z_t \alpha_t + \epsilon_t, \quad
\epsilon_t \sim N(0,\tilde H_t),}{ytilde[t] = Z[t]\alpha[t]
+ \epsilon[t], \epsilon[t] ~ N(0,Htilde[t]),}
\deqn{\alpha_{t+1} = T_t \alpha_t + R_t \eta_t, \quad
\eta_t \sim N(0,Q_t),}{\alpha[t+1] = T[t]\alpha[t] +
R[t]\eta[t], \eta[t] ~ N(0,Q[t]),} and \eqn{\alpha_1 \sim
N(a_1,P_1)}{\alpha[1] ~ N(a[1],P[1])}, where \eqn{\tilde
y}{ytilde} and \eqn{\tilde H}{Htilde} are chosen in a way
that the linear Gaussian approximating model has the same
conditional mode of \eqn{\theta=Z\alpha} given the
observations \eqn{y} as the original non-gaussian model.
Models also have a same curvature at the mode.

The approximation of the exponential family state space
model is based on iterative weighted least squares method,
see McCullagh and Nelder (1983) p.31 and Durbin Koopman
(2012) p. 243.
}
\seealso{
Importance sampling of non-Gaussian state space models
\code{\link{importanceSSM}}, construct a \code{SSModel}
object \code{\link{SSModel}}, and examples in
\code{\link{KFAS}}.
}

####$$$$ KFAS\man/artransform.Rd
\name{artransform}
\alias{artransform}
\title{Mapping real valued parameters to stationary region}
\usage{
artransform(param)
}
\arguments{
  \item{param}{Real valued parameters for the
  transformation.}
}
\value{
transformed The parameters satisfying the stationary
constrains.
}
\description{
Function \code{artransform} transforms \eqn{p} real valued
parameters to stationary region of \eqn{p}th order
autoregressive process using parametrization suggested by
Jones (1980), except the same modification is done as in
\code{arima}.
}

####$$$$ KFAS\man/boat.Rd
\docType{data}
\name{boat}
\alias{boat}
\title{Oxford-Cambridge boat race results 1829-2000}
\format{A time series object containing 172 observations.}
\source{
http://www.ssfpack.com/DKbook.html
}
\description{
Results of the annual boat race between universities of
Oxford (0) and Cambridge (1).
}
\references{
Koopman, S.J. and Durbin J. (2001).  Time Series Analysis
by State Space Methods. Oxford: Oxford University Press.
}
\keyword{datasets}

####$$$$ KFAS\man/checkModel.Rd
\name{is.SSModel}
\alias{is.SSModel}
\title{Test whether object is a valid \code{SSModel} object}
\usage{
is.SSModel(object, na.check = FALSE, return.logical = TRUE)
}
\arguments{
  \item{object}{An object to be tested.}

  \item{na.check}{Test the system matrices for NA and
  infinite values. Default is \code{FALSE}.}

  \item{return.logical}{If \code{FALSE}, error is given if
  the the model is not a valid \code{SSModel} object.
  Otherwise logical value is returned. Defaults to
  \code{FALSE}.}
}
\value{
Logical value or nothing, depending on the value of
\code{return.logical}.
}
\description{
Function \code{is.SSModel} tests whether the object is a
valid \code{SSModel} object.
}
\details{
Note that the validity of the values in \code{y} and
\code{Z} are not tested. These can contain NA values (but
not infinite values), with condition that when
\code{Z[i,,t]} contains NA value, the corresponding
\code{y[t,i]} must also have NA value. In this case
\code{Z[i,,t]} is not referenced in filtering and
smoothing, and algorithms works properly. Note also that
this does result NA values in \code{thetahat}, so it could
be beneficial to use for example zeroes in place of NA
values in Z, making first sure that the above condition is
met.
}

####$$$$ KFAS\man/coef.KFS.Rd
\name{coef.KFS}
\alias{coef.KFS}
\title{Extract Estimated States of State Space Model}
\usage{
\method{coef}{KFS}(object, start = NULL, end = NULL, filtered = FALSE,
  ...)
}
\arguments{
  \item{object}{An object of class \code{KFS}.}

  \item{start}{The start time of the period of interest.
  Defaults to first time point of the object}

  \item{end}{The end time of the period of interest.
  Defaults to the last time point of the object.}

  \item{filtered}{Logical, return filtered instead of
  smoothed estimates of state vector. Default is
  \code{FALSE}.}

  \item{\dots}{Ignored.}
}
\value{
Multivariate time series containing estimates states.
}
\description{
Extracts the estimates states from output of \code{KFS}.
For non-Gaussian models without simulation, these are
estimates of conditional modes of states. For Gaussian
models and non-Gaussian models with importance sampling,
these are estimates of conditional means of states.
}

####$$$$ KFAS\man/deviance.KFS.Rd
\name{deviance.KFS}
\alias{deviance.KFS}
\title{Deviance of a State Space Model}
\usage{
\method{deviance}{KFS}(object, ...)
}
\arguments{
  \item{object}{An object of class \code{KFS}.}

  \item{\dots}{Ignored.}
}
\value{
The value of the deviance extracted from object.
}
\description{
Returns the deviance of a object of class \code{KFS}.
}

####$$$$ KFAS\man/Extract.SSModel.Rd
\name{[<-.SSModel}
\alias{[.SSModel}
\alias{[<-.SSModel}
\alias{subset.SSModel}
\alias{subset<-}
\alias{subset<-.SSModel}
\title{Extract or Replace Parts of a State Space Model}
\usage{
\method{[}{SSModel}(x, element, states, etas, series, times, ...) <- value

\method{[}{SSModel}(x, element, states, etas, series, times, ...)

\method{subset}{SSModel}(x, element, states, etas, series, times, ...) <- value

subset(x, ...) <- value

\method{subset}{SSModel}(x, element, states, etas, series, times, ...)
}
\arguments{
  \item{x}{Object of class \code{SSModel}.}

  \item{element}{Which element is chosen. Possible choices
  are 'y','Z','H','T','R','Q','a1','P1','P1inf', and 'u'.}

  \item{states}{Which states are chosen. Either a numeric
  vector containing the indices of the corresponding
  states, or a character vector defining the types of the
  corresponding states. Possible choices are \dQuote{all},
  \dQuote{arima}, \dQuote{custom}, \dQuote{cycle},
  \dQuote{seasonal}, \dQuote{trend}, or
  \dQuote{regression}. These can be combined. Default is
  \dQuote{all}.}

  \item{etas}{Which disturbances eta are chosen. Used for
  elements \dQuote{R} and \dQuote{Q}.Either a numeric
  vector containing the indices of the corresponding etas,
  or a character vector defining the types of the
  corresponding etas. Possible choices are \dQuote{all},
  \dQuote{arima}, \dQuote{custom}, \dQuote{cycle},
  \dQuote{seasonal}, \dQuote{trend}, or
  \dQuote{regression}. These can be combined.}

  \item{series}{Numeric. Which series are chosen. Used for
  elements \dQuote{y}, \dQuote{Z}, and \dQuote{u}.}

  \item{times}{Numeric. Which time points are chosen.}

  \item{value}{A value to be assigned to x.}

  \item{...}{ignored.}
}
\value{
A selected subset of the chosen element or a value.
}
\description{
S3 methods for extracting or replacing parts of objects of
class \code{SSModel}. These methods ensure that dimensions
of system matrices are not altered. \code{[} and
\code{subset} and corresponding replacement methods are
identical methods with different method names.
}
\examples{
set.seed(1)
model<-SSModel(rnorm(10)~1)
model["H"]
model["H"]<-10
# H is still an array:
model["H"]
logLik(model)
model$H<-1
# model["H"] throws an error as H is now scalar:
model$H
logLik(model,check.model=TRUE) #with check.model=FALSE (default) R crashes!
}

####$$$$ KFAS\man/fitSSM.Rd
\name{fitSSM}
\alias{fitSSM}
\title{Maximum Likelihood Estimation of a State Space Model}
\usage{
fitSSM(model, inits, updatefn, checkfn, ...)
}
\arguments{
  \item{inits}{Initial values for \code{optim}}

  \item{model}{Model object of class \code{SSModel}.}

  \item{updatefn}{User defined function which updates the
  model given the parameters. Must be of form
  \code{updatefn(pars, model,...)}, i.e. must contain
  ellipsis \code{...}. If not supplied, a default function
  is used, which estimates the values marked as NA in time
  invariant covariance matrices Q and H.}

  \item{checkfn}{Optional function for model checking. If
  supplied, after updating the model, if
  \code{checkfn(model)} returns TRUE, -log-likelihood is
  computed, otherwise \code{.Machine$double.xmax} is
  returned. See examples. If not supplied, check.model=TRUE
  is used for checking possible NA or Inf values, see
  ?logLik.SSModel.}

  \item{...}{Further arguments for functions \code{optim},
  \code{updatefn} and \code{logLik.SSModel}, such as
  \code{method='BFGS'}.}
}
\value{
A list with elements \item{optim.out}{Output from function
\code{optim}. } \item{model}{Model with estimated
parameters. }
}
\description{
Function \code{fitSSM} finds the maximum likelihood
estimates for unknown parameters of an arbitary state space
model, given the user-defined model updating function.
}
\examples{
# Example function for updating covariance matrices H and Q
# (also used as a default function in fitSSM)

updatefn <- function(pars,model,...){
Q<-as.matrix(model$Q[,,1])
naQd  <- which(is.na(diag(Q)))
naQnd <- which(upper.tri(Q[naQd,naQd]) & is.na(Q[naQd,naQd]))
Q[naQd,naQd][lower.tri(Q[naQd,naQd])] <- 0
diag(Q)[naQd] <- exp(0.5 * pars[1:length(naQd)])
Q[naQd,naQd][naQnd] <- pars[length(naQd)+1:length(naQnd)]
model$Q[naQd,naQd,1] <- crossprod(Q[naQd,naQd])
if(!identical(model$H,'Omitted')){
   H<-as.matrix(model$H[,,1])
   naHd  <- which(is.na(diag(H)))
   naHnd <- which(upper.tri(H[naHd,naHd]) & is.na(H[naHd,naHd]))
   H[naHd,naHd][lower.tri(H[naHd,naHd])] <- 0
   diag(H)[naHd] <- exp(0.5 * pars[length(naQd)+length(naQnd)+1:length(naHd)])
   H[naHd,naHd][naHnd] <- pars[length(naQd)+length(naQnd)+length(naHd)+1:length(naHnd)]
   model$H[naHd,naHd,1] <- crossprod(H[naHd,naHd])
 }

 model
}

# Example function for checking the validity of covariance matrices.

checkfn <- function(model){
  #test positive semidefiniteness of H and Q
  inherits(try(ldl(model$H[,,1]),TRUE),'try-error') ||
  inherits(try(ldl(model$Q[,,1]),TRUE),'try-error')
}
}

####$$$$ KFAS\man/fitted.KFS.Rd
\name{fitted.KFS}
\alias{fitted.KFS}
\title{Extract Fitted Values of State Space Model}
\usage{
\method{fitted}{KFS}(object, start = NULL, end = NULL, filtered = FALSE,
  ...)
}
\arguments{
  \item{object}{An object of class \code{KFS}.}

  \item{start}{The start time of the period of interest.
  Defaults to first time point of the object.}

  \item{end}{The end time of the period of interest.
  Defaults to the last time point of the object.}

  \item{filtered}{Logical, return filtered instead of
  smoothed estimates of mean vector. Default is
  \code{FALSE}.}

  \item{\dots}{Ignored.}
}
\value{
Multivariate time series containing fitted values.
}
\description{
Extracts fitted values from output of \code{KFS}.
}

####$$$$ KFAS\man/GlobalTemp.Rd
\docType{data}
\name{GlobalTemp}
\alias{GlobalTemp}
\title{Two series of average global temperature deviations for years 1880-1987}
\format{A time series object containing 108 times 2 observations.}
\source{
http://lib.stat.cmu.edu/general/stoffer/tsa2/
}
\description{
This data set contains two series of average global
temperature deviations for years 1880-1987. These series
are same as used in Shumway and Stoffer (2006), where they
are known as HL and Folland series. For more details, see
Shumway and Stoffer (2006, p. 327).
}
\references{
Shumway, Robert H. and Stoffer, David S. (2006). Time
Series Analysis and Its Applications: With R examples.
}
\keyword{datasets}

####$$$$ KFAS\man/hatvalues.KFS.Rd
\name{hatvalues.KFS}
\alias{hatvalues.KFS}
\title{Extract Hat Values from KFS Output}
\usage{
\method{hatvalues}{KFS}(model, ...)
}
\arguments{
  \item{model}{An object of class \code{KFS}.}

  \item{\dots}{Ignored.}
}
\value{
Multivariate time series containing hat values.
}
\description{
Extract hat values from KFS output, when \code{KFS} was run
with signal (non-Gaussian case) or mean smoothing (Gaussian
case).
}
\details{
Hat values are the diagonal elements of \code{V_t/H_t}
where V_t is the covariance matrix of signal/mean at time t
and H_t is the covariance matrix of disturbance vector
\eqn{\epsilon} of (approximating) Gaussian model at time t.
}

####$$$$ KFAS\man/importanceSSM.Rd
\name{importanceSSM}
\alias{importanceSSM}
\title{Importance Sampling of Exponential Family State Space Model}
\usage{
importanceSSM(model, type = c("states", "signals"), filtered = FALSE,
  nsim = 1000, save.model = FALSE, theta, antithetics = FALSE,
  maxiter = 50)
}
\arguments{
  \item{model}{Exponential family state space model of
  class \code{SSModel}.}

  \item{type}{What to simulate, \code{'states'} or
  \code{'signals'}. Default is \code{'states'}}

  \item{filtered}{Simulate from
  \eqn{p(\alpha_t|y_{t-1},...,y_1)} instead of
  \eqn{p(\alpha|y)}.}

  \item{nsim}{Number of independent samples. Default is
  1000.}

  \item{save.model}{Return the original model with the
  samples. Default is FALSE.}

  \item{theta}{Initial values for conditional mode theta.}

  \item{antithetics}{Logical. If TRUE, two antithetic
  variables are used in simulations, one for location and
  another for scale. Default is FALSE.}

  \item{maxiter}{Maximum number of iterations used in
  linearisation. Default is 50.}
}
\value{
A list containing elements \code{samples}, \code{weights}
and \code{model} (if \code{save.model==TRUE}).
}
\description{
Importance Sampling of Exponential Family State Space
Model.
}
\details{
Function \code{importanceSSM} simulates states or signals
of the exponential family state space model conditioned
with the observations, returning the simulated samples of
the states/signals with the corresponding importance
weights.

Function can use two antithetic variables, one for location
and other for scale, so output contains four blocks of
simulated values which correlate which each other (ith
block correlates negatively with (i+1)th block, and
positively with (i+2)th block etc.).
}

####$$$$ KFAS\man/KFAS.Rd
\docType{package}
\name{KFAS}
\alias{KFAS}
\alias{KFAS-package}
\title{KFAS: Functions for Gaussian and Non-Gaussian State Space Models}
\description{
Package KFAS contains functions for Kalman filtering,
smoothing and simulation of linear state space models with
exact diffuse initialization.
}
\details{
The linear gaussian state space model is given by

\deqn{y_t = Z_t \alpha_t + \epsilon_t,}{y[t] =
Z[t]\alpha[t] + \epsilon[t], (observation equation)}

\deqn{\alpha_{t+1} = T_t \alpha_t + R_t
\eta_t,}{\alpha[t+1] = T[t]\alpha[t] + R[t]\eta[t],
(transition equation)}

where \eqn{\epsilon_t \sim N(0,H_t)}{\epsilon[t] ~
N(0,H[t])}, \eqn{\eta_t \sim N(0,Q_t)}{\eta[t] ~ N(0,Q[t])}
and \eqn{\alpha_1 \sim N(a_1,P_1)}{\alpha[1] ~
N(a[1],P[1])} independently of each other.

All system and covariance matrices Z, H, T, R and Q can be
time-varying, and partially or totally missing observations
\eqn{y_t}{y[t]} are allowed.

Covariance matrices H and Q has to be positive semidefinite
(although this is not checked).

Dimensions of system matrices are

\tabular{rl}{ Z \tab \eqn{p \times m \times 1}{p*m*1} or
\eqn{p \times m \times n}{p*m*n} in time varying case \cr H
\tab \eqn{p \times p \times 1}{p*p*1} or \eqn{p \times p
\times n}{p*p*n} in time varying case (Omitted in
non-gaussian models) \cr T \tab \eqn{m \times m \times
1}{m*m*1} or \eqn{m \times m \times n}{m*m*n} in time
varying case \cr R \tab \eqn{m \times k \times 1}{m*k*1} or
\eqn{m \times k \times n}{m*k*n} in time varying case \cr Q
\tab \eqn{k \times k \times 1}{k*k*1} or \eqn{k \times k
\times n}{k*k*n} in time varying case \cr u \tab \eqn{n
\times p}{p*n} (Omitted in gaussian models) \cr }

In case of any of the series in model is defined as
non-gaussian, the observation equation is of form
\deqn{\prod_i^p p_i(y_{i,t}|\theta_t)}{\prod_i^p
p(y[i,t]|\theta[t]),} with
\eqn{\theta_{i,t}=Z_{i,t}\alpha_t}{\theta[i,t]=Z[i,t]\alpha[t]}
being one of the following:

If observations \eqn{y_{i,1},\ldots,y_{i,n}} are
distributed as \eqn{N(\mu_t,u_t)}, then
\eqn{\theta_t=\mu_t}. Note that now variances are defined
using \code{u}, not \code{H}. If correlation between
gaussian observation equations is needed, one can use
\eqn{u_t=0} and add correlating disturbances into state
equation (although care is needed when making inferences as
then \eqn{y_t=\theta_t})

If observations are distributed as
\eqn{Poisson(u_t\lambda_t)}, where \eqn{u_t}{u[t]} is
offset term, then \eqn{\theta_t =
log(u_t\lambda_t)}{\theta[t]=log(u[t]\lambda[t])}.

If observations are distributed as
\eqn{binomial(u_t,\pi_t)}, then \eqn{\theta_t =
log[\pi_t/(1-\pi_t)]}{\theta[t] = log(\pi[t]/(1-\pi[t]))},
where \eqn{\pi_t}{\pi[t]} is the probability of success at
time \eqn{t}.

If observations are distributed as \eqn{gamma(u_t,\mu_t)},
then \eqn{\theta_t = log(\mu_t)}{[\theta[t] =
log(\mu[t])]}, where \eqn{\mu[t]} is the mean parameter and
\eqn{u} is the shape parameter.

If observations are distributed as \eqn{negative
binomial(u_t,\mu_t)} (with expected value \eqn{\mu_t} and
variance \eqn{\mu_t+ \mu_t^2/u_t}, see
\code{\link{dbinom}}), then \eqn{\theta_t =
log[\mu_t]}{\theta[t] = log(\mu[t])}.

For exponential family models \eqn{u_t=1}{u[t]=1} as a
default. For completely gaussian models, parameter is
omitted.

For the unknown elements of initial state vector
\eqn{a_1}{a[1]}, KFS uses exact diffuse initialization by
Koopman and Durbin (2000, 2001, 2003), where the unknown
initial states are set to have a zero mean and infinite
variance, so \deqn{P_1 = P_{\ast,1} + \kappa
P_{\infty,1},}{P[1] = P[*,1] + \kappaP[inf,1],} with
\eqn{\kappa} going to infinity and
\eqn{P_{\infty,1}}{P[inf,1]} being diagonal matrix with
ones on diagonal elements corresponding to unknown initial
states.

Diffuse phase is continued until rank of
\eqn{P_{\infty,t}}{P[inf,t]} becomes zero. Rank of
\eqn{P_{\infty}}{P[inf]} decreases by 1, if
\eqn{F_\infty>tol>0}{F[inf]>tol>0}. Usually the number of
diffuse time points equals the number unknown elements of
initial state vector, but missing observations or
time-varying Z can affect this. See Koopman and Durbin
(2000, 2001, 2003) for details for exact diffuse and
non-diffuse filtering.

To lessen the notation and storage space, KFAS uses letters
P, F and K for non-diffuse part of the corresponding
matrices, omitting the asterisk in diffuse phase.

All functions of KFAS use the univariate approach (also
known as sequential processing, see Anderson and Moore
(1979)) which is from Koopman and Durbin (2000, 2001). In
univariate approach the observations are introduced one
element at the time. Therefore the prediction error
variance matrices F and Finf does not need to be
non-singular, as there is no matrix inversions in
univariate approach algorithm.  This provides more stable
and possibly more faster filtering and smoothing than
normal multivariate Kalman filter algorithm. If covariance
matrix H is not diagonal, it is possible to transform the
model by either using LDL decomposition on H, or augmenting
the state vector with \eqn{\epsilon} disturbances. See
\code{\link{transformSSM}} for more details.
}
\examples{
# Example of local level model for Nile series

modelNile<-SSModel(Nile~SSMtrend(1,Q=list(matrix(NA))),H=matrix(NA))
modelNile
modelNile<-fitSSM(inits=c(log(var(Nile)),log(var(Nile))),model=modelNile,
                  method='BFGS',control=list(REPORT=1,trace=1))$model
# Filtering and state smoothing
out<-KFS(modelNile,filtering='state',smoothing='state')
out

# Confidence and prediction intervals for the expected value and the observations.
# Note that predict uses original model object, not the output from KFS.
conf<-predict(modelNile,interval='confidence')
pred<-predict(modelNile,interval='prediction')

ts.plot(cbind(Nile,pred,conf[,-1]),col=c(1:2,3,3,4,4),
        ylab='Predicted Annual flow', main='River Nile')


# Missing observations, using same parameter estimates

y<-Nile
y[c(21:40,61:80)]<-NA
modelNile<-SSModel(y~SSMtrend(1,Q=list(modelNile$Q)),H=modelNile$H)

out<-KFS(modelNile,filtering='mean',smoothing='mean')

# Filtered and smoothed states
plot.ts(cbind(y,fitted(out,filtered=TRUE),fitted(out)), plot.type='single',
        col=1:3, ylab='Predicted Annual flow', main='River Nile')


# Example of multivariate local level model with only one state
# Two series of average global temperature deviations for years 1880-1987
# See Shumway and Stoffer (2006), p. 327 for details

data(GlobalTemp)

model<-SSModel(GlobalTemp~SSMtrend(1,Q=NA,type='common'),H=matrix(NA,2,2))

# Estimating the variance parameters
inits<-chol(cov(GlobalTemp))[c(1,4,3)]
inits[1:2]<-log(inits[1:2])
fit<-fitSSM(inits=c(0.5*log(.1),inits),model=model,method='BFGS')

out<-KFS(fit$model)

ts.plot(cbind(model$y,coef(out)),col=1:3)
legend('bottomright',legend=c(colnames(GlobalTemp), 'Smoothed signal'), col=1:3, lty=1)



# Seatbelts data
\dontrun{
model<-SSModel(log(drivers)~SSMtrend(1,Q=list(NA))+
               SSMseasonal(period=12,sea.type='trigonometric',Q=NA)+
               log(PetrolPrice)+law,data=Seatbelts,H=NA)

# As trigonometric seasonal contains several disturbances which are all
# identically distributed, default behaviour of fitSSM is not enough,
# as we have constrained Q. We can either provide our own
# model updating function with fitSSM, or just use optim directly:

# option 1:
ownupdatefn<-function(pars,model,...){
  model$H[]<-exp(pars[1])
  diag(model$Q[,,1])<-exp(c(pars[2],rep(pars[3],11)))
  model #for option 2, replace this with -logLik(model) and call optim directly
}

fit<-fitSSM(inits=log(c(var(log(Seatbelts[,'drivers'])),0.001,0.0001)),
            model=model,updatefn=ownupdatefn,method='BFGS')

out<-KFS(fit$model,smoothing=c('state','mean'))
out
ts.plot(cbind(out$model$y,fitted(out)),lty=1:2,col=1:2,
main='Observations and smoothed signal with and without seasonal component')
lines(signal(out,states=c("regression","trend"))$signal,col=4,lty=1)
legend('bottomleft',
legend=c('Observations', 'Smoothed signal','Smoothed level'),
col=c(1,2,4), lty=c(1,2,1))


# Multivariate model with constant seasonal pattern,
# using the the seat belt law dummy only for the front seat passangers,
# and restricting the rank of the level component by using custom component

# note the small inconvinience in regression component,
# you must remove the intercept from the additional regression parts manually

model<-SSModel(log(cbind(front,rear))~ -1 + log(PetrolPrice) + log(kms)
               + SSMregression(~-1+law,data=Seatbelts,index=1)
               + SSMcustom(Z=diag(2),T=diag(2),R=matrix(1,2,1),
                           Q=matrix(1),P1inf=diag(2))
               + SSMseasonal(period=12,sea.type='trigonometric'),
                 data=Seatbelts,H=matrix(NA,2,2))

likfn<-function(pars,model,estimate=TRUE){
  model$H[,,1]<-exp(0.5*pars[1:2])
  model$H[1,2,1]<-model$H[2,1,1]<-tanh(pars[3])*prod(sqrt(exp(0.5*pars[1:2])))
  model$R[28:29]<-exp(pars[4:5])
  if(estimate) return(-logLik(model))
  model
}
fit<-optim(f=likfn,p=c(-7,-7,1,-1,-3),method='BFGS',model=model)
model<-likfn(fit$p,model,estimate=FALSE)
model$R[28:29,,1]\%*\%t(model$R[28:29,,1])
model$H

out<-KFS(model)
out
ts.plot(cbind(signal(out,states=c('custom','regression'))$signal,model$y),col=1:4)

# For confidence or prediction intervals, use predict on the original model
pred <- predict(model,states=c('custom','regression'),interval='prediction')
ts.plot(pred$front,pred$rear,model$y,col=c(1,2,2,3,4,4,5,6),lty=c(1,2,2,1,2,2,1,1))
}

 \dontrun{
# Poisson model
model<-SSModel(VanKilled~law+SSMtrend(1,Q=list(matrix(NA)))+
               SSMseasonal(period=12,sea.type='dummy',Q=NA),
               data=Seatbelts, distribution='poisson')

# Estimate variance parameters
fit<-fitSSM(inits=c(-4,-7,2), model=model,method='BFGS')

model<-fit$model

# use approximating model, gives posterior mode of the signal and the linear predictor
out_nosim<-KFS(model,smoothing=c('signal','mean'),nsim=0)
# State smoothing via importance sampling
out_sim<-KFS(model,smoothing=c('signal','mean'),nsim=1000)

out_nosim
out_sim
}

# Example of generalized linear modelling with KFS

# Same example as in ?glm
counts <- c(18,17,15,20,10,20,25,13,12)
outcome <- gl(3,1,9)
treatment <- gl(3,3)
print(d.AD <- data.frame(treatment, outcome, counts))
glm.D93 <- glm(counts ~ outcome + treatment, family = poisson())


model<-SSModel(counts ~ outcome + treatment, data=d.AD,
               distribution = 'poisson')

out<-KFS(model)
coef(out,start=1,end=1)
coef(glm.D93)

summary(glm.D93)$cov.s
out$V[,,1]

outnosim<-KFS(model,smoothing=c('state','signal','mean'))
set.seed(1)
outsim<-KFS(model,smoothing=c('state','signal','mean'),nsim=1000)


## linear
# GLM
glm.D93$linear.predictor
# approximate model, this is the posterior mode of p(theta|y)
c(outnosim$thetahat)
# importance sampling on theta,  gives E(theta|y)
c(outsim$thetahat)



## predictions on response scale
# GLM
fitted(glm.D93)
# approximate model with backtransform, equals GLM
c(fitted(outnosim))
# importance sampling on exp(theta)
fitted(outsim)

# prediction variances on link scale
# GLM
as.numeric(predict(glm.D93,type='link',se.fit=TRUE)$se.fit^2)
# approx, equals to GLM results
c(outnosim$V_theta)
# importance sampling on theta
c(outsim$V_theta)


# prediction variances on response scale
# GLM
as.numeric(predict(glm.D93,type='response',se.fit=TRUE)$se.fit^2)
# approx, equals to GLM results
c(outnosim$V_mu)
# importance sampling on theta
c(outsim$V_mu)

\dontrun{
data(sexratio)
model<-SSModel(Male~SSMtrend(1,Q=list(NA)),u=sexratio[,'Total'],data=sexratio,
               distribution='binomial')
fit<-fitSSM(model,inits=-15,method='BFGS',control=list(trace=1,REPORT=1))
fit$model$Q #1.107652e-06

# Computing confidence intervals in response scale
# Uses importance sampling on response scale (4000 samples with antithetics)

pred<-predict(fit$model,type='response',interval='conf',nsim=1000)

ts.plot(cbind(model$y/model$u,pred),col=c(1,2,3,3),lty=c(1,1,2,2))

# Now with sex ratio instead of the probabilities:
imp<-importanceSSM(fit$model,nsim=1000,antithetics=TRUE)
sexratio.smooth<-numeric(length(model$y))
sexratio.ci<-matrix(0,length(model$y),2)
w<-imp$w/sum(imp$w)
for(i in 1:length(model$y)){
 sexr<-exp(imp$sample[i,1,])
 sexratio.smooth[i]<-sum(sexr*w)
 oo<-order(sexr)
 sexratio.ci[i,]<-c(sexr[oo][which.min(abs(cumsum(w[oo]) - 0.05))],
                      + sexr[oo][which.min(abs(cumsum(w[oo]) - 0.95))])
}

# Same by direct transformation:
out<-KFS(fit$model,smoothing='signal',nsim=1000)
sexratio.smooth2 <- exp(out$thetahat)
sexratio.ci2<-exp(c(out$thetahat)
                  + qnorm(0.025) * sqrt(drop(out$V_theta))\%o\%c(1, -1))

ts.plot(cbind(sexratio.smooth,sexratio.ci,sexratio.smooth2,sexratio.ci2),
        col=c(1,1,1,2,2,2),lty=c(1,2,2,1,2,2))
}
# Example of Cubic spline smoothing
\dontrun{
require(MASS)
data(mcycle)

model<-SSModel(accel~-1+SSMcustom(Z=matrix(c(1,0),1,2),
                                 T=array(diag(2),c(2,2,nrow(mcycle))),
                                 Q=array(0,c(2,2,nrow(mcycle))),
                                 P1inf=diag(2),P1=diag(0,2)),data=mcycle)

model$T[1,2,]<-c(diff(mcycle$times),1)
model$Q[1,1,]<-c(diff(mcycle$times),1)^3/3
model$Q[1,2,]<-model$Q[2,1,]<-c(diff(mcycle$times),1)^2/2
model$Q[2,2,]<-c(diff(mcycle$times),1)


updatefn<-function(pars,model,...){
  model$H[]<-exp(pars[1])
  model$Q[]<-model$Q[]*exp(pars[2])
  model
}

fit<-fitSSM(model,inits=c(4,4),updatefn=updatefn,method="BFGS")

pred<-predict(fit$model,interval="conf",level=0.95)
plot(x=mcycle$times,y=mcycle$accel,pch=19)
lines(x=mcycle$times,y=pred[,1])
lines(x=mcycle$times,y=pred[,2],lty=2)
lines(x=mcycle$times,y=pred[,3],lty=2)
}
}
\references{
Koopman, S.J. and Durbin J. (2000).  Fast filtering and
smoothing for non-stationary time series models, Journal of
American Statistical Assosiation, 92, 1630-38.

Koopman, S.J. and Durbin J. (2001).  Time Series Analysis
by State Space Methods. Oxford: Oxford University Press.

Koopman, S.J. and Durbin J. (2003).  Filtering and
smoothing of state vector for diffuse state space models,
Journal of Time Series Analysis, Vol. 24, No. 1.

#' Shumway, Robert H. and Stoffer, David S. (2006).  Time
Series Analysis and Its Applications: With R examples.  \cr
}

####$$$$ KFAS\man/KFS.Rd
\name{KFS}
\alias{KFS}
\title{Kalman Filter and Smoother with Exact Diffuse Initialization for Exponential Family State Space Models}
\usage{
KFS(model, filtering, smoothing, simplify = TRUE, transform = c("ldl",
  "augment"), nsim = 0, theta, maxiter = 50, convtol = 1e-15)
}
\arguments{
  \item{model}{Object of class \code{SSModel}.}

  \item{filtering}{Types of filtering. Possible choices are
  'state', 'signal', 'mean', and 'none'. Default is 'state'
  for Gaussian and 'none' for non-Gaussian models.
  Multiple values are allowed. Note that for Gaussian
  models, signal is mean. Note that filtering for
  non-Gaussian models with importance sampling can be very
  slow with large models. Also in approximating mean
  filtering only diagonals of P_mu are returned.}

  \item{smoothing}{Types of smoothing. Possible choices are
  'state', 'signal', 'mean', 'disturbance' and 'none'.
  Default is 'state' and 'mean'. For non-Gaussian models,
  option 'disturbance' is not supported, and for Gaussian
  models option 'mean' is identical to 'signal'. Multiple
  values are allowed.}

  \item{simplify}{If FALSE and model is completely
  Gaussian, KFS returns some generally not so interesting
  variables from filtering and smoothing. Default is TRUE.}

  \item{transform}{How to transform the model in case of
  non-diagonal covariance matrix \eqn{H}. Defaults to
  \code{'ldl'}. See function \code{\link{transformSSM}} for
  details.}

  \item{nsim}{The number of independent samples.  Only used
  for non-Gaussian model. Default is 0, which computes the
  approximating Gaussian model by \code{\link{approxSSM}}
  and performs the usual Gaussian smoothing so that the
  smoothed state estimates equals to the conditional mode
  of \eqn{p(\alpha_t|y)}{p(\alpha[t]|y)}.}

  \item{theta}{Initial values for conditional mode theta.
  Only used for non-Gaussian model.}

  \item{maxiter}{The maximum number of iterations used in
  approximation Default is 50. Only used for non-Gaussian
  model.}

  \item{convtol}{Tolerance parameter for convergence checks
  for Gaussian approximation.  Iterations are continued
  until
  \eqn{tol>abs(dev_{old}-dev_{new})/(abs(dev_{new})+0.1))}.}
}
\value{
What \code{KFS} returns depends on the arguments
\code{filtering}, \code{smoothed} and \code{simplify}, and
whether the model is Gaussian or not: \item{model}{Original
state space model.  } \item{KFS_transform}{Type of H after
possible transformation.  } \item{logLik}{Value of the
log-likelihood function. Only computed for Gaussian models.
}

\item{a}{One step predictions of states,
\eqn{a_t=E(\alpha_t | y_{t-1}, \ldots ,
y_{1})}{a[t]=E(\alpha[t] | y[t-1], \ldots , y[1])}.  }
\item{P}{Covariance matrices (of the non-diffuse parts) of
predicted states, \eqn{P_t=Cov(\alpha_t | y_{t-1}, \ldots ,
y_{1})}{P[t]=Cov(\alpha[t] | y[t-1], \ldots , y[1])}.  }
\item{Pinf}{Diffuse part of \eqn{P_t}{P[t]}. Only returned
for Gaussian models.} \item{t}{Filtered estimates of
signals, \eqn{E(Z_t\alpha_t | y_{t-1}, \ldots ,
y_{1})}{E(Z[t]\alpha[t] | y[t-1], \ldots , y[1])}. }
\item{P_theta}{Covariances \eqn{Var(Z[t]\alpha_t | y_{t-1},
\ldots , y_{1}).}{Var(Z[t]\alpha[t] | y[t-1], \ldots ,
y[1])}. } \item{m}{Filtered estimates of \eqn{f(\theta_t) |
y_{t-1}, \ldots , y_{1})}{f(\theta[t]) | y[t-1], \ldots ,
y[1])}, where \eqn{f} is the inverse link function.  }
\item{P_mu}{Covariances \eqn{Cov(f(\theta_t)| y_{t-1},
\ldots , y_{1})}{Cov(f(\theta[t]) | y[t-1], \ldots ,
y[1])}. If \code{nsim=0}, only diagonal elements
(variances) are computed, using the delta method.  }
\item{alphahat}{Smoothed estimates of states,
\eqn{E(\alpha_t | y_1, \ldots , y_n)}{E(\alpha[t] | y[1],
\ldots , y[n])}. } \item{V}{Covariances \eqn{Var(\alpha_t |
y_1, \ldots , y_n)}{Var(\alpha[t] | y[1], \ldots , y[n])}.
} \item{thetahat}{Smoothed estimates of signals,
\eqn{E(Z_t\alpha_t | y_1, \ldots , y_n)}{E(Z[t]\alpha[t] |
y[1], \ldots , y[n])}. } \item{V_theta}{Covariances
\eqn{Var(Z[t]\alpha_t | y_1, \ldots ,
y_n).}{Var(Z[t]\alpha[t] | y[1], \ldots , y[n])}. }
\item{muhat}{Smoothed estimates of \eqn{f(\theta_t) | y_1,
\ldots , y_n)}{f(\theta[t]) | y[1], \ldots , y[n])}, where
\eqn{f} is the inverse link function.  }
\item{V_mu}{Covariances \eqn{Cov(f(\theta_t)| y_1, \ldots ,
y_n)}{Cov(f(\theta[t]) | y[1], \ldots , y[n])}. If
\code{nsim=0}, only diagonal elements (variances) are
computed, using the delta method.  } \item{etahat}{Smoothed
disturbance terms \eqn{E(\eta_t | y_1, \ldots ,
y_n)}{E(\eta[t] | y[1], \ldots , y[n])}. }
\item{V_eta}{Covariances \eqn{Var(\eta_t | y_1, \ldots ,
y_n)}{Var(\eta[t] | y[1], \ldots , y[n])}. }
\item{epshat}{Smoothed disturbance terms
\eqn{E(\epsilon_{t,i} | y_1, \ldots , y_n)}{E(\epsilon[t,i]
| y[1], \ldots , y[n])}. Note that due to the possible
diagonalization these are on transformed scale. }
\item{V_eps}{Diagonal elements of \eqn{Var(\epsilon_{t} |
y_1, \ldots , y_n)}{Var(\epsilon[t] | y[1], \ldots ,
y[n])}. Note that due to the diagonalization the
off-diagonal elements are zero. } \item{iterations}{The
number of iterations used in linearization of non-Gaussian
model. } \item{v}{Prediction errors \eqn{v_{t,i} = y_{t,i}
- Z_{i,t}a_{t,i}, i=1,\ldots,p}{v[t,i] = y[t,i] -
Z[i,t]a[t,i], i=1,\ldots,p}, where \eqn{a_{t,i}=E(\alpha_t
| y_{t,i-1}, \ldots, y_{t,1}, \ldots ,
y_{1,1})}{a[t,i]=E(\alpha[t] | y[t,i-1], \ldots, y[t,1],
\ldots , y[1,1])}. Only returned for Gaussian models.  }
\item{F}{Prediction error variances
\eqn{Var(v_{t,i})}{Var(v[t,i])}. Only returned for Gaussian
models.  } \item{Finf}{Diffuse part of \eqn{F_t}{F[t]}.
Only returned for Gaussian models.  } \item{d}{The last
index of diffuse phase, i.e. the non-diffuse phase began
from time \eqn{d+1}. Only returned for Gaussian models.  }
\item{j}{The index of last \eqn{y_{i,t}} of diffuse phase.
Only returned for Gaussian models.  } In addition, if
argument \code{simplify=FALSE}, list contains following
components: \item{K}{Covariances \eqn{Cov(\alpha_{t,i},
y_{t,i} | y_{t,i-1}, \ldots, y_{t,1}, y_{t-1}, \ldots ,
y_{1}), \quad i=1,\ldots,p}{Cov(\alpha[t,i], y[t,i] |
y[t,i-1], \ldots, y[t,1], y[t-1], \ldots , y[1]),
i=1,\ldots,p}.  } \item{Kinf}{Diffuse part of
\eqn{K_t}{K[t]}.  } \item{r}{Weighted sums of innovations
\eqn{v_{t+1}, \ldots , v_{n}}{v[t+1], \ldots , v[n]}.
Notice that in literature t in \eqn{r_t}{r[t]} goes from
\eqn{0, \ldots, n}. Here \eqn{t=1, \ldots, n+1}. Same
applies to all r and N variables.  } \item{r0, r1}{Diffuse
phase decomposition of \eqn{r_t}{r[t]}.  }
\item{N}{Covariances \eqn{Var(r_t)}{Var(r[t])} .  }
\item{N0, N1, N2}{Diffuse phase decomposition of
\eqn{N_t}{N[t]}.  }
}
\description{
Performs Kalman filtering and smoothing with exact diffuse
initialization using univariate approach for exponential
family state space models.
}
\details{
Notice that in case of multivariate observations, \code{v},
\code{F}, \code{Finf}, \code{K} and \code{Kinf} are usually
not the same as those calculated in usual multivariate
Kalman filter. As filtering is done one observation element
at the time, the elements of prediction error
\eqn{v_t}{v[t]} are uncorrelated, and \code{F},
\code{Finf}, \code{K} and \code{Kinf} contain only the
diagonal elemens of the corresponding covariance matrices.

In rare cases of a diffuse initialization phase with highly
correlated states, cumulative rounding errors in computing
\code{Finf} and \code{Pinf} can sometimes cause the diffuse
phase end too early. Changing the tolerance parameter
\code{tol} of the model (see \code{\link{SSModel}}) to
smaller (or larger) should help.

In case of non-Gaussian models with \code{nsim=0}, the
smoothed estimates relate the conditional mode of
\eqn{p(\alpha|y)}, and are equivalent with the results from
generalized linear models. When using importance sampling
(\code{nsim>0}), results correspond to the conditional
mean.
}
\references{
Koopman, S.J. and Durbin J. (2000).  Fast filtering and
smoothing for non-stationary time series models, Journal of
American Statistical Assosiation, 92, 1630-38.  \cr

Koopman, S.J. and Durbin J. (2001).  Time Series Analysis
by State Space Methods. Oxford: Oxford University Press.
\cr

Koopman, S.J. and Durbin J. (2003).  Filtering and
smoothing of state vector for diffuse state space models,
Journal of Time Series Analysis, Vol. 24, No. 1.  \cr
}

####$$$$ KFAS\man/ldl.Rd
\name{ldl}
\alias{ldl}
\title{LDL Decomposition of a Matrix}
\usage{
ldl(x, tol = max(abs(diag(x))) * .Machine$double.eps)
}
\arguments{
  \item{x}{Symmetrix matrix.}

  \item{tol}{Tolerance parameter for LDL decomposition,
  determines which diagonal values are counted as zero.
  Same value is used in isSymmetric function.}
}
\value{
Transformed matrix with D in diagonal, L in strictly lower
diagonal and zeros on upper diagonal.
}
\description{
Function \code{ldl} computes the LDL decomposition of a
positive semidefinite matrix.
}

####$$$$ KFAS\man/logLik.SSModel.Rd
\name{logLik.SSModel}
\alias{logLik}
\alias{logLik.SSModel}
\title{Log-likelihood of the State Space Model.}
\usage{
\method{logLik}{SSModel}(object, nsim = 0, antithetics = TRUE, theta,
  check.model = FALSE, transform = c("ldl", "augment"), maxiter = 50,
  seed, convtol = 1e-08, ...)
}
\arguments{
  \item{object}{State space model of class \code{SSModel}.}

  \item{nsim}{Number of independent samples used in
  estimating the log-likelihood of the non-Gaussian state
  space model. Default is 0, which gives good starting
  value for optimization. Only used for non-Gaussian
  model.}

  \item{antithetics}{Logical. If TRUE, two antithetic
  variables are used in simulations, one for location and
  another for scale. Default is TRUE. Only used for
  non-Gaussian model.}

  \item{theta}{Initial values for conditional mode theta.
  Only used for non-Gaussian model.}

  \item{check.model}{Logical. If TRUE, function
  \code{is.SSModel} is called before computing the
  likelihood. Default is FALSE.}

  \item{transform}{How to transform the model in case of
  non-diagonal covariance matrix \eqn{H}. Defaults to
  \code{'ldl'}. See function \code{\link{transformSSM}} for
  details.}

  \item{maxiter}{The maximum number of iterations used in
  linearisation. Default is 50. Only used for non-Gaussian
  model.}

  \item{seed}{The value is used as a seed via set.seed
  function. Only used for non-Gaussian model.}

  \item{convtol}{Tolerance parameter for convergence checks
  for Gaussian approximation.  Iterations are continued
  until
  \eqn{tol>abs(dev_{old}-dev_{new})/(abs(dev_{new})+0.1))}.}

  \item{...}{Ignored.}
}
\value{
\item{}{log-likelihood of the state space model.}
}
\description{
Function \code{logLik.SSmodel} computes the log-likelihood
value of a state space model.
}

####$$$$ KFAS\man/predict.SSModel.Rd
\name{predict.SSModel}
\alias{predict}
\alias{predict.SSModel}
\title{State Space Model Predictions}
\usage{
\method{predict}{SSModel}(object, newdata, n.ahead, interval = c("none",
  "confidence", "prediction"), level = 0.95, type = c("response", "link"),
  states = NULL, se.fit = FALSE, nsim = 0, prob = TRUE, maxiter = 50,
  ...)
}
\arguments{
  \item{object}{Object of class \code{SSModel}.}

  \item{newdata}{A compatible \code{SSModel} object to be
  added in the end of the old object for which the
  predictions are required. If omitted, predictions are
  either for the whole data (fitted values), or if argument
  \code{n.ahead} is given, \code{n.ahead} time steps
  ahead.}

  \item{n.ahead}{Number of steps ahead at which to predict.
  Only used if \code{newdata} is omitted. Note that when
  using \code{n.ahead}, object cannot contain time varying
  system matrices.}

  \item{interval}{Type of interval calculation.}

  \item{level}{Confidence level for intervals.}

  \item{type}{Scale of the prediction, \code{'response'} or
  \code{'link'}.}

  \item{states}{Which states are used in computing the
  predictions. Either a numeric vector containing the
  indices of the corresponding states, or a character
  vector defining the types of the corresponding states.
  Possible choices are \dQuote{all}, \dQuote{arima},
  \dQuote{custom}, \dQuote{cycle}, \dQuote{seasonal},
  \dQuote{trend}, or \dQuote{regression}. These can be
  combined. Default is \dQuote{all}.}

  \item{nsim}{Number of independent samples used in
  importance sampling. Used only for non-Gaussian models.}

  \item{se.fit}{If TRUE, standard errors are computed.
  Default is FALSE.}

  \item{prob}{if TRUE (default), the predictions in
  binomial case are probabilities instead of counts.}

  \item{maxiter}{The maximum number of iterations used in
  approximation Default is 50. Only used for non-Gaussian
  model.}

  \item{\dots}{Ignored.}
}
\value{
A matrix or list of matrices containing the predictions,
and optionally standard errors.
}
\description{
Function \code{predict.SSModel} predicts the future
observations of a state space model of class
\code{\link{SSModel}}
}
\details{
For non-Gaussian models, the results depend whether
importance sampling is used (\code{nsim>0}). without
simulations, the confidence intervals in response scale are
computed in linear predictor scale, and then transformed to
response scale. The prediction intervals are not supported.
With importance sampling, the confidence intervals are
computed as the empirical quantiles from the weighted
sample, whereas the prediction intervals contain additional
step of simulating the response variables from the sampling
distribution \eqn{p(y|\theta^i)}.

If no simulations are used, the standard errors in response
scale are computed using delta method.
}
\examples{
\dontrun{
set.seed(1)
x<-runif(n=100,min=1,max=3)
y<-rpois(n=100,lambda=exp(-1+x))
model<-SSModel(y~x,distribution="poisson")
xnew<-seq(0.5,3.5,by=0.1)
newdata<-SSModel(rep(NA,length(xnew))~xnew,distribution="poisson")
pred<-predict(model,newdata=newdata,interval="prediction",level=0.9,nsim=1000)
plot(x=x,y=y,pch=19,ylim=c(0,25),xlim=c(0.5,3.5))
matlines(x=xnew,y=pred,col=c(2,2,2),lty=c(1,2,2),type="l")

model<-SSModel(Nile~SSMtrend(1,Q=1469),H=15099)
pred<-predict(model,n.ahead=10,interval="prediction",level=0.9)
}
}

####$$$$ KFAS\man/print.KFS.Rd
\name{print.KFS}
\alias{print.KFS}
\title{Print Ouput of Kalman Filter and Smoother}
\usage{
\method{print}{KFS}(x, digits = max(3L, getOption("digits") - 3L), ...)
}
\arguments{
  \item{x}{output object from function KFS.}

  \item{digits}{minimum number of digits to be printed.}

  \item{...}{Ignored.}
}
\description{
Print Ouput of Kalman Filter and Smoother
}

####$$$$ KFAS\man/print.SSModel.Rd
\name{print.SSModel}
\alias{print.SSModel}
\title{Print SSModel Object}
\usage{
\method{print}{SSModel}(x, ...)
}
\arguments{
  \item{x}{SSModel object}

  \item{...}{Ignored.}
}
\description{
Print SSModel Object
}

####$$$$ KFAS\man/residuals.KFS.Rd
\name{residuals.KFS}
\alias{residuals.KFS}
\title{Extract Residuals of KFS output}
\usage{
\method{residuals}{KFS}(object, type = c("recursive", "deviance", "pearson",
  "response", "state"), ...)
}
\arguments{
  \item{object}{KFS object}

  \item{type}{Character string defining the type of
  residuals.}

  \item{...}{Ignored.}
}
\description{
Extract Residuals of KFS output
}
\details{
For object of class KFS, several types of residuals can be
computed:

\itemize{ \item 'recursive': One-step ahead prediction
residuals \deqn{v_{t,i}),} with residuals being undefined
in diffuse phase. Only supported for fully Gaussian models.

\item 'response': Data minus fitted values,
\eqn{y-E(y)}{y-E(y)}.

\item 'pearson':
\deqn{(y_{t,i}-\theta_{t,i})/\sqrt{V(\mu)_{t,i}}, \quad
i=1,\ldots,p,t=1,\ldots,n,}{(y[t,i]-\theta[t,i])V(\mu)[t,i]^(-0.5),
i=1,\ldots,p, t=1,\ldots,n,} where
\eqn{V(\mu_{t,i})}{V(\mu[t,i])} is the variance function of
the model.

\item 'state': Residuals based on the smoothed disturbance
terms \eqn{\eta} are defined as \deqn{\hat \eta_t, \quad
t=1,\ldots,n,}{L^{-1}[t] \eta[t], t=1,\ldots,n}.

\item 'deviance': Deviance residuals. }
}

####$$$$ KFAS\man/rstandard.KFS.Rd
\name{rstandard.KFS}
\alias{rstandard.KFS}
\title{Extract Standardized Residuals from KFS output}
\usage{
\method{rstandard}{KFS}(model, type = c("recursive", "deviance", "pearson",
  "state"), ...)
}
\arguments{
  \item{model}{KFS object}

  \item{type}{Type of residuals. See details.}

  \item{...}{Ignored.}
}
\description{
Extract Standardized Residuals from KFS output
}
\details{
For object of class KFS, several types of standardized
residuals can be computed: \itemize{

\item 'recursive': One-step ahead prediction residuals
defined as \deqn{v_{t,i})/\sqrt{F_{i,t}},} with residuals
being undefined in diffuse phase. Only supported for fully
Gaussian models.

\item 'pearson': Standardized Pearson residuals
\deqn{(y_{t,i}-\theta_{t,i})/\sqrt{V(\mu)_{t,i}\phi_i\sqrt{1-h_{t,i}}},
\quad
i=1,\ldots,p,t=1,\ldots,n,}{(y[t,i]-\theta[t,i])/(V(\mu)[t,i]\phi[i](1-h[t,i]))^0.5,
i=1,\ldots,p, t=1,\ldots,n,} where
\eqn{V(\mu_{t,i})}{V(\mu[t,i])} is the variance function of
the model, \eqn{\phi_i}{\phi[i]} is the dispersion
parameter and \eqn{h_{t,i}}{h[t,i]} is the hat value.  For
gaussian models, these coincide with the smoothed
\eqn{\epsilon} disturbance residuals.

\item 'state': Residuals based on the smoothed disturbance
terms \eqn{\eta} are defined as \deqn{L^{-1}_t \hat \eta_t,
\quad t=1,\ldots,n,}{L^{-1}[t] \eta[t], t=1,\ldots,n,}
where \eqn{L_t}{L[t]} is the lower triangular matrix from
Cholesky decomposition of \eqn{V_{\eta,t}}{V[\eta,t]}.

\item 'deviance': Deviance residuals. }
}

####$$$$ KFAS\man/sexratio.Rd
\docType{data}
\name{sexratio}
\alias{sexratio}
\title{Number of males and females born in Finland from 1751 to 2011}
\format{A time series object containing the number of males and females born in Finland from 1751 to 2011.}
\source{
Statistics Finland
}
\description{
A time series object containing the number of males and
females born in Finland from 1751 to 2011.
}
\keyword{datasets}

####$$$$ KFAS\man/signal.Rd
\name{signal}
\alias{signal}
\title{Extracting the Partial Signal Of a State Space Model}
\usage{
signal(object, states = "all", filtered = FALSE)
}
\arguments{
  \item{object}{Object of class \code{KFS}.}

  \item{states}{Which states are combined? Either a numeric
  vector containing the indices of the corresponding
  states, or a character vector defining the types of the
  corresponding states. Possible choices are \dQuote{all},
  \dQuote{arima}, \dQuote{custom}, \dQuote{cycle},
  \dQuote{seasonal}, \dQuote{trend}, or
  \dQuote{regression}. These can be combined. Default is
  \dQuote{all}.}

  \item{filtered}{If TRUE, filtered signal is used.
  Otherwise smoothed signal is used.}
}
\value{
\item{signal}{Time series object of filtered signal
\eqn{Z_ta_t}{Z[t]a[t]} or smoothed signal
\eqn{Z_t\hat\alpha_t}{Z[t]\alpha[t]} using only the defined
states.  } \item{variance}{Cov(\eqn{Z_ta_t}{Z[t]a[t]}) or
Cov(\eqn{Z_t\hat\alpha_t}{Z[t]\alpha[t]}) using only the
defined states. For the covariance matrices of the filtered
signal, only the non-diffuse part P is used.  }
}
\description{
Function \code{signal} returns the signal of a state space
model using only subset of states.
}

####$$$$ KFAS\man/simulateSSM.Rd
\name{simulateSSM}
\alias{simulateSSM}
\title{Simulation of a gaussian State Space Model}
\usage{
simulateSSM(object, type = c("states", "signals", "disturbances",
  "observations", "epsilon", "eta"), filtered = FALSE, nsim = 1,
  antithetics = FALSE, conditional = TRUE)
}
\arguments{
  \item{object}{gaussian state space object.}

  \item{type}{What to simulate.}

  \item{filtered}{Simulate from
  \eqn{p(\alpha_t|y_{t-1},...,y_1)} instead of
  \eqn{p(\alpha|y)}.}

  \item{nsim}{Number of independent samples. Default is 1.}

  \item{antithetics}{Use antithetic variables in
  simulation. Default is FALSE.}

  \item{conditional}{Simulations are conditional to data.
  If FALSE, the initial state \eqn{\alpha_1}{\alpha[1]} is
  set to \eqn{\hat \alpha_1}{alphahat[1]} computed by
  \code{KFS}, and all the observations are removed from the
  model. Default is TRUE.}
}
\value{
An n x k x nsim array containing the simulated series,
where k is number of observations, signals, states or
disturbances.
}
\description{
Function \code{simulateSMM} simulates states, signals,
disturbances or missing observations of the gaussian state
space model.
}
\details{
Simulation smoother algorithm is based to article by J.
Durbin and S.J. Koopman (2002).

Function can use two antithetic variables, one for location
and other for scale, so output contains four blocks of
simulated values which correlate which each other (ith
block correlates negatively with (i+1)th block, and
positively with (i+2)th block etc.).
}
\references{
Durbin J. and Koopman, S.J. (2002). A simple and efficient
simulation smoother for state space time series analysis,
Biometrika, Volume 89, Issue 3
}

####$$$$ KFAS\man/SSModel.Rd
\name{SSMarima}
\alias{SSMarima}
\alias{SSMcustom}
\alias{SSMcycle}
\alias{SSModel}
\alias{SSMregression}
\alias{SSMseasonal}
\alias{SSMtrend}
\title{Create a State Space Model Object of Class SSModel}
\usage{
SSMarima(ar = NULL, ma = NULL, d = 0, Q, stationary = TRUE, index, n,
  ynames)

SSMcustom(Z, T, R, Q, a1, P1, P1inf, index, n)

SSMcycle(period, type, Q, index, a1, P1, P1inf, n, ynames)

SSModel(formula, data, H, u, distribution, tol = .Machine$double.eps^0.5)

SSMregression(rformula, data, type, Q, index, R, a1, P1, P1inf, n, ynames)

SSMseasonal(period, sea.type = c("dummy", "trigonometric"), type, Q, index,
  a1, P1, P1inf, n, ynames)

SSMtrend(degree = 1, type, Q, index, a1, P1, P1inf, n, ynames)
}
\arguments{
  \item{formula}{an object of class \code{\link{formula}}
  containing the symbolic description of the model. The
  intercept term can be removed with \code{-1} as in
  \code{lm}. In case of trend or differenced arima
  component intercept is removed automatically. Note that
  in order to be compatible with nonstationary elements,
  first level of each factor is always added to intercept,
  so if intercept is removed via \code{-1}, one level will
  be missing. See details and examples in
  \code{\link{KFAS}} for special functions used in model
  construction.}

  \item{data}{an optional data frame, list or environment
  containing the variables in the model.}

  \item{H}{covariance matrix or array of disturbance terms
  \eqn{\epsilon_t}{\epsilon[t]} of observation equation.
  Omitted in case of non-gaussian distributions. Augment
  the state vector if you want to add additional noise.}

  \item{u}{additional parameters for non-gaussian models.
  See details in \code{\link{KFAS}}.}

  \item{distribution}{a vector of distributions of the
  observations. Default is \code{rep('gaussian',p)}.}

  \item{tol}{a tolerance parameter for a diffuse phase.
  Smallest value of Finf not counted for zero.  Defaults to
  \code{.Machine$double.eps^0.5}.  If smoothing gives
  negative variances for smoothed states, try adjusting
  this.}

  \item{index}{a vector indicating for which series the
  corresponding components are constructed.}

  \item{type}{for cycle, seasonal, trend and regression
  components, character string defining if
  \code{'distinct'} or \code{'common'} states are used for
  different series.}

  \item{Q}{for arima, cycle and seasonal component, a
  \eqn{p \times p}{p x p} covariance matrix of the
  disturbances (or in the time varying case \eqn{p \times p
  \times n}{p x p x n} array), where where
  p=\code{length(index)}.  For trend component, list of
  length \code{degree} containing the \eqn{p \times p} or
  \eqn{p \times p \times n} covariance matrices. For a
  custom component, arbitrary covariance matrix or array of
  disturbance terms \eqn{\eta_t}{\eta[t]}}

  \item{a1}{optional \eqn{m \times 1}{m x 1} matrix giving
  the expected value of the initial state vector
  \eqn{\alpha_1}{\alpha[1]}.}

  \item{P1}{optional \eqn{m \times m}{m x m} matrix giving
  the covariance matrix of \eqn{\alpha_1}{\alpha[1]}.  In
  the diffuse case the non-diffuse part of
  \eqn{P_1}{P[1]}.}

  \item{P1inf}{optional \eqn{m \times m}{m x m} matrix
  giving the diffuse part of \eqn{P_1}{P[1]}. Diagonal
  matrix with ones on diagonal elements which correspond to
  the unknown initial states.}

  \item{R}{for a custom and regression components, optional
  \eqn{m \times k} system matrix or array of transition
  equation.}

  \item{ar}{for arima component, a numeric vector
  containing the autoregressive coeffients.}

  \item{ma}{for arima component, a numericvector containing
  the moving average coeffients.}

  \item{d}{for arima component, a degree of differencing.}

  \item{stationary}{for arima component, logical value
  indicating whether a stationarity of the arima part is
  assumed. Defaults to TRUE.}

  \item{Z}{for a custom component, system matrix or array
  of observation equation.}

  \item{T}{for a custom component, system matrix or array
  of transition equation.}

  \item{period}{for a cycle and seasonal components, the
  length of the cycle/seasonal pattern.}

  \item{sea.type}{for seasonal component, character string
  defining whether to use \code{'dummy'} or
  \code{'trigonometric'} form of the seasonal component.}

  \item{degree}{for trend component, integer defining the
  degree of the polynomial trend. 1 corresponds to local
  level, 2 for local linear trend and so forth.}

  \item{rformula}{for regression component, right hand side
  formula or list of of such formulas defining the custom
  regression part.}

  \item{n}{length of the series, only used internally for
  dimensionality check.}

  \item{ynames}{names of the times series, only used
  internally.}
}
\value{
object of class \code{SSModel}, which is a list with the
following components: \item{y}{A n x p matrix containing
the observations. } \item{Z}{A p x m x 1 or p x m x n array
corresponding to the system matrix of observation equation.
} \item{H}{A p x p x 1 or p x p x n array corresponding to
the covariance matrix of observational disturbances
epsilon. } \item{T}{A m x m x 1 or m x m x n array
corresponding to the first system matrix of state equation.
} \item{R}{A m x k x 1 or m x k x n array corresponding to
the second system matrix of state equation. } \item{Q}{A k
x k x 1 or k x k x n array corresponding to the covariance
matrix of state disturbances eta } \item{a1}{A m x 1 matrix
containing the expected values of the initial states. }
\item{P1}{A m x m matrix containing the covariance matrix
of the nondiffuse part of the initial state vector. }
\item{P1inf}{A m x m matrix containing the covariance
matrix of the diffuse part of the initial state vector. }
\item{u}{A n x p matrix of an additional parameters in case
of non-Gaussian model.} \item{distribution}{A vector of
length p giving the distributions of the observations. }
\item{tol}{A tolerance parameter for the diffuse phase. }
\item{call}{Original call to the function. } In addition,
object of class \code{SSModel} contains following
attributes: \item{names}{Names of the list components. }
\item{p, m, k, n}{Integer valued scalars defining the
dimensions of the model components. }
\item{state_types}{Types of the states in the model. }
}
\description{
Function \code{SSModel} creates a state space object object
of class \code{SSModel} which can be used as an input
object for various functions of \code{KFAS} package.
}
\details{
Formula of the model can contain the usual regression part
and additional functions defining different types of
components of the model, named as \code{SSMarima},
\code{SSMcustom}, \code{SSMcycle}, \code{SSMregression},
\code{SSMseasonal} and \code{SSMtrend}.
}
\examples{
\dontrun{
examplemodel<-SSModel(cbind(y1,y2,y3)  ~ x1+x2
+ SSMregression(~-1+x3+x4,data=dataset,type='common',index=c(1,3),Q=diag(c(0.05,0.1)))
+ SSMtrend(degree=1,index=1,Q=list(matrix(0.2)))
+ SSMtrend(degree=2,index=2:3,Q=list(matrix(c(0.2,0.1,0.1,0.2),2,2),diag(0.07,2)))
+ SSMcycle(period=25,Q=matrix(c(0.3,0.2,0.1,0.2,0.4,0.05,0.1,0.05,0.1),3,3))
, data=dataset, H=matrix(c(1,0.7,0.7,0.7,1,0.7,0.7,0.7,1),3,3))
}
}
\seealso{
\code{\link{KFAS}} for examples.
}

####$$$$ KFAS\man/transformSSM.Rd
\name{transformSSM}
\alias{transformSSM}
\title{Transform the SSModel object with multivariate observations}
\usage{
transformSSM(object, type = c("ldl", "augment"))
}
\arguments{
  \item{object}{State space model object from function
  SSModel.}

  \item{type}{Option \code{'ldl'} performs LDL
  decomposition for covariance matrix \eqn{H_t}{H[t]}, and
  multiplies the observation equation with the
  \eqn{L_t^{-1}}{L[t]^-1}, so \eqn{\epsilon_t^* \sim
  N(0,D_t)}{\epsilon[t]* ~ N(0,D[t])}. Option
  \code{'augment'} adds \eqn{\epsilon_t}{\epsilon[t]} to
  the state vector, when \eqn{Q_t}{Q[t]} becomes block
  diagonal with blocks \eqn{Q_t}{Q[t]} and
  \eqn{H_t}{H[t]}.}
}
\value{
\item{model}{Transformed model.}
}
\description{
Function transform.SSModel transforms original model by LDL
decomposition or state vector augmentation,
}
\details{
As all the functions in KFAS use univariate approach,
\eqn{H_t}{H[t]}, a covariance matrix of an observation
equation needs to be either diagonal or zero matrix.
Function transformSSM performs either the LDL decomposition
of the covariance matrix of the observation equation, or
augments the state vector with the disturbances of the
observation equation.

In case of a LDL decomposition, the new \eqn{H_t}{H[t]}
contains the diagonal part of the decomposition, whereas
observations \eqn{y_t}{Z[t]} and system matrices
\eqn{Z_t}{Z[t]} are multiplied with the inverse of
\eqn{L_t}{L[t]}.
}

####$$$$ KFAS\R/approxSSM.R
#' Linear Gaussian Approximation for Exponential Family State Space Model
#'
#' Function \code{approxSMM} computes the linear Gaussian approximation of a
#' state space model where observations follow an exponential family distribution.
#'
#' The linear Gaussian approximating model is defined by
#' \deqn{\tilde y_t = Z_t \alpha_t + \epsilon_t, \quad \epsilon_t \sim N(0,\tilde H_t),}{ytilde[t] = Z[t]\alpha[t] + \epsilon[t], \epsilon[t] ~ N(0,Htilde[t]),}
#' \deqn{\alpha_{t+1} = T_t \alpha_t + R_t \eta_t, \quad \eta_t \sim N(0,Q_t),}{\alpha[t+1] = T[t]\alpha[t] + R[t]\eta[t], \eta[t] ~ N(0,Q[t]),}
#' and \eqn{\alpha_1 \sim N(a_1,P_1)}{\alpha[1] ~ N(a[1],P[1])}, 
#' where \eqn{\tilde y}{ytilde} and \eqn{\tilde H}{Htilde} are chosen in a way that the linear
#' Gaussian approximating model has the same conditional mode of \eqn{\theta=Z\alpha} 
#' given the observations \eqn{y} as the original non-gaussian model. 
#' Models also have a same curvature at the mode.
#'
#' The approximation of the exponential family state space model is based on iterative weighted 
#' least squares method, see McCullagh and Nelder (1983) p.31 and Durbin Koopman (2012) p. 243.
#'  
#' @seealso Importance sampling of non-Gaussian state space models \code{\link{importanceSSM}}, 
#' construct a \code{SSModel} object \code{\link{SSModel}}, and examples in \code{\link{KFAS}}.
#' @export
#' @param model A non-Gaussian state space model object of class \code{SSModel}.
#' @param theta Initial values for conditional mode theta.
#' @param maxiter The maximum number of iterations used in approximation Default is 50.
#' @param tol Tolerance parameter for convergence checks.
#'  Iterations are continued until 
#'  \eqn{tol>abs(dev_{old}-dev_{new})/(abs(dev_{new})+0.1))}.
#' @return An object which contains the approximating Gaussian state space model with following additional components:
#' \item{thetahat}{Mode of \eqn{p(\theta|y)}. }
#' \item{iterations}{Number of iterations used. }
approxSSM <- function(model, theta, maxiter = 50, tol = 1e-15) {
  
  # Check that the model object is of proper form
  is.SSModel(model, na.check = TRUE, return.logical = FALSE)
  if (all(model$distribution == "gaussian")) 
    stop("Model is completely Gaussian, nothing to approximate.")
  p <- attr(model, "p")
  m <- attr(model, "m")
  k <- attr(model, "k")
  n <- attr(model, "n")
  
  tv <- array(0, dim = 5)
  tv[1] <- dim(model$Z)[3] > 1
  tv[2] <- 1
  tv[3] <- dim(model$T)[3] > 1
  tv[4] <- dim(model$R)[3] > 1
  tv[5] <- dim(model$Q)[3] > 1
  
  ymiss <- is.na(model$y)
  storage.mode(ymiss) <- "integer"
  if(is.null(maxiter)) maxiter<-50
  if(is.null(tol)) tol<-1e-8
  # initial values for linear predictor theta
  if (missing(theta) || is.null(theta)) {
    theta <- sapply(1:p, function(i) 
      switch(model$distribution[i], 
             gaussian = model$y[, i], 
             poisson = log(pmax(model$y[, i]/model$u[, i], 0.1, na.rm = TRUE)), 
             binomial = qlogis((ifelse(is.na(model$y[, i]), 0.5, model$y[, i]) + 0.5)/(model$u[, i] + 1)), 
             gamma = log(pmax(model$y[, i], 1, na.rm = TRUE)), 
             `negative binomial` = log(pmax(model$y[, i], 1/6, na.rm = TRUE))))
  } else theta <- array(theta, dim = c(n, p))
 
  # call Fortran subroutine for model approximation
  out <- .Fortran(fapprox, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z, 
                  model$T, model$R, Htilde = array(0, c(p, p, n)), model$Q, 
                  model$a1, model$P1, model$P1inf, as.integer(p), as.integer(n),
                  as.integer(m),as.integer(k), theta = theta, model$u, 
                  ytilde = array(0, dim = c(n, p)), 
                  pmatch(x = model$distribution, 
                         table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                         duplicates.ok = TRUE), maxiter = as.integer(maxiter), 
                  model$tol, as.integer(sum(model$P1inf)), as.double(tol),diff=double(1))
  
  if (!is.finite(out$diff)){
    stop("Non-finite difference in approximation algoritm.")
  }
  if(out$maxiter==maxiter){
    warning(paste("Maximum number of iterations reached, 
                  the approximation algorithm did not converge. Latest difference was",out$diff))
  }
  
  model$distribution <- rep("gaussian", p)
  model$y[] <- out$ytilde
  model$y[as.logical(ymiss)] <- NA
  model$H <- out$Htilde
  model$thetahat <- out$theta
  model$iterations <- out$maxiter
  model$difference <- out$diff
  class(model) <- c("approxSSM", "SSModel")
  invisible(model)
} 
####$$$$ KFAS\R/artransform.R
#' Mapping real valued parameters to stationary region
#'
#' Function \code{artransform} transforms \eqn{p} real valued parameters to 
#' stationary region of \eqn{p}th order autoregressive process using 
#' parametrization suggested by Jones (1980), except the same modification 
#' is done as in \code{arima}.
#'
#' @export
#' @param param Real valued parameters for the transformation.
#' @return transformed The parameters satisfying the stationary constrains.
artransform<-function(param){
  param<-tanh(param)
  p<-length(param)
  .Fortran("fartransform", as.double(param), phi = diag(param,p),
           as.integer(p))$phi[p,]
  
}####$$$$ KFAS\R/checkModel.R
#' Test whether object is a valid \code{SSModel} object
#'
#' Function \code{is.SSModel} tests whether the object is a valid \code{SSModel} object.
#'
#' Note that the validity of the values in \code{y} and \code{Z} are not tested. 
#' These can contain NA values (but not infinite values),  with condition that when \code{Z[i,,t]} 
#' contains NA value, the corresponding \code{y[t,i]} must also have NA value. In this case 
#' \code{Z[i,,t]} is not referenced in filtering and smoothing, and algorithms works properly. 
#' Note also that this does result NA values in \code{thetahat}, so it could be beneficial to use 
#' for example zeroes in place of NA values in Z, making first sure that the above condition is met.
#'  
#' @export
#' @rdname checkModel
#' @aliases is.SSModel
#' @param object An object to be tested.
#' @param na.check Test the system matrices for NA and infinite values. Default is \code{FALSE}.
#' @param return.logical If \code{FALSE}, error is given if the the model is not a 
#' valid \code{SSModel} object. Otherwise logical value is returned. Defaults to \code{FALSE}.
#' @return Logical value or nothing, depending on the value of \code{return.logical}.
is.SSModel <- function(object, na.check = FALSE, return.logical = TRUE) {
    
    p <- attr(object, "p")
    m <- attr(object, "m")
    k <- attr(object, "k")
    n <- attr(object, "n")
    one <- as.integer(1)
    
    if (return.logical) {
        x <- inherits(object, "SSModel") && all(c("y", "Z", "H", "T", "R", "Q", "a1", "P1", "P1inf", "u", "distribution", "tol", 
            "call") %in% names(object)) && all(object$distribution %in% c("gaussian", "poisson", "binomial", "gamma", "negative binomial")) && 
            identical(dim(object$y), c(n, p)) && (identical(dim(object$Z), c(p, m, n)) || identical(dim(object$Z), c(p, m, one))) && 
            (object$H == "Omitted" || identical(dim(object$H), c(p, p, n)) || identical(dim(object$H), c(p, p, one))) && (identical(dim(object$T), 
            c(m, m, n)) || identical(dim(object$T), c(m, m, one))) && (identical(dim(object$R), c(m, k, n)) || identical(dim(object$R), 
            c(m, k, one))) && (identical(dim(object$Q), c(k, k, n)) || identical(dim(object$Q), c(k, k, one))) && identical(dim(object$a1), 
            c(m, one)) && identical(dim(object$P1), c(m, m)) && identical(dim(object$P1inf), c(m, m)) && (object$u == "Omitted" || 
            identical(dim(object$u), dim(object$y)))
        if (na.check) 
            x <- x && !any(sapply(c("H", "u", "T", "R", "Q", "a1", "P1", "P1inf"), function(x) any(is.na(object[[x]])) | any(is.infinite(object[[x]]))))
        x
    } else {
        if (!inherits(object, "SSModel")) 
            stop("Object is not of class 'SSModel'")
        
        if (!all(object$distribution %in% c("gaussian", "poisson", "binomial", "gamma", "negative binomial"))) 
            stop("The distributions of the observations are not valid. Possible choices are 'gaussian', 'poisson', 'binomial', 'gamma' and ,'negative binomial'.")
        
        if (na.check == TRUE && any(sapply(c("H", "u", "T", "R", "Q", "a1", "P1", "P1inf"), function(x) any(is.na(object[[x]])) | 
            any(is.infinite(object[[x]]))))) 
            stop("System matrices (excluding Z) contain NA or infinite values.")
        
        components <- c("y", "Z", "H", "T", "R", "Q", "a1", "P1", "P1inf", "u", "distribution", "tol", "call")
        if (!all(components %in% names(object))) 
            stop(paste("Model is not a proper object of class 'SSModel'. Following components are missing: ", paste(components[!(components %in% 
                names(object))], collapse = ", ")))
        if (!(identical(dim(object$y), c(n, p)) && (identical(dim(object$Z), c(p, m, n)) || identical(dim(object$Z), c(p, m, one))) && 
            (object$H == "Omitted" || identical(dim(object$H), c(p, p, n)) || identical(dim(object$H), c(p, p, one))) && (identical(dim(object$T), 
            c(m, m, n)) || identical(dim(object$T), c(m, m, one))) && (identical(dim(object$R), c(m, k, n)) || identical(dim(object$R), 
            c(m, k, one))) && (identical(dim(object$Q), c(k, k, n)) || identical(dim(object$Q), c(k, k, one))) && identical(dim(object$a1), 
            c(m, one)) && identical(dim(object$P1), c(m, m)) && identical(dim(object$P1inf), c(m, m)) && (object$u == "Omitted" || 
            identical(dim(object$u), dim(object$y))))) 
            stop("Model is not a proper object of class 'SSModel'. Check dimensions of system matrices.")
    }
    
} 
####$$$$ KFAS\R/coef.KFS.R
#' Extract Estimated States of State Space Model
#' 
#' Extracts the estimates states from output of \code{KFS}. For non-Gaussian models without simulation, 
#' these are estimates of conditional modes of states. For Gaussian models and non-Gaussian 
#' models with importance sampling, these are estimates of conditional means of states.
#' 
#' @S3method coef KFS
#' @method coef KFS
#' @param object An object of class \code{KFS}.
#' @param start The start time of the period of interest. Defaults to first time point of the object
#' @param end The end time of the period of interest. Defaults to the last time point of the object.
#' @param filtered Logical, return filtered instead of smoothed estimates of state vector.
#' Default is \code{FALSE}.
#' @param \dots Ignored.
#' @return Multivariate time series containing estimates states.
coef.KFS<-function(object,start=NULL,end=NULL,filtered=FALSE,...){
  if(!filtered){
    if(!is.null(object$alphahat)){
      tmp<-object$alphahat
    } else stop("Input does not contain smoothed estimates for states, rerun KFS with state smoothing.")   
  } else {
    if(!is.null(object[["a",exact=TRUE]])){
      tmp<-object$a
    } else stop("Input does not contain filtered estimates for states, rerun KFS with state filtering.") 
  }
  tmp<-window(tmp,start=start,end=end)
  if(start==end && !is.null(start))
    tsp(tmp) <- class(tmp) <- NULL
  drop(tmp)
}####$$$$ KFAS\R/deviance.KFS.R
#' Deviance of a State Space Model
#' 
#' Returns the deviance of a object of class \code{KFS}.
#' @S3method deviance KFS
#' @method deviance KFS
#' @param object An object of class \code{KFS}.
#' @param \dots Ignored.
#' @return The value of the deviance extracted from object.
deviance.KFS<-function(object,...){
 sum(residuals(object,type="deviance")^2,na.rm=TRUE)
}####$$$$ KFAS\R/extract.SSModel.R
#' Extract or Replace Parts of a State Space Model
#'
#' S3 methods for extracting or replacing parts of objects of class \code{SSModel}. These methods 
#' ensure that dimensions of system matrices are not altered. \code{[} and \code{subset} and 
#' corresponding replacement methods are identical methods with different method names.
#'
#' @method [<- SSModel
#' @S3method [<- SSModel
#' @rdname Extract.SSModel
#' @param x Object of class \code{SSModel}.
#' @param element Which element is chosen. Possible choices are 'y','Z','H','T','R','Q','a1','P1','P1inf', and 'u'.
#' @param states Which states are chosen. Either a numeric vector containing the indices of the corresponding states,
#' or a character vector defining the types of the corresponding states. 
#' Possible choices are \dQuote{all}, \dQuote{arima}, \dQuote{custom}, \dQuote{cycle}, \dQuote{seasonal}, 
#' \dQuote{trend}, or \dQuote{regression}. These can be combined. Default is \dQuote{all}.
#' @param etas Which disturbances eta are chosen. Used for elements \dQuote{R} and \dQuote{Q}.Either a numeric vector containing the indices of the corresponding etas,
#' or a character vector defining the types of the corresponding etas. 
#' Possible choices are \dQuote{all}, \dQuote{arima}, \dQuote{custom}, \dQuote{cycle}, \dQuote{seasonal}, 
#' \dQuote{trend}, or \dQuote{regression}. These can be combined. 
#' @param series Numeric. Which series are chosen. Used for elements \dQuote{y}, \dQuote{Z}, and \dQuote{u}.
#' @param times Numeric. Which time points are chosen.
#' @param value A value to be assigned to x.
#' @return A selected subset of the chosen element or a value.
#' @examples
#' set.seed(1)
#' model<-SSModel(rnorm(10)~1)
#' model["H"]
#' model["H"]<-10
#' # H is still an array:
#' model["H"]
#' logLik(model)
#' model$H<-1
#' # model["H"] throws an error as H is now scalar:
#' model$H
#' logLik(model,check.model=TRUE) #with check.model=FALSE (default) R crashes!

`[<-.SSModel` <- function(x, element, states, etas, series, times, ..., value) {
    
    element <- match.arg(arg = element, choices = c("y", "Z", "H", "T", "R", "Q", "a1", "P1", "P1inf", "u"))
    
    if (!(element %in% c("y", "u", "Q"))) {
        if (missing(states)) {
            states <- 1:attr(x, "m")
        } else {
            if (is.numeric(states)) {
                states <- as.integer(states)
                if (min(states) < 1 | max(states) > attr(x, "m")) 
                  stop("Vector states should contain the indices or names of the states which are modified.")
            } else {
                states <- match.arg(arg = states, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% states) {
                  states <- 1:attr(x, "m")
                } else states <- which(attr(x, "state_types") %in% states)
            }
        }
    }
    if (element %in% c("R", "Q")) {
        if (missing(etas)) {
            etas <- 1:attr(x, "k")
        } else {
            if (is.numeric(etas)) {
                etas <- as.integer(etas)
                if (min(etas) < 1 | max(etas) > attr(x, "k")) 
                  stop("Vector etas should contain the indices or names of the etas which are modified.")
            } else {
                etas <- match.arg(arg = etas, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% etas) {
                  etas <- 1:attr(x, "k")
                } else etas <- which(attr(x, "eta_types") %in% etas)
            }
        }
    }
    if (element %in% c("y", "u", "Z")) {
        if (missing(series)) {
            series <- 1:attr(x, "p")
        } else if (!all(series %in% (1:attr(x, "p")))) 
            stop("Argument series must have values between 1 to p, where p is the number of time series in model. ")
    }
    
    if (missing(times)) {
        switch(element, y = , u = x[[element]][, series] <- value, Z = x[[element]][series, states, ] <- value, H = x[[element]][series, 
            series, ] <- value, T = x[[element]][states, states, ] <- value, R = x[[element]][states, etas, ] <- value, Q = x[[element]][etas, 
            etas, ] <- value, a1 = x[[element]][states, 1] <- value, P1 = x[[element]][states, states] <- value, P1inf = x[[element]][states, 
            states] <- value, )
        
    } else {
        switch(element, y = , u = x[[element]][times, series] <- value, Z = x[[element]][series, states, times] <- value, H = x[[element]][series, 
            series, times] <- value, T = x[[element]][states, states, times] <- value, R = x[[element]][states, etas, times] <- value, 
            Q = x[[element]][etas, etas, times] <- value, a1 = x[[element]][states, 1] <- value, P1 = x[[element]][states, states] <- value, 
            P1inf = x[[element]][states, states] <- value, )
    }
    
    x
}
#' @method [ SSModel
#' @S3method [ SSModel
#' @rdname Extract.SSModel
`[.SSModel` <- function(x, element, states, etas, series, times, ...) {
    
    # is.SSModel(x,return.logical=FALSE)
    element <- match.arg(arg = element, choices = c("y", "Z", "H", "T", "R", "Q", "a1", "P1", "P1inf", "u"))
    
    if (!(element %in% c("y", "u", "Q"))) {
        if (missing(states)) {
            states <- 1:attr(x, "m")
        } else {
            if (is.numeric(states)) {
                states <- as.integer(states)
                if (min(states) < 1 | max(states) > attr(x, "m")) 
                  stop("Vector states should contain the indices or types of the states which are modified.")
            } else {
                states <- match.arg(arg = states, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% states) {
                  states <- 1:attr(x, "m")
                } else states <- which(attr(x, "state_types") %in% states)
            }
        }
    }
    if (element %in% c("R", "Q")) {
        if (missing(etas)) {
            etas <- 1:attr(x, "k")
        } else {
            if (is.numeric(etas)) {
                etas <- as.integer(etas)
                if (min(etas) < 1 | max(etas) > attr(x, "k")) 
                  stop("Vector etas should contain the indices or types of the etas which are modified.")
            } else {
                etas <- match.arg(arg = etas, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% etas) {
                  etas <- 1:attr(x, "k")
                } else etas <- which(attr(x, "eta_types") %in% etas)
            }
        }
    }
    if (element %in% c("y", "u", "Z")) {
        if (missing(series)) {
            series <- 1:attr(x, "p")
        } else if (!all(series %in% (1:attr(x, "p")))) 
            stop("Argument series must have values between 1 to p, where p is the number of time series in model. ")
    }
    
    if (missing(times)) {
        switch(element, y = , u = x[[element]][, series,drop=FALSE], Z = x[[element]][series, states, ,drop=FALSE], 
               H = x[[element]][series, series, ,drop=FALSE
            ], T = x[[element]][states, states, ,drop=FALSE], R = x[[element]][states, etas, ,drop=FALSE], 
               Q = x[[element]][etas, etas,,drop=FALSE ], a1 = x[[element]][states, 
            1,drop=FALSE], P1 = x[[element]][states, states,drop=FALSE], P1inf = x[[element]][states, states,drop=FALSE], )
        
    } else {
        switch(element, y = , u = x[[element]][times, series,drop=FALSE], Z = x[[element]][series, states, times,drop=FALSE], H = x[[element]][series, 
            series, times,drop=FALSE], T = x[[element]][states, states, times,drop=FALSE], R = x[[element]][states, etas, times,drop=FALSE], Q = x[[element]][etas, 
            etas, times,drop=FALSE], a1 = x[[element]][states, 1,drop=FALSE], P1 = x[[element]][states, states,drop=FALSE], P1inf = x[[element]][states, states,drop=FALSE], 
            )
    }
    
} 
####$$$$ KFAS\R/fitSSM.R
#' Maximum Likelihood Estimation of a State Space Model
#'
#' Function \code{fitSSM} finds the maximum likelihood estimates for
#' unknown parameters of an arbitary state space model, given the user-defined model updating function.
#'
#'
#' @export
#' @param inits Initial values for \code{optim}
#' @param model Model object of class \code{SSModel}.
#' @param updatefn User defined function which updates the model given the parameters. 
#' Must be of form \code{updatefn(pars, model,...)}, i.e. must contain ellipsis \code{...}. 
#' If not supplied, a default function is used, which estimates the values marked as NA in time invariant covariance matrices Q and H.
#' @param checkfn Optional function for model checking. 
#' If supplied, after updating the model, if \code{checkfn(model)} returns TRUE, -log-likelihood is computed, 
#' otherwise \code{.Machine$double.xmax} is returned. See examples.
#' If not supplied, check.model=TRUE is used for checking possible NA or Inf values, see ?logLik.SSModel.
#' @param ... Further arguments for functions \code{optim}, \code{updatefn} and \code{logLik.SSModel}, such as \code{method='BFGS'}.
#' @return A list with elements 
#' \item{optim.out}{Output from function \code{optim}. }
#' \item{model}{Model with estimated parameters. }
#' @examples
#' 
#' # Example function for updating covariance matrices H and Q 
#' # (also used as a default function in fitSSM)
#' 
#' updatefn <- function(pars,model,...){       
#' Q<-as.matrix(model$Q[,,1])         
#' naQd  <- which(is.na(diag(Q))) 
#' naQnd <- which(upper.tri(Q[naQd,naQd]) & is.na(Q[naQd,naQd]))  
#' Q[naQd,naQd][lower.tri(Q[naQd,naQd])] <- 0
#' diag(Q)[naQd] <- exp(0.5 * pars[1:length(naQd)])
#' Q[naQd,naQd][naQnd] <- pars[length(naQd)+1:length(naQnd)]
#' model$Q[naQd,naQd,1] <- crossprod(Q[naQd,naQd])
#' if(!identical(model$H,'Omitted')){
#'    H<-as.matrix(model$H[,,1])  
#'    naHd  <- which(is.na(diag(H)))
#'    naHnd <- which(upper.tri(H[naHd,naHd]) & is.na(H[naHd,naHd]))
#'    H[naHd,naHd][lower.tri(H[naHd,naHd])] <- 0         
#'    diag(H)[naHd] <- exp(0.5 * pars[length(naQd)+length(naQnd)+1:length(naHd)])
#'    H[naHd,naHd][naHnd] <- pars[length(naQd)+length(naQnd)+length(naHd)+1:length(naHnd)]
#'    model$H[naHd,naHd,1] <- crossprod(H[naHd,naHd])
#'  }            
#'  
#'  model
#'}
#'
#' # Example function for checking the validity of covariance matrices. 
#'
#' checkfn <- function(model){
#'   #test positive semidefiniteness of H and Q 
#'   inherits(try(ldl(model$H[,,1]),TRUE),'try-error') || 
#'   inherits(try(ldl(model$Q[,,1]),TRUE),'try-error')
#' }
#'


fitSSM <- function(model, inits, updatefn, checkfn, ...) {
    
    # use default updating function, only for time invariant covariance matrices
    if (missing(updatefn)) {
        if (max(dim(model$H)[3], dim(model$Q)[3]) > 1) 
            stop("No model updating function supplied, but cannot use default function as covariance matrices are time varying.")
        updatefn <- function(pars, model, ...) {
            Q <- as.matrix(model$Q[, , 1])
            naQd <- which(is.na(diag(Q)))
            naQnd <- which(upper.tri(Q[naQd, naQd]) & is.na(Q[naQd, naQd]))
            Q[naQd, naQd][lower.tri(Q[naQd, naQd])] <- 0
            diag(Q)[naQd] <- exp(0.5 * pars[1:length(naQd)])
            Q[naQd, naQd][naQnd] <- pars[length(naQd) + 1:length(naQnd)]
            model$Q[naQd, naQd, 1] <- crossprod(Q[naQd, naQd])
            if (!identical(model$H, "Omitted")) {
                H <- as.matrix(model$H[, , 1])
                naHd <- which(is.na(diag(H)))
                naHnd <- which(upper.tri(H[naHd, naHd]) & is.na(H[naHd, naHd]))
                H[naHd, naHd][lower.tri(H[naHd, naHd])] <- 0
                diag(H)[naHd] <- exp(0.5 * pars[length(naQd) + length(naQnd) + 1:length(naHd)])
                H[naHd, naHd][naHnd] <- pars[length(naQd) + length(naQnd) + length(naHd) + 1:length(naHnd)]
                model$H[naHd, naHd, 1] <- crossprod(H[naHd, naHd])
            }
            model
        }
        
    }
    
    is.SSModel(updatefn(inits, model, ...), na.check = TRUE, return.logical = FALSE)
    
    # use is.SSModel as default checking function
    if (missing(checkfn)) { 
        
        likfn <- function(pars, model, ...) {
            model <- updatefn(pars, model, ...)
            -logLik(object = model, check.model = TRUE, ...)
        }
        
    } else {
        
        likfn <- function(pars, model, ...) {
            model <- updatefn(pars, model, ...)
            if (checkfn(model)) {
                return(-logLik(object = model, ...))
            } else return(.Machine$double.xmax)
        }
        
    }
    
    
    out <- NULL
    out$optim.out <- optim(par = inits, fn = likfn, model = model, ...)
    out$model <- updatefn(out$opt$par, model, ...)
    out
} 
####$$$$ KFAS\R/fitted.KFS.R
#' Extract Fitted Values of State Space Model
#' 
#' Extracts fitted values from output of \code{KFS}.
#' @S3method fitted KFS
#' @method fitted KFS
#' @param object An object of class \code{KFS}.
#' @param start The start time of the period of interest. Defaults to first time point of the object.
#' @param end The end time of the period of interest. Defaults to the last time point of the object.
#' @param filtered Logical, return filtered instead of smoothed estimates of mean vector.
#' Default is \code{FALSE}.
#' @param \dots Ignored.
#' @return Multivariate time series containing fitted values.
fitted.KFS<-function(object,start=NULL,end=NULL,filtered=FALSE,...){
  if(!filtered){
    if(!is.null(object$muhat)){
      tmp<-object$muhat
    } else stop("Input does not contain smoothed estimates for means, rerun KFS with mean smoothing.")   
  } else {
    if(!is.null(object$m)){
      tmp<-object$m
    } else stop("Input does not contain filtered estimates for means, rerun KFS with mean filtering.") 
  }
  tmp<-window(tmp,start=start,end=end)
  if(start==end && !is.null(start))
    tsp(tmp) <- class(tmp) <- NULL
  drop(tmp)
}
####$$$$ KFAS\R/hatvalues.KFS.R
#' Extract Hat Values from KFS Output
#'
#' Extract hat values from KFS output, when \code{KFS} was run with signal (non-Gaussian case) 
#' or mean smoothing (Gaussian case). 
#' 
#' @details Hat values are the diagonal elements of 
#' \code{V_t/H_t} where V_t is the covariance matrix of signal/mean at time t and H_t is the 
#' covariance matrix of disturbance vector \eqn{\epsilon} of (approximating) Gaussian model 
#' at time t.
#' @S3method hatvalues KFS
#' @method hatvalues KFS
#' @import stats
#' @param model An object of class \code{KFS}.
#' @param \dots Ignored.
#' @return Multivariate time series containing hat values.
hatvalues.KFS<-function(model,...){
  if(any(model$model$distribution != "gaussian")){
    app<-approxSSM(model$model,theta=model$call$theta,tol=model$call$convtol,maxiter=model$call$maxiter)
    if(is.null(model$V_theta))
      stop("KFS was run without signal smoothing, cannot compute hat values.")
    hatv<-matrix(apply(model$V_theta/app$H, 3, diag), attr(model$model, "n"), attr(model$model,  "p"), 
           byrow = TRUE)
  } else {
    if(is.null(model$V_mu))
      stop("KFS was run without mean smoothing, cannot compute hat values.")
    hatv<-matrix(apply(model$V_mu, 3, diag), attr(model$model, "n"), attr(model$model,  "p"), 
                    byrow = TRUE)/matrix(apply(model$model$H, 3, diag), attr(model$model, "n"), attr(model$model,  "p"), 
                                         byrow = TRUE)
  }
  attributes(hatv)<-attributes(model$model$y)
  hatv
}

####$$$$ KFAS\R/importanceSSM.R
#' Importance Sampling of Exponential Family State Space Model
#'
#' Importance Sampling of Exponential Family State Space Model.
#'
#' Function \code{importanceSSM} simulates states or signals of the exponential family state space 
#' model conditioned with the observations, returning the simulated samples of the states/signals 
#' with the corresponding importance weights.
#'
#' Function can use two antithetic variables, one for location and other for
#' scale, so output contains four blocks of simulated values which correlate
#' which each other (ith block correlates negatively with (i+1)th block, and
#' positively with (i+2)th block etc.).
#' 
#' @export
#' @param model Exponential family state space model of class \code{SSModel}.
#' @param type What to simulate, \code{'states'} or \code{'signals'}. Default is \code{'states'}
#'@param filtered Simulate from \eqn{p(\alpha_t|y_{t-1},...,y_1)} instead of \eqn{p(\alpha|y)}.
#' @param nsim Number of independent samples. Default is 1000.
#' @param save.model Return the original model with the samples. Default is FALSE.
#' @param theta Initial values for conditional mode theta.
#' @param antithetics Logical. If TRUE, two antithetic variables are used in
#' simulations, one for location and another for scale. Default is FALSE.
#' @param maxiter Maximum number of iterations used in linearisation. Default is 50.
#' @return A list containing elements \code{samples}, \code{weights} and \code{model} (if \code{save.model==TRUE}).
importanceSSM <- function(model, type = c("states", "signals"), filtered=FALSE,nsim = 1000, 
                          save.model = FALSE, theta, antithetics = FALSE, maxiter = 50) {
  
  sim.what <- match.arg(arg = type, choices = c("states", "signals"))
  is.SSModel(model, na.check = TRUE, return.logical = FALSE)
  
  p <- attr(model, "p")
  m <- attr(model, "m")
  k <- attr(model, "k")
  n <- attr(model, "n")    
  tv <- array(0, dim = 5)
  tv[1] <- dim(model$Z)[3] > 1
  tv[2] <- 1
  tv[3] <- dim(model$T)[3] > 1
  tv[4] <- dim(model$R)[3] > 1
  tv[5] <- dim(model$Q)[3] > 1
  
  ymiss <- is.na(model$y)
  storage.mode(ymiss) <- "integer"  
  
  # initial values for linear predictor theta
  if (missing(theta)) {
    theta <- sapply(1:p, function(i) switch(model$distribution[i], 
                                            gaussian = model$y[, i], 
                                            poisson = log(pmax(model$y[, i]/model$u[, i], 0.1, na.rm = TRUE)), 
                                            binomial = qlogis((ifelse(is.na(model$y[, i]), 0.5, model$y[, i]) + 0.5)/(model$u[, i] + 1)), 
                                            gamma = log(pmax(model$y[, i], 1, na.rm = TRUE)), 
                                            `negative binomial` = log(pmax(model$y[, i], 1/6, na.rm = TRUE))))
  } else theta <- array(theta, dim = c(n, p))
  
  epsplus <- array(0, c(p, n, nsim))
  etaplus <- array(0, c(k, n, nsim))
  aplus1 <- array(0, dim = c(m, nsim))
  
  x <- array(t(!ymiss), c(p, n, nsim))   
  dfeps <- sum(x)/nsim
  
  x2 <- array(abs(apply(model$Q, 3, diag)) > model$tol, c(k, (n - 1) * tv[5] + 1))
  x2 <- array(x2, c(k, n, nsim))
  dfeta <- sum(x2)/nsim    
  
  nonzero_P1 <- which(diag(model$P1) > model$tol)
  N_nonzero_P1 <- length(nonzero_P1)
  zero_P1inf <- which(diag(model$P1inf) == 0)
  dfu <- dfeps + dfeta + N_nonzero_P1
  u <- rnorm(dfu * nsim, mean = 0, sd = 1)
  if (dfeps > 0) 
    epsplus[x] <- u[1:(dfeps * nsim)]
  if (dfeta > 0) 
    etaplus[x2] <- u[(dfeps * nsim + 1):(dfeps * nsim + dfeta * nsim)]
  if (N_nonzero_P1 > 0) 
    aplus1[nonzero_P1, ] <- u[(dfeps * nsim + dfeta * nsim + 1):(dfu * nsim)]    
  
  c2 <- numeric(nsim)
  
  if (antithetics) {
    for (i in 1:nsim) {
      u <- c(etaplus[, , i], epsplus[, , i], aplus1[, i])
      c2[i] <- t(u) %*% c(u)
    }
    q <- pchisq(c2, df = dfu)
    c2 <- sqrt(qchisq(1 - q, dfu)/c2)
  }  
  
  sim.what<-which(c("epsilon", "eta","disturbances", "states", "signals", "observations")==sim.what)
  simdim <- as.integer(switch(sim.what,p,k,p+k,m,p,p))
  
  if(!filtered){
   
    out <- .Fortran(fisample, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z, model$T, 
                    model$R, model$Q, model$a1, model$P1, model$P1inf, model$u, 
                    dist = pmatch(x = model$distribution, 
                                  table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                                  duplicates.ok = TRUE), as.integer(p), as.integer(n), 
                    as.integer(m),as.integer(k), theta, maxiter = as.integer(maxiter), 
                    as.integer(sum(model$P1inf)), 1e-08, as.integer(N_nonzero_P1), 
                    as.integer(nsim), epsplus, etaplus, aplus1, c2, model$tol, info = integer(1), 
                    as.integer(antithetics), w = numeric(3 * nsim * antithetics + nsim), 
                    sim = array(0, c(simdim, n, 3 * nsim * antithetics + nsim)), 
                    as.integer(zero_P1inf), as.integer(length(zero_P1inf)),sim.what,simdim)
    
  } else{     
    #warning("Filtered samples of non-Gaussian models is at a prototype stage, results can be meaningless.")
    out <- .Fortran(fisamplefilter, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z, model$T, 
                    model$R, model$Q, model$a1, model$P1, model$P1inf, model$u, 
                    dist = pmatch(x = model$distribution, 
                                  table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                                  duplicates.ok = TRUE), as.integer(p), as.integer(n), 
                    as.integer(m),as.integer(k), theta, maxiter = as.integer(maxiter), 
                    as.integer(sum(model$P1inf)), 1e-08, as.integer(N_nonzero_P1), 
                    as.integer(nsim), epsplus, etaplus, aplus1, c2, model$tol, info = integer(1), 
                    as.integer(antithetics), w = array(0,c(n,3 * nsim * antithetics + nsim)), 
                    sim = array(0, c(simdim, n, 3 * nsim * antithetics + nsim)), 
                    as.integer(zero_P1inf), as.integer(length(zero_P1inf)),sim.what,simdim)
    
    
  }
  if (maxiter == out$maxiter) 
    warning("Maximum number of iterations reached, the linearization did not converge.")
  
  out <- list(samples = aperm(out$sim, c(2, 1, 3)), weights = out$w)
  if (save.model) 
    out$model <- model
  
  # class(out) <- 'importanceSSM'
  out
} 
####$$$$ KFAS\R/interval.R
# Function for computing the prediction and confidence intervals for non-Gaussian models
# Used by predict.SSModel method

interval <- function(model, interval = c("confidence", "prediction"), level, type = c("response", "link"), 
                     states=NULL,nsim, se.fit = TRUE, timespan, prob = TRUE,maxiter=50) {
  
  interval <- match.arg(interval)
  type <- match.arg(type)
  if (type == "link" && interval == "prediction") 
    stop("Prediction intervals can only be computed at response scale.")
  
  m <- attr(model, "m")
  n <- as.integer(length(timespan))
  p <- attr(model, "p")
  n2 <- as.integer(length(timespan))
  # Generate sample via importance sampling
  imp <- importanceSSM(model, ifelse(identical(states, as.integer(1:m)), "signal", "states"), 
                       nsim = nsim, antithetics = TRUE,maxiter=maxiter)
  nsim <- as.integer(4 * nsim)
  w <- imp$weights/sum(imp$weights)
  if (!identical(states, 1:attr(model, "m"))) # use only selected states
    imp$samples <- .Fortran(fzalpha, as.integer(dim(model$Z)[3] > 1), 
                            model$Z[, , if (dim(model$Z)[3] > 1) timespan else 1, drop = FALSE], 
                            imp$samples[timespan, , drop = FALSE], 
                            signal = array(0, c(n2, p, nsim)), as.integer(p), n2, as.integer(m), 
                            nsim, as.integer(length(states)), states)$signal
  
  for(j in 1:p)
    if(model$distribution[j]=="poisson")
      imp$samples[timespan, j, ]<-imp$samples[timespan, j, ]+log(model$u[timespan,j])
  
  # compute intervals using weighted sample
  if (type == "link") {
    int <- lapply(1:p, function(j) sapply(timespan, function(i) {
      or <- order(imp$samples[i, j, ])
      c(imp$samples[i, j, or][which.max(cumsum(w[or]) >= (1 - level)/2)], imp$samples[i, j, or][which.max(cumsum(w[or]) >= 
                                                                                                            1 - (1 - level)/2)])
    }))
  } else {
    for (j in 1:p) {
      imp$samples[timespan, j, ] <- switch(model$distribution[j], gaussian = imp$samples[timespan, j, ], poisson = exp(imp$samples[timespan, j, ]), binomial = (if (!prob) model$u[timespan, j] else 1) * exp(imp$samples[timespan, 
                                                                                                                                                                                                                          j, ])/(1 + exp(imp$samples[timespan, j, ])), gamma = exp(imp$samples[timespan, j, ]), `negative binomial` = exp(imp$samples[timespan, 
                                                                                                                                                                                                                                                                                                                                                      j, ]))
    }
    
    if (interval == "confidence") {
      int <- lapply(1:p, function(j) {
        sapply(timespan, function(i) {
          or <- order(imp$samples[i, j, ])
          c(imp$samples[i, j, or][which.max(cumsum(w[or]) >= (1 - level)/2)], imp$samples[i, j, or][which.max(cumsum(w[or]) >= 
                                                                                                                1 - (1 - level)/2)])
        })
      })
    } else {
      # sample from observational density
      int <- lapply(1:p, function(j) {
        sapply(timespan, function(i) {
          sample_mu <- sample(imp$samples[i, j, ], size = nsim, replace = TRUE, prob = w)
          q<-quantile(switch(model$distribution[j], gaussian = rnorm(n = nsim, mean = sample_mu, sd = model$u[i, j]), poisson = rpois(n = nsim, 
                                                                                                                                      lambda = sample_mu), binomial = rbinom(n = nsim, size = (if (!prob) model$u[i, j] else 1), prob = sample_mu/(if (!prob) model$u[i, 
                                                                                                                                                                                                                                                                      j] else 1)), gamma = rgamma(n = nsim, shape = model$u[i, j], scale = sample_mu/model$u[i, j]), `negative binomial` = rnbinom(n = nsim, 
                                                                                                                                                                                                                                                                                                                                                                                                   size = model$u[i, j], mu = sample_mu)), 
                      prob = c((1 - level)/2, 1 - (1 - level)/2),
                      type=switch(model$distribution[j], gaussian=,gamma=7, poisson=,binomial=,`negative binomial`=1))                  
        })
      })
      
    }
    
  }
  varmean <- .Fortran(fvarmeanw, imp$samples[timespan, , ], w, as.integer(p), n2, nsim, mean = array(0, c(n2, p)), var = array(0, c(n2, p)), 
                      as.integer(se.fit))
  if (se.fit) {
    pred <- lapply(1:p, function(j) cbind(fit = cbind(varmean$mean[, j], lwr = int[[j]][1, ], upr = int[[j]][2, ]), se.fit = sqrt(varmean$var[, 
                                                                                                                                              j])))
  } else {
    pred <- lapply(1:p, function(j) cbind(fit = varmean$mean[, j], lwr = int[[j]][1, ], upr = int[[j]][2, ]))
  }
  pred
} 
####$$$$ KFAS\R/KFAS-package.R
#' KFAS: Functions for Gaussian and Non-Gaussian State Space Models
#'
#' Package KFAS contains functions for Kalman filtering, smoothing and 
#' simulation of linear state space models with exact diffuse initialization.
#'
#' The linear gaussian state space model is given by
#'
#' \deqn{y_t = Z_t \alpha_t + \epsilon_t,}{y[t] = Z[t]\alpha[t] + \epsilon[t], (observation equation)}
#'
#' \deqn{\alpha_{t+1} = T_t \alpha_t + R_t \eta_t,}{\alpha[t+1] = T[t]\alpha[t] + R[t]\eta[t], (transition equation)}
#'
#' where \eqn{\epsilon_t \sim N(0,H_t)}{\epsilon[t] ~ N(0,H[t])}, \eqn{\eta_t \sim N(0,Q_t)}{\eta[t] ~ N(0,Q[t])}
#' and \eqn{\alpha_1 \sim N(a_1,P_1)}{\alpha[1] ~ N(a[1],P[1])} independently of each other.
#'
#' All system and covariance matrices Z, H, T, R and Q can be time-varying, and partially or totally missing observations \eqn{y_t}{y[t]} are allowed.
#'
#' Covariance matrices H and Q has to be positive semidefinite (although this is not checked).
#'
#' Dimensions of system matrices are
#'
#' \tabular{rl}{
#'  Z \tab \eqn{p \times m \times 1}{p*m*1} or \eqn{p \times m \times n}{p*m*n} in time varying case \cr
#'  H \tab \eqn{p \times p \times 1}{p*p*1} or \eqn{p \times p \times n}{p*p*n} in time varying case (Omitted in non-gaussian models) \cr
#'  T \tab \eqn{m \times m \times 1}{m*m*1} or \eqn{m \times m \times n}{m*m*n} in time varying case \cr
#'  R \tab \eqn{m \times k \times 1}{m*k*1} or \eqn{m \times k \times n}{m*k*n} in time varying case \cr
#'  Q \tab \eqn{k \times k \times 1}{k*k*1} or \eqn{k \times k \times n}{k*k*n} in time varying case \cr
#'  u \tab \eqn{n \times p}{p*n} (Omitted in gaussian models) \cr
#'  }
#'
#' In case of any of the series in model is defined as non-gaussian, the observation equation is of form
#' \deqn{\prod_i^p p_i(y_{i,t}|\theta_t)}{\prod_i^p p(y[i,t]|\theta[t]),}
#' with \eqn{\theta_{i,t}=Z_{i,t}\alpha_t}{\theta[i,t]=Z[i,t]\alpha[t]} being one of the following:
#'
#' If observations \eqn{y_{i,1},\ldots,y_{i,n}} are distributed as \eqn{N(\mu_t,u_t)}, then \eqn{\theta_t=\mu_t}.
#' Note that now variances are defined using \code{u}, not \code{H}. 
#' If correlation between gaussian observation equations is needed, one can use \eqn{u_t=0} and add correlating disturbances into state equation 
#' (although care is needed when making inferences as then \eqn{y_t=\theta_t})
#' 
#' If observations are distributed as \eqn{Poisson(u_t\lambda_t)}, where \eqn{u_t}{u[t]} is offset term, then
#' \eqn{\theta_t = log(u_t\lambda_t)}{\theta[t]=log(u[t]\lambda[t])}.
#'
#' If observations are distributed as \eqn{binomial(u_t,\pi_t)}, then \eqn{\theta_t =
#' log[\pi_t/(1-\pi_t)]}{\theta[t] = log(\pi[t]/(1-\pi[t]))}, where \eqn{\pi_t}{\pi[t]} is the probability of success at time \eqn{t}.
#' 
#' If observations are distributed as \eqn{gamma(u_t,\mu_t)}, then \eqn{\theta_t = log(\mu_t)}{[\theta[t] = log(\mu[t])]}, where \eqn{\mu[t]} is the mean parameter and \eqn{u} is the shape parameter.
#' 
#' If observations are distributed as \eqn{negative binomial(u_t,\mu_t)} 
#' (with expected value \eqn{\mu_t} and variance \eqn{\mu_t+ \mu_t^2/u_t}, see \code{\link{dbinom}}), 
#' then \eqn{\theta_t = log[\mu_t]}{\theta[t] = log(\mu[t])}.
#' 
#' For exponential family models \eqn{u_t=1}{u[t]=1} as a default. For completely gaussian models, parameter is omitted.
#'
#'
#' For the unknown elements of initial state vector \eqn{a_1}{a[1]}, KFS
#' uses exact diffuse initialization by Koopman and Durbin (2000, 2001, 2003), where the unknown initial states are set to have a zero mean and infinite variance, so
#' \deqn{P_1 = P_{\ast,1} + \kappa P_{\infty,1},}{P[1] = P[*,1] + \kappaP[inf,1],}
#' with \eqn{\kappa} going to infinity and \eqn{P_{\infty,1}}{P[inf,1]} being diagonal matrix with ones on diagonal elements corresponding to unknown initial states.
#'
#' Diffuse phase is continued until rank of \eqn{P_{\infty,t}}{P[inf,t]} becomes zero. Rank of \eqn{P_{\infty}}{P[inf]} decreases by 1, if \eqn{F_\infty>tol>0}{F[inf]>tol>0}.
#' Usually the number of diffuse time points equals the number unknown elements of initial state vector, but missing observations or time-varying Z can affect this.
#' See Koopman and Durbin (2000, 2001, 2003) for details for exact diffuse and non-diffuse filtering.
#'
#' To lessen the notation and storage space, KFAS uses letters P, F and K for non-diffuse part of the corresponding matrices, omitting the asterisk in diffuse phase.
#'
#' All functions of KFAS use the univariate approach (also known as sequential processing, see Anderson and Moore (1979))
#' which is from Koopman and Durbin (2000, 2001). In univariate approach the observations are introduced one element at the time.
#' Therefore the prediction error variance matrices F and Finf does not need to be non-singular, as
#' there is no matrix inversions in univariate approach algorithm.  This provides more stable and possibly more faster filtering and smoothing than normal multivariate Kalman
#' filter algorithm. If covariance matrix H is not diagonal, it is possible to transform the model by either using LDL decomposition on H, or augmenting the state vector with \eqn{\epsilon} disturbances. See \code{\link{transformSSM}} for more details.
#'
#'
#' @references Koopman, S.J. and Durbin J. (2000).  Fast filtering and
#' smoothing for non-stationary time series models, Journal of American
#' Statistical Assosiation, 92, 1630-38.
#'
#' Koopman, S.J. and Durbin J. (2001).  Time Series Analysis by State Space
#' Methods. Oxford: Oxford University Press.
#'
#' Koopman, S.J. and Durbin J. (2003).  Filtering and smoothing of state vector
#' for diffuse state space models, Journal of Time Series Analysis, Vol. 24,
#' No. 1.
#' 
#' #' Shumway, Robert H. and Stoffer, David S. (2006).  Time Series Analysis and
#' Its Applications: With R examples.  \cr
#' @docType package
#' @name KFAS
#' @aliases KFAS
#' @useDynLib KFAS .registration=TRUE
#' @examples
#'
#' 
# 
#' # Example of local level model for Nile series
#'
#' modelNile<-SSModel(Nile~SSMtrend(1,Q=list(matrix(NA))),H=matrix(NA))
#' modelNile
#' modelNile<-fitSSM(inits=c(log(var(Nile)),log(var(Nile))),model=modelNile,
#'                   method='BFGS',control=list(REPORT=1,trace=1))$model
#' # Filtering and state smoothing
#' out<-KFS(modelNile,filtering='state',smoothing='state') 
#' out
#'
#' # Confidence and prediction intervals for the expected value and the observations.
#' # Note that predict uses original model object, not the output from KFS.
#' conf<-predict(modelNile,interval='confidence')
#' pred<-predict(modelNile,interval='prediction')
#' 
#' ts.plot(cbind(Nile,pred,conf[,-1]),col=c(1:2,3,3,4,4), 
#'         ylab='Predicted Annual flow', main='River Nile')
#'
#'
#' # Missing observations, using same parameter estimates
#'
#' y<-Nile
#' y[c(21:40,61:80)]<-NA
#' modelNile<-SSModel(y~SSMtrend(1,Q=list(modelNile$Q)),H=modelNile$H)
#'
#' out<-KFS(modelNile,filtering='mean',smoothing='mean')
#'
#' # Filtered and smoothed states
#' plot.ts(cbind(y,fitted(out,filtered=TRUE),fitted(out)), plot.type='single', 
#'         col=1:3, ylab='Predicted Annual flow', main='River Nile')
#' 
#' 
#' # Example of multivariate local level model with only one state
#' # Two series of average global temperature deviations for years 1880-1987
#' # See Shumway and Stoffer (2006), p. 327 for details
#'
#' data(GlobalTemp)
#' 
#' model<-SSModel(GlobalTemp~SSMtrend(1,Q=NA,type='common'),H=matrix(NA,2,2))        
#'
#' # Estimating the variance parameters
#' inits<-chol(cov(GlobalTemp))[c(1,4,3)]
#' inits[1:2]<-log(inits[1:2])
#' fit<-fitSSM(inits=c(0.5*log(.1),inits),model=model,method='BFGS')
#' 
#' out<-KFS(fit$model)
#'
#' ts.plot(cbind(model$y,coef(out)),col=1:3)
#' legend('bottomright',legend=c(colnames(GlobalTemp), 'Smoothed signal'), col=1:3, lty=1)
#'
#'
#'
#' # Seatbelts data
#' \dontrun{
#' model<-SSModel(log(drivers)~SSMtrend(1,Q=list(NA))+
#'                SSMseasonal(period=12,sea.type='trigonometric',Q=NA)+
#'                log(PetrolPrice)+law,data=Seatbelts,H=NA)
#' 
#' # As trigonometric seasonal contains several disturbances which are all 
#' # identically distributed, default behaviour of fitSSM is not enough, 
#' # as we have constrained Q. We can either provide our own 
#' # model updating function with fitSSM, or just use optim directly:
#'
#' # option 1:
#' ownupdatefn<-function(pars,model,...){
#'   model$H[]<-exp(pars[1])
#'   diag(model$Q[,,1])<-exp(c(pars[2],rep(pars[3],11)))
#'   model #for option 2, replace this with -logLik(model) and call optim directly
#' }
#' 
#' fit<-fitSSM(inits=log(c(var(log(Seatbelts[,'drivers'])),0.001,0.0001)),
#'             model=model,updatefn=ownupdatefn,method='BFGS')
#' 
#' out<-KFS(fit$model,smoothing=c('state','mean'))
#' out
#' ts.plot(cbind(out$model$y,fitted(out)),lty=1:2,col=1:2,
#' main='Observations and smoothed signal with and without seasonal component')
#' lines(signal(out,states=c("regression","trend"))$signal,col=4,lty=1)
#' legend('bottomleft',
#' legend=c('Observations', 'Smoothed signal','Smoothed level'), 
#' col=c(1,2,4), lty=c(1,2,1))
#' 
#' 
#' # Multivariate model with constant seasonal pattern,
#' # using the the seat belt law dummy only for the front seat passangers, 
#' # and restricting the rank of the level component by using custom component 
#' 
#' # note the small inconvinience in regression component, 
#' # you must remove the intercept from the additional regression parts manually
#' 
#' model<-SSModel(log(cbind(front,rear))~ -1 + log(PetrolPrice) + log(kms)
#'                + SSMregression(~-1+law,data=Seatbelts,index=1)
#'                + SSMcustom(Z=diag(2),T=diag(2),R=matrix(1,2,1),
#'                            Q=matrix(1),P1inf=diag(2))
#'                + SSMseasonal(period=12,sea.type='trigonometric'),
#'                  data=Seatbelts,H=matrix(NA,2,2)) 
#' 
#' likfn<-function(pars,model,estimate=TRUE){
#'   diag(model$H[,,1])<-exp(0.5*pars[1:2])
#'   model$H[1,2,1]<-model$H[2,1,1]<-tanh(pars[3])*prod(sqrt(exp(0.5*pars[1:2]))) 
#'   model$R[28:29]<-exp(pars[4:5])
#'   if(estimate) return(-logLik(model))
#'   model
#' }        
# 
#' fit<-optim(f=likfn,p=c(-7,-7,1,-1,-3),method='BFGS',model=model)
#' model<-likfn(fit$p,model,estimate=FALSE)
#' model$R[28:29,,1]%*%t(model$R[28:29,,1])
#' model$H
#' 
#' out<-KFS(model)
#' out
#' ts.plot(cbind(signal(out,states=c('custom','regression'))$signal,model$y),col=1:4)
#' 
#' # For confidence or prediction intervals, use predict on the original model
#' pred <- predict(model,states=c('custom','regression'),interval='prediction')
#' ts.plot(pred$front,pred$rear,model$y,col=c(1,2,2,3,4,4,5,6),lty=c(1,2,2,1,2,2,1,1))
#' }
#' 
#'  \dontrun{
#' # Poisson model
#' model<-SSModel(VanKilled~law+SSMtrend(1,Q=list(matrix(NA)))+
#'                SSMseasonal(period=12,sea.type='dummy',Q=NA),
#'                data=Seatbelts, distribution='poisson')
#'
#' # Estimate variance parameters
#' fit<-fitSSM(inits=c(-4,-7,2), model=model,method='BFGS')
#'
#' model<-fit$model
#' 
#' # use approximating model, gives posterior mode of the signal and the linear predictor
#' out_nosim<-KFS(model,smoothing=c('signal','mean'),nsim=0)
#' # State smoothing via importance sampling
#' out_sim<-KFS(model,smoothing=c('signal','mean'),nsim=1000)
#' 
#' out_nosim
#' out_sim
#' }
#' 
#' # Example of generalized linear modelling with KFS
#'
#' # Same example as in ?glm 
#' counts <- c(18,17,15,20,10,20,25,13,12)
#' outcome <- gl(3,1,9)
#' treatment <- gl(3,3)
#' print(d.AD <- data.frame(treatment, outcome, counts))
#' glm.D93 <- glm(counts ~ outcome + treatment, family = poisson())
#' 
#'
#' model<-SSModel(counts ~ outcome + treatment, data=d.AD, 
#'                distribution = 'poisson')
#' 
#' out<-KFS(model)
#' coef(out,start=1,end=1)
#' coef(glm.D93)
#' 
#' summary(glm.D93)$cov.s
#' out$V[,,1]
#' 
#' outnosim<-KFS(model,smoothing=c('state','signal','mean'))
#' set.seed(1)
#' outsim<-KFS(model,smoothing=c('state','signal','mean'),nsim=1000)
#' 
#' 
#' ## linear 
#' # GLM
#' glm.D93$linear.predictor
#' # approximate model, this is the posterior mode of p(theta|y)
#' c(outnosim$thetahat)            
#' # importance sampling on theta,  gives E(theta|y)            
#' c(outsim$thetahat)                         
#' 
#' 
#' 
#' ## predictions on response scale
#' # GLM
#' fitted(glm.D93) 
#' # approximate model with backtransform, equals GLM
#' c(fitted(outnosim))                
#' # importance sampling on exp(theta)       
#' fitted(outsim)                                 
#' 
#' # prediction variances on link scale
#' # GLM
#' as.numeric(predict(glm.D93,type='link',se.fit=TRUE)$se.fit^2)
#' # approx, equals to GLM results
#' c(outnosim$V_theta)                                    
#' # importance sampling on theta        
#' c(outsim$V_theta)                                            
#' 
#' 
#' # prediction variances on response scale
#' # GLM
#' as.numeric(predict(glm.D93,type='response',se.fit=TRUE)$se.fit^2) 
#' # approx, equals to GLM results
#' c(outnosim$V_mu)                             
#' # importance sampling on theta                    
#' c(outsim$V_mu)                                                   
#' 
#' \dontrun{
#' data(sexratio)
#' model<-SSModel(Male~SSMtrend(1,Q=list(NA)),u=sexratio[,'Total'],data=sexratio,
#'                distribution='binomial')
#' fit<-fitSSM(model,inits=-15,method='BFGS',control=list(trace=1,REPORT=1))
#' fit$model$Q #1.107652e-06
#' 
#' # Computing confidence intervals in response scale 
#' # Uses importance sampling on response scale (4000 samples with antithetics)
#' 
#' pred<-predict(fit$model,type='response',interval='conf',nsim=1000) 
#'  
#' ts.plot(cbind(model$y/model$u,pred),col=c(1,2,3,3),lty=c(1,1,2,2))
#' 
#' # Now with sex ratio instead of the probabilities:
#' imp<-importanceSSM(fit$model,nsim=1000,antithetics=TRUE)
#' sexratio.smooth<-numeric(length(model$y))
#' sexratio.ci<-matrix(0,length(model$y),2)
#' w<-imp$w/sum(imp$w)
#' for(i in 1:length(model$y)){
#'  sexr<-exp(imp$sample[i,1,])
#'  sexratio.smooth[i]<-sum(sexr*w)
#'  oo<-order(sexr)
#'  sexratio.ci[i,]<-c(sexr[oo][which.min(abs(cumsum(w[oo]) - 0.05))],
#'                       + sexr[oo][which.min(abs(cumsum(w[oo]) - 0.95))])
#' }
#' 
#' # Same by direct transformation:
#' out<-KFS(fit$model,smoothing='signal',nsim=1000)
#' sexratio.smooth2 <- exp(out$thetahat)
#' sexratio.ci2<-exp(c(out$thetahat) 
#'                   + qnorm(0.025) * sqrt(drop(out$V_theta))%o%c(1, -1))
#' 
#' ts.plot(cbind(sexratio.smooth,sexratio.ci,sexratio.smooth2,sexratio.ci2),
#'         col=c(1,1,1,2,2,2),lty=c(1,2,2,1,2,2))
#'}
#' # Example of Cubic spline smoothing
#' \dontrun{
#' require(MASS)
#' data(mcycle)
#' 
#' model<-SSModel(accel~-1+SSMcustom(Z=matrix(c(1,0),1,2),
#'                                  T=array(diag(2),c(2,2,nrow(mcycle))),
#'                                  Q=array(0,c(2,2,nrow(mcycle))),
#'                                  P1inf=diag(2),P1=diag(0,2)),data=mcycle)
#' 
#' model$T[1,2,]<-c(diff(mcycle$times),1)
#' model$Q[1,1,]<-c(diff(mcycle$times),1)^3/3
#' model$Q[1,2,]<-model$Q[2,1,]<-c(diff(mcycle$times),1)^2/2
#' model$Q[2,2,]<-c(diff(mcycle$times),1)
#' 
#' 
#' updatefn<-function(pars,model,...){ 
#'   model$H[]<-exp(pars[1])
#'   model$Q[]<-model$Q[]*exp(pars[2])
#'   model
#' }
#' 
#' fit<-fitSSM(model,inits=c(4,4),updatefn=updatefn,method="BFGS")
#'
#' pred<-predict(fit$model,interval="conf",level=0.95)
#' plot(x=mcycle$times,y=mcycle$accel,pch=19)
#' lines(x=mcycle$times,y=pred[,1])
#' lines(x=mcycle$times,y=pred[,2],lty=2)
#' lines(x=mcycle$times,y=pred[,3],lty=2)
#' }
#' 
#' 
NULL
#' Oxford-Cambridge boat race results 1829-2000
#'
#' Results of the annual boat race between universities of Oxford (0) and Cambridge (1).
#'
#' @name boat
#' @docType data
#' @format A time series object containing 172 observations.
#' @references  Koopman, S.J. and Durbin J. (2001).  Time Series Analysis by State Space Methods. Oxford: Oxford University Press.
#' @source http://www.ssfpack.com/DKbook.html
#' @keywords datasets
NULL
#' Two series of average global temperature deviations for years 1880-1987
#'
#' This data set contains two series of average global temperature deviations
#' for years 1880-1987. These series are same as used in Shumway and Stoffer
#' (2006), where they are known as HL and Folland series. For more details, see
#' Shumway and Stoffer (2006, p. 327).
#'
#'
#' @name GlobalTemp
#' @docType data
#' @format A time series object containing 108 times 2 observations.
#' @references Shumway, Robert H. and Stoffer, David S. (2006). Time Series
#' Analysis and Its Applications: With R examples.
#' @source http://lib.stat.cmu.edu/general/stoffer/tsa2/
#' @keywords datasets
NULL
#' Number of males and females born in Finland from 1751 to 2011
#'
#' A time series object containing the number of males and females born in Finland from 1751 to 2011.
#' 
#' @name sexratio
#' @docType data
#' @format A time series object containing the number of males and females born in Finland from 1751 to 2011.
#' @source Statistics Finland
#' @keywords datasets
NULL####$$$$ KFAS\R/KFS.R
#' Kalman Filter and Smoother with Exact Diffuse Initialization for Exponential Family State Space Models
#'
#' Performs Kalman filtering and smoothing with exact diffuse initialization
#' using univariate approach for exponential family state space models. 
#'
#' Notice that in case of multivariate observations, \code{v}, \code{F}, \code{Finf}, \code{K} and 
#' \code{Kinf} are usually not the same as those calculated in usual multivariate Kalman filter. 
#' As filtering is done one observation element at the time, the elements of prediction error 
#' \eqn{v_t}{v[t]} are uncorrelated, and \code{F}, \code{Finf}, \code{K} and \code{Kinf} contain 
#' only the diagonal elemens of the corresponding covariance matrices.
#'
#' In rare cases of a diffuse initialization phase with highly correlated states, 
#' cumulative rounding errors in computing \code{Finf} and \code{Pinf} can sometimes cause the 
#' diffuse phase end too early. Changing the tolerance parameter \code{tol} of the model 
#' (see \code{\link{SSModel}}) to smaller (or larger) should help.
#' 
#' In case of non-Gaussian models with \code{nsim=0}, the smoothed estimates relate 
#' the conditional mode of \eqn{p(\alpha|y)}, and are equivalent with the results from 
#' generalized linear models. When using importance sampling (\code{nsim>0}), 
#' results correspond to the conditional mean.
#' 
#' @export
#' @param model Object of class \code{SSModel}.
#' @param filtering Types of filtering. Possible choices are 'state', 'signal', 'mean', and 'none'. 
#' Default is 'state' for Gaussian and 'none' for non-Gaussian models.  Multiple values are allowed. Note that for Gaussian models, signal is mean.
#' Note that filtering for non-Gaussian models with importance sampling can be very slow with large
#'  models. Also in approximating mean filtering only diagonals of P_mu are returned.
#' @param smoothing Types of smoothing. Possible choices are 'state', 'signal', 'mean', 
#' 'disturbance' and 'none'. Default is 'state' and 'mean'. For non-Gaussian models, 
#'  option 'disturbance' is not supported, and for Gaussian models option 'mean' is identical to 'signal'. 
#' Multiple values are allowed.
#' @param simplify If FALSE and model is completely Gaussian, KFS returns some generally not so 
#' interesting variables from filtering and smoothing. Default is TRUE.
#' @param transform How to transform the model in case of non-diagonal
#' covariance matrix \eqn{H}. Defaults to \code{'ldl'}. See function \code{\link{transformSSM}} for
#' details.
#' @param nsim The number of independent samples.  Only used for non-Gaussian model. 
#' Default is 0, which computes the approximating Gaussian model by \code{\link{approxSSM}} and 
#' performs the usual Gaussian smoothing so that the smoothed state estimates equals to the 
#' conditional mode of \eqn{p(\alpha_t|y)}{p(\alpha[t]|y)}.
#' @param theta Initial values for conditional mode theta. Only used for non-Gaussian model.
#' @param maxiter The maximum number of iterations used in approximation Default is 50. 
#' Only used for non-Gaussian model.
#' @param convtol Tolerance parameter for convergence checks for Gaussian approximation.
#'  Iterations are continued until 
#'  \eqn{tol>abs(dev_{old}-dev_{new})/(abs(dev_{new})+0.1))}.
#'
#' @return What \code{KFS} returns depends on the arguments \code{filtering}, \code{smoothed} and 
#' \code{simplify}, and whether the model is Gaussian or not:
#' \item{model}{Original state space model.  }
#' \item{KFS_transform}{Type of H after possible transformation.  }
#' \item{logLik}{Value of the log-likelihood function. Only computed for Gaussian models. }
#' 
#' \item{a}{One step predictions of states, \eqn{a_t=E(\alpha_t | y_{t-1}, \ldots , y_{1})}{a[t]=E(\alpha[t] | y[t-1], \ldots , y[1])}.  }
#' \item{P}{Covariance matrices (of the non-diffuse parts) of predicted states, 
#' \eqn{P_t=Cov(\alpha_t | y_{t-1}, \ldots , y_{1})}{P[t]=Cov(\alpha[t] | y[t-1], \ldots , y[1])}.  }
#' \item{Pinf}{Diffuse part of \eqn{P_t}{P[t]}. Only returned for Gaussian models.}
#' \item{t}{Filtered estimates of signals, \eqn{E(Z_t\alpha_t | y_{t-1}, \ldots , y_{1})}{E(Z[t]\alpha[t] | y[t-1], \ldots , y[1])}. }
#' \item{P_theta}{Covariances \eqn{Var(Z[t]\alpha_t | y_{t-1}, \ldots , y_{1}).}{Var(Z[t]\alpha[t] | y[t-1], \ldots , y[1])}. }
#' \item{m}{Filtered estimates of \eqn{f(\theta_t) | y_{t-1}, \ldots , y_{1})}{f(\theta[t]) | y[t-1], \ldots , y[1])}, where \eqn{f} is the inverse link function.  }
#' \item{P_mu}{Covariances \eqn{Cov(f(\theta_t)| y_{t-1}, \ldots , y_{1})}{Cov(f(\theta[t]) | y[t-1], \ldots , y[1])}. 
#' If \code{nsim=0}, only diagonal elements (variances) are computed, using the delta method.  }
#' \item{alphahat}{Smoothed estimates of states, \eqn{E(\alpha_t | y_1, \ldots , y_n)}{E(\alpha[t] | y[1], \ldots , y[n])}. }
#' \item{V}{Covariances \eqn{Var(\alpha_t | y_1, \ldots , y_n)}{Var(\alpha[t] | y[1], \ldots , y[n])}. }
#' \item{thetahat}{Smoothed estimates of signals, \eqn{E(Z_t\alpha_t | y_1, \ldots , y_n)}{E(Z[t]\alpha[t] | y[1], \ldots , y[n])}. }
#' \item{V_theta}{Covariances \eqn{Var(Z[t]\alpha_t | y_1, \ldots , y_n).}{Var(Z[t]\alpha[t] | y[1], \ldots , y[n])}. }
#' \item{muhat}{Smoothed estimates of \eqn{f(\theta_t) | y_1, \ldots , y_n)}{f(\theta[t]) | y[1], \ldots , y[n])}, where \eqn{f} is the inverse link function.  }
#' \item{V_mu}{Covariances \eqn{Cov(f(\theta_t)| y_1, \ldots , y_n)}{Cov(f(\theta[t]) | y[1], \ldots , y[n])}. 
#' If \code{nsim=0}, only diagonal elements (variances) are computed, using the delta method.  }
#' \item{etahat}{Smoothed disturbance terms \eqn{E(\eta_t | y_1, \ldots , y_n)}{E(\eta[t] | y[1], \ldots , y[n])}. }
#' \item{V_eta}{Covariances \eqn{Var(\eta_t | y_1, \ldots , y_n)}{Var(\eta[t] | y[1], \ldots , y[n])}. }
#' \item{epshat}{Smoothed disturbance terms \eqn{E(\epsilon_{t,i} | y_1, \ldots , y_n)}{E(\epsilon[t,i] | y[1], \ldots , y[n])}. 
#' Note that due to the possible diagonalization these are on transformed scale. }
#' \item{V_eps}{Diagonal elements of \eqn{Var(\epsilon_{t} | y_1, \ldots , y_n)}{Var(\epsilon[t] | y[1], \ldots , y[n])}. 
#' Note that due to the diagonalization the off-diagonal elements are zero. }
#' \item{iterations}{The number of iterations used in linearization of non-Gaussian model. }
#' \item{v}{Prediction errors \eqn{v_{t,i} = y_{t,i} - Z_{i,t}a_{t,i}, i=1,\ldots,p}{v[t,i] = y[t,i] - Z[i,t]a[t,i], i=1,\ldots,p},
#' where \eqn{a_{t,i}=E(\alpha_t | y_{t,i-1}, \ldots, y_{t,1}, \ldots , y_{1,1})}{a[t,i]=E(\alpha[t] | y[t,i-1], \ldots, y[t,1], \ldots , y[1,1])}. 
#' Only returned for Gaussian models.  }
#' \item{F}{Prediction error variances \eqn{Var(v_{t,i})}{Var(v[t,i])}. 
#' Only returned for Gaussian models.  }
#' \item{Finf}{Diffuse part of \eqn{F_t}{F[t]}. Only returned for Gaussian models.  }
#' \item{d}{The last index of diffuse phase, i.e. the non-diffuse phase began from time \eqn{d+1}. 
#' Only returned for Gaussian models.  }
#' \item{j}{The index of last \eqn{y_{i,t}} of diffuse phase. Only returned for Gaussian models.  }
#' In addition, if argument \code{simplify=FALSE}, list contains following components:
#' \item{K}{Covariances \eqn{Cov(\alpha_{t,i}, y_{t,i} | y_{t,i-1}, \ldots, y_{t,1}, y_{t-1}, \ldots , y_{1}), \quad i=1,\ldots,p}{Cov(\alpha[t,i], y[t,i] | y[t,i-1], \ldots, y[t,1], y[t-1], \ldots , y[1]), i=1,\ldots,p}.  }
#' \item{Kinf}{Diffuse part of \eqn{K_t}{K[t]}.  }
#' \item{r}{Weighted sums of innovations \eqn{v_{t+1}, \ldots , v_{n}}{v[t+1], \ldots , v[n]}.  Notice that in literature t in \eqn{r_t}{r[t]} goes from \eqn{0, \ldots, n}. Here \eqn{t=1, \ldots, n+1}. Same applies to all r and N variables.  }
#' \item{r0, r1}{Diffuse phase decomposition of \eqn{r_t}{r[t]}.  }
#' \item{N}{Covariances \eqn{Var(r_t)}{Var(r[t])} .  }
#' \item{N0, N1, N2}{Diffuse phase decomposition of \eqn{N_t}{N[t]}.   }
#' 
#' @references Koopman, S.J. and Durbin J. (2000).  Fast filtering and
#' smoothing for non-stationary time series models, Journal of American
#' Statistical Assosiation, 92, 1630-38.  \cr
#'
#' Koopman, S.J. and Durbin J. (2001).  Time Series Analysis by State Space
#' Methods. Oxford: Oxford University Press.  \cr
#'
#' Koopman, S.J. and Durbin J. (2003).  Filtering and smoothing of state vector
#' for diffuse state space models, Journal of Time Series Analysis, Vol. 24,
#' No. 1.  \cr
#'

KFS <- function(model, filtering, smoothing, simplify = TRUE, transform = c("ldl","augment"), 
                nsim = 0, theta, maxiter = 50,convtol=1e-15) {
  
  is.SSModel(model, na.check = TRUE, return.logical = FALSE)
  
  if(missing(filtering)){
    if(all(model$distribution == "gaussian")){
      filtering <- "state"
    } else filtering <- "none"
  } else{
    filtering <- match.arg(arg = filtering, 
                           choices = c("state", "signal", "mean","invlink", "none"), several.ok = TRUE)
    filtering[filtering=="invlink"]<-"mean"
    if ("signal" %in% filtering && all(model$distribution == "gaussian")) {
      filtering[filtering == "signal"]  <-"mean" 
      filtering<-unique(filtering)
    }
  }
  
  if(missing(smoothing)){
    smoothing <- c("state","mean")
  } else{
    smoothing <- match.arg(arg = smoothing, 
                           choices = c("state", "signal", "disturbance","mean","invlink", "none"), 
                           several.ok = TRUE)
    smoothing[smoothing=="invlink"]<-"mean"
    if ("signal" %in% smoothing && all(model$distribution == "gaussian")) {
      smoothing[smoothing == "signal"]  <-"mean" 
      smoothing<-unique(smoothing)
      
    }
    if ("disturbance" %in% smoothing && !all(model$distribution == "gaussian")) {
      warning("disturbance smoothing is not supported for non-gaussian models.")
      smoothing <- smoothing[smoothing != "disturbance"]
    }
  }
  
  p <- attr(model, "p")
  m <- attr(model, "m")
  k <- attr(model, "k")
  n <- attr(model, "n")    
  
  tv <- array(0, dim = 5)
  tv[1] <- dim(model$Z)[3] > 1
  tv[2] <- any(model$distribution != "gaussian") || (dim(model$H)[3] > 1)
  tv[3] <- dim(model$T)[3] > 1
  tv[4] <- dim(model$R)[3] > 1
  tv[5] <- dim(model$Q)[3] > 1
  
  ymiss <- is.na(model$y)
  
  out <- list(model = model)
  
  # non-Gaussian case
  if (any(model$distribution != "gaussian")) {  
    
    # initial values for theta
    if (missing(theta)) {
      theta <- sapply(1:p, function(i) 
        switch(model$distribution[i], gaussian = model$y[, i], 
               poisson = log(pmax(model$y[, i]/model$u[, i], 0.1, na.rm = TRUE)), 
               binomial = qlogis((ifelse(is.na(model$y[, i]), 0.5, model$y[, i]) + 0.5)/(model$u[, i] + 1)), 
               gamma = log(pmax(model$y[, i], 1, na.rm = TRUE)), 
               `negative binomial` = log(pmax(model$y[, i], 1/6, na.rm = TRUE))))
    } else theta <- array(theta, dim = c(n, p))
    
    if (nsim > 0) {
      
      # generate standard normal variables for importance sampling
      epsplus <- array(0, c(p, n, nsim))
      etaplus <- array(0, c(k, n, nsim))
      aplus1 <- array(0, dim = c(m, nsim))
      c2 <- numeric(nsim)
      x <- array(t(!ymiss), c(p, n, nsim))
      df_eps <- sum(x)/nsim
      x2 <- array(abs(apply(model$Q, 3, diag)) > model$tol, c(k, (n - 1) * tv[5] + 1))
      x2 <- array(x2, c(k, n, nsim))
      df_eta <- sum(x2)/nsim
      
      nondiffuse_elements <- which(diag(model$P1) > model$tol)
      nondiffuse_elements_length <- length(nondiffuse_elements)
      nd <- which(diag(model$P1inf) == 0)
      df_total <- df_eps + df_eta + nondiffuse_elements_length
      std_normal_sample <- rnorm(df_total * nsim, mean = 0, sd = 1)
      
      if (df_eps > 0) 
        epsplus[x] <- std_normal_sample[1:(df_eps * nsim)]
      if (df_eta > 0) 
        etaplus[x2] <- std_normal_sample[(df_eps * nsim + 1):(df_eps * nsim + df_eta * nsim)]
      if (nondiffuse_elements_length > 0) 
        aplus1[nondiffuse_elements, ] <- std_normal_sample[(df_eps * nsim + df_eta * nsim + 1):(df_total * nsim)]
      
      
      for (i in 1:nsim) {
        std_normal_sample <- c(etaplus[, , i], epsplus[, , i], aplus1[, i])
        c2[i] <- t(std_normal_sample) %*% c(std_normal_sample)
      }
      q <- pchisq(c2, df = df_total)
      c2 <- sqrt(qchisq(1 - q, df_total)/c2)
      
      
      
      storage.mode(ymiss) <- "integer"
      
      if(!("none"%in%filtering)){ 
        # filtering is always "none" for non-gaussian models, this is for future release.
        # 
        #stop("Filtering of non-Gaussian models with simulation is not supported.")
        filterout <- .Fortran(fngfilter, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z,
                              model$T, model$R, model$Q, model$a1, model$P1, model$P1inf, model$u, 
                              theta, 
                              pmatch(x = model$distribution, 
                                     table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                                     duplicates.ok = TRUE), as.integer(p), as.integer(n), 
                              as.integer(m), as.integer(k), as.integer(sum(model$P1inf)), 
                              as.integer(nondiffuse_elements_length), as.integer(nsim), epsplus, 
                              etaplus, aplus1, c2, model$tol, info = integer(1),
                              maxiter = as.integer(maxiter), convtol =convtol, as.integer(nd), 
                              as.integer(length(nd)), 
                              a = array(0, ("state" %in% filtering) * c(m - 1, n - 1) + 1), 
                              P = array(0, ("state" %in% filtering) * c(m - 1, m - 1, n - 1) + 1), 
                              theta = array(0, ("signal" %in% filtering) * c(p - 1, n - 1) + 1), 
                              P_theta = array(0, ("signal" %in% filtering) * c(p - 1, p - 1, n - 1) + 1), 
                              mu = array(0, ("mean" %in% filtering) * c(p - 1, n - 1) + 1), 
                              P_mu = array(0, ("mean" %in% filtering) * c(p - 1, p - 1, n - 1) + 1), 
                              as.integer("state" %in% filtering), as.integer("signal" %in% filtering), 
                              as.integer("mean" %in% filtering))
        if ("state" %in% filtering) {
          out <- c(out, list(a = ts(t(filterout$a),start=start(model$y),frequency=frequency(model$y)), 
                             P = filterout$P))                
          colnames(out$a) <- rownames(model$a1)
        }
        if ("signal" %in% filtering) {
          out <- c(out, list(t = ts(t(filterout$theta),start=start(model$y),frequency=frequency(model$y)), 
                             P_theta = filterout$P_theta))                
          colnames(out$t) <- colnames(model$y)
        }
        if ("mean" %in% filtering) {
          out <- c(out, list(m = ts(t(filterout$mu),start=start(model$y),frequency=frequency(model$y)), 
                             P_mu = filterout$P_mu))                
          colnames(out$m) <- colnames(model$y)
        }
        
        out <- c(out, iterations = filterout$maxiter)
      } 
      if(!("none"%in%smoothing)){ 
        smoothout <- .Fortran(fngsmooth, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z, 
                              model$T, model$R, model$Q, model$a1, model$P1, model$P1inf, model$u, 
                              theta, 
                              pmatch(x = model$distribution, 
                                     table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                                     duplicates.ok = TRUE), as.integer(p), as.integer(n), 
                              as.integer(m),as.integer(k), as.integer(sum(model$P1inf)), 
                              as.integer(nondiffuse_elements_length), as.integer(nsim), epsplus, 
                              etaplus, aplus1, c2, model$tol, info = integer(1), 
                              maxiter = as.integer(maxiter), convtol = convtol, as.integer(nd), 
                              as.integer(length(nd)), 
                              alphahat = array(0, ("state" %in% smoothing) * c(m - 1, n - 1) + 1), 
                              V = array(0, ("state" %in% smoothing) * c(m - 1, m - 1, n - 1) + 1), 
                              thetahat = array(0, ("signal" %in% smoothing) * c(p - 1, n - 1) + 1), 
                              V_theta = array(0, ("signal" %in% smoothing) * c(p - 1, p - 1, n - 1) + 1), 
                              muhat = array(0, ("mean" %in% smoothing) * c(p - 1, n - 1) + 1), 
                              V_mu = array(0, ("mean" %in% smoothing) * c(p - 1, p - 1, n - 1) + 1), 
                              as.integer("state" %in% smoothing), as.integer("signal" %in% smoothing), 
                              as.integer("mean" %in% smoothing))
        if ("state" %in% smoothing) {
          out <- c(out, list(alphahat = ts(t(smoothout$alphahat),start=start(model$y),frequency=frequency(model$y)), V = smoothout$V))                
          colnames(out$alphahat) <- rownames(model$a1)
        }
        if ("signal" %in% smoothing) {
          out <- c(out, list(thetahat = ts(t(smoothout$thetahat),start=start(model$y),frequency=frequency(model$y)), V_theta = smoothout$V_theta))                
          colnames(out$thetahat) <- colnames(model$y)
        }
        if ("mean" %in% smoothing) {
          out <- c(out, list(muhat = ts(t(smoothout$muhat),start=start(model$y),frequency=frequency(model$y)), V_mu = smoothout$V_mu))                
          colnames(out$muhat) <- colnames(model$y)
        }
        if("none"%in%filtering)
          out <- c(out, iterations = smoothout$maxiter)
      }
      
      
      
      if (maxiter == out$iterations) 
        warning("Maximum number of iterations reached, the linearization did not converge.")
      out$call <- match.call(expand.dots = FALSE)
      class(out) <- "KFS"
      
      return(out)
    } else {
      # Approximating model
      storage.mode(ymiss) <- "integer"
      app <- .Fortran(fapprox, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z, model$T, 
                      model$R, Htilde = array(0, c(p, p, n)), model$Q, model$a1, model$P1, 
                      model$P1inf, as.integer(p), as.integer(n), as.integer(m),as.integer(k), 
                      theta = theta, model$u, ytilde = array(0, dim = c(n, p)), 
                      pmatch(x = model$distribution, 
                             table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                             duplicates.ok = TRUE), maxiter = as.integer(maxiter), model$tol, 
                      as.integer(sum(model$P1inf)), convtol,diff=double(1))
      
      if (!is.finite(app$diff)){
        stop("Non-finite difference in approximation algoritm.")
      }
      if(app$maxiter==maxiter){
        warning(paste("Maximum number of iterations reached, 
                  the approximation algorithm did not converge. Latest difference was",app$diff))
      }
      
      tsp(app$ytilde)<-tsp(model$y)
      model$y <- app$ytilde
      model$H <- app$Htilde
    }
  }
  
  if (all(model$distribution == "gaussian")) {
    transform <- match.arg(arg = transform, choices = c("ldl","augment"))
    
    # Deal with the possible non-diagonality of H
    
    if (any(abs(apply(model$H, 3, "[", !diag(p))) > model$tol)) {
      model <- transformSSM(model, type = transform)
      tv[1] <- dim(model$Z)[3] > 1
      tv[2] <- dim(model$H)[3] > 1
      tv[5] <- dim(model$Q)[3] > 1
      KFS_transform <- transform
      m <- attr(model, "m")
      k <- attr(model, "k")
    } else KFS_transform <- "none"
    
  } else KFS_transform <- "none"
  filtersignal<-("signal"%in%filtering) || ("mean"%in%filtering)
  storage.mode(ymiss) <- "integer"

  filterout <- .Fortran(fkfilter, NAOK = TRUE, model$y, ymiss, as.integer(tv), model$Z, model$H, model$T, 
                        model$R, model$Q, model$a1, P1 = model$P1, model$P1inf, as.integer(p), 
                        as.integer(n), as.integer(m),as.integer(k), d = integer(1), j = integer(1), 
                        a = array(0, dim = c(m, n + 1)), P = array(0, dim = c(m, m, n + 1)), 
                        v = array(0, dim = c(p, n)), F = array(0, dim = c(p, n)),
                        K = array(0, dim = c(m, p, n)), Pinf = array(0, dim = c(m, m, n + 1)), 
                        Finf = array(0, dim = c(p, n)), Kinf = array(0, dim = c(m, p, n)), 
                        lik = double(1), model$tol, as.integer(sum(model$P1inf)), 
                        theta = array(0,c(filtersignal*n,p)), 
                        P_theta = array(0,c(p,p,filtersignal*n)),
                        as.integer(filtersignal))
  
  if (filterout$d == n & filterout$j == p) 
    warning("Model is degenerate, diffuse phase did not end.")
  if (filterout$d > 0 & m > 1 & min(apply(filterout$Pinf, 3, diag))<0) 
    warning("Possible error in diffuse filtering: Negative variances in Pinf, 
            try changing the tolerance parameter tol of the model.")
  if (sum(filterout$Finf > 0) != sum(diag(model$P1inf))) 
    warning("Possible error in diffuse filtering: 
            Number of nonzero elements in Finf is not equal to the number of diffuse states. \n 
            Either model is degenerate or numerical errors occured. 
            Check the model or change the tolerance parameter tol of the model.")
  
  
  
  filterout$Pinf <- filterout$Pinf[1:m, 1:m, 1:(filterout$d + 1), drop = FALSE]
  if (filterout$d > 0) {
    filterout$Finf <- filterout$Finf[, 1:filterout$d, drop = FALSE]
    filterout$Kinf <- filterout$Kinf[, , 1:filterout$d, drop = FALSE]
  } else {
    filterout$Finf <- filterout$Kinf <- NA
  } 
  
  out$KFS_transform <- KFS_transform
  
  if(!("none"%in%filtering)){
    
    if (all(model$distribution == "gaussian")) {            
      filterout$v[as.logical(t(ymiss))] <- NA
      out$logLik <- filterout$lik     
      
      if("state"%in%filtering){
        rownames(filterout$a) <- rownames(model$a1) 
        out <- c(out, list(
          a = ts(t(filterout$a), start = start(model$y), frequency = frequency(model$y)), 
          P = filterout$P, Pinf = filterout$Pinf))        
      }
      if("mean"%in%filtering){
        colnames(filterout$theta) <- colnames(model$y)
        out <- c(out, list( 
          m = ts(filterout$theta, start = start(model$y), frequency = frequency(model$y)), 
          P_mu = filterout$P_theta))
      }
      out <- c(out, 
               list(v = ts(t(filterout$v), start = start(model$y), frequency = frequency(model$y)), 
                    F = filterout$F, Finf = filterout$Finf, d = filterout$d, j = filterout$j))      
      
      if (!simplify) 
        out <- c(out, list(K = filterout$K, Kinf = filterout$Kinf))      
    } else {       
      
      if("state"%in%filtering){
        rownames(filterout$a) <- rownames(model$a1)
        out <- c(out, list(
          a = ts(t(filterout$a), start = start(model$y), frequency = frequency(model$y)), 
          P = filterout$P))
        
      } 
      if("signal"%in%filtering){
        colnames(filterout$theta) <- colnames(model$y)
        out <- c(out, list( 
          theta = ts(filterout$theta, start = start(model$y), frequency = frequency(model$y)), 
          P_theta = filterout$P_theta))
      }  
      if("mean"%in%filtering){
        mu<-out$model$y
        P_mu<-array(0,c(p,p,n))
        for(i in 1:p){
          P_mu[i, i, ] <- switch(model$distribution[i], gaussian = filterout$P_theta[i, i, ],
                                 poisson = filterout$P_theta[i, i, ] * (exp(filterout$theta[, i])*model$u[,i])^2, 
                                 binomial = filterout$P_theta[i, i, ] * 
                                   (exp(filterout$theta[, i])/(1 + exp(filterout$theta[, i]))^2)^2, 
                                 gamma = filterout$P_theta[i, i, ] * exp(filterout$theta[, i])^2, 
                                 `negative binomial` = filterout$P_theta[i, i, ] * exp(filterout$theta[, i])^2)
          mu[,i] <- switch(model$distribution[i], gaussian = filterout$theta[,i], 
                           poisson = exp(filterout$theta[,i])*model$u[,i], 
                           binomial = exp(filterout$theta[,i])/(1 + exp(filterout$theta[,i])), 
                           gamma = exp(filterout$theta[,i]), `negative binomial` = exp(filterout$theta[,i]))
          
          
        }
        
        out <- c(out, list(m = mu, P_mu = P_mu))
      }  
    }
  }
  
  if (!("none"%in%smoothing)) {
    
    smoothout <- .Fortran(fgsmoothall, NAOK = TRUE, ymiss, as.integer(tv), model$Z, model$H, 
                          model$T, model$R, model$Q, as.integer(p), as.integer(n), as.integer(m), 
                          as.integer(k), filterout$d, filterout$j, filterout$a, filterout$P, 
                          filterout$v, filterout$F, filterout$K, 
                          r = array(0, dim = c(m, n + 1)), r0 = array(0, dim = c(m, filterout$d + 1)), 
                          r1 = array(0, dim = c(m, filterout$d + 1)), 
                          N = array(0, dim = c(m, m, n + 1)), 
                          N0 = array(0, dim = c(m, m, filterout$d + 1)), 
                          N1 = array(0, dim = c(m, m, filterout$d + 1)), 
                          N2 = array(0, dim = c(m, m, filterout$d + 1)), 
                          filterout$Pinf, filterout$Kinf, filterout$Finf, model$tol, 
                          alphahat = array(0, dim = c(m, n)), V = array(0, dim = c(m, m, n)), 
                          epshat = array(0, dim = c(p, n)), V_eps = array(0, dim = c(p, n)), 
                          etahat = array(0, dim = c(k, n)), V_eta = array(0, dim = c(k, k, n)), 
                          thetahat = array(0, dim = c(p, n)), V_theta = array(0, dim = c(p, p, n)), 
                          as.integer(KFS_transform=="ldl" && ("signal" %in% smoothing || "mean" %in% smoothing)), {if (KFS_transform=="ldl" && ("signal" %in% smoothing || "mean" %in% smoothing)) out$model$Z else double(1)}, 
                          as.integer(dim(out$model$Z)[3]>1), as.integer(KFS_transform != "augment"), 
                          as.integer("state" %in% smoothing), as.integer("disturbance" %in% smoothing), 
                          as.integer(("signal" %in% smoothing || "mean" %in% smoothing)))
    
    if (m > 1 & min(apply(smoothout$V, 3, diag))<0) 
      warning("Possible error in smoothing: Negative variances in V, 
            try changing the tolerance parameter tol of the model.")
    
    if ("state" %in% smoothing) {
      out$alphahat <- ts(t(smoothout$alphahat),start=start(model$y),frequency=frequency(model$y))
      colnames(out$alphahat) <- rownames(model$a1)
      out$V <- smoothout$V
    }
    if ("disturbance" %in% smoothing) {
      out$etahat <- ts(t(smoothout$etahat),start=start(model$y),frequency=frequency(model$y))           
      colnames(out$etahat) <- rownames(model$Q[, , 1])
      out$V_eta <- smoothout$V_eta
      if (KFS_transform != "augment") {
        out$epshat <- ts(t(smoothout$epshat),start=start(model$y),frequency=frequency(model$y))              
        colnames(out$epshat) <- rownames(model$H[, , 1])
        out$V_eps <- smoothout$V_eps
      }
    }
    if ("signal" %in% smoothing) {
      out$thetahat <- ts(t(smoothout$thetahat),start=start(model$y),frequency=frequency(model$y))           
      colnames(out$thetahat) <- rownames(model$H[, , 1])
      out$V_theta <- smoothout$V_theta
    }
    if ("mean" %in% smoothing) {
      out$muhat <- array(NA, c(n, p))
      out$V_mu <- array(0, c(p, p, n))
      for (i in 1:p) {
        out$muhat[, i] <- switch(model$distribution[i], gaussian = smoothout$thetahat[i, ], 
                                 poisson = exp(smoothout$thetahat[i, ])*model$u[,i], 
                                 binomial = exp(smoothout$thetahat[i, ])/(1 + exp(smoothout$thetahat[i, ])), 
                                 gamma = exp(smoothout$thetahat[i, ]), 
                                 `negative binomial` = exp(smoothout$thetahat[i, ]))
        
        out$V_mu[i, i, ] <- switch(model$distribution[i], gaussian = smoothout$V_theta[i, i, ],
                                   poisson = smoothout$V_theta[i, i, ] * out$muhat[, i]^2, 
                                   binomial = smoothout$V_theta[i, i, ] * 
                                     (exp(smoothout$thetahat[i, ])/(1 + exp(smoothout$thetahat[i, ]))^2)^2, 
                                   gamma = smoothout$V_theta[i, i, ] * out$muhat[, i]^2, 
                                   `negative binomial` = smoothout$V_theta[i, i, ] * out$muhat[, i]^2)
      }
      out$muhat<-ts(out$muhat,start=start(model$y),frequency=frequency(model$y))
    }
    if (!simplify && all(model$distribution == "gaussian"))
      out <- c(out, list(r = smoothout$r, r0 = smoothout$r0, r1 = smoothout$r1, N = smoothout$N, 
                         N0 = smoothout$N0, N1 = smoothout$N1, N2 = smoothout$N2))
    
  }    
  
  
  out$call <- match.call(expand.dots = FALSE)
  class(out) <- "KFS"
  out
} 
####$$$$ KFAS\R/ldl.R
#' LDL Decomposition of a Matrix
#'
#' Function \code{ldl} computes the LDL decomposition of a positive semidefinite matrix.
#'
#' @export
#' @param x Symmetrix matrix.
#' @param tol Tolerance parameter for LDL decomposition, determines which
#' diagonal values are counted as zero. Same value is used in isSymmetric function.
#' @return Transformed matrix with D in diagonal, L in strictly lower diagonal 
#' and zeros on upper diagonal.
ldl <- function(x, tol = max(abs(diag(x))) * .Machine$double.eps) {  
    if (!isSymmetric(x, tol = tol)) 
        stop("Matrix is not symmetric!")
    out <- .Fortran(fldl, x = x, as.integer(dim(x)[1]), tol = tol,info=integer(1))
    out$x    
} 
####$$$$ KFAS\R/logLik.SSModel.R
#' Log-likelihood of the State Space Model.
#'
#' Function \code{logLik.SSmodel} computes the log-likelihood value of a state space model.
#'
#'
#' @export
#' @S3method logLik SSModel
#' @method logLik SSModel
#' @aliases logLik logLik.SSModel
#' @param object State space model of class \code{SSModel}.
#' @param nsim Number of independent samples used in estimating the
#' log-likelihood of the non-Gaussian state space model. Default is 0, which
#' gives good starting value for optimization. Only used for non-Gaussian model.
#' @param antithetics Logical. If TRUE, two antithetic variables are used in
#' simulations, one for location and another for scale. Default is TRUE. Only used for non-Gaussian model.
#' @param theta Initial values for conditional mode theta. Only used for non-Gaussian model.
#' @param check.model Logical. If TRUE, function \code{is.SSModel} is called before computing the likelihood. Default is FALSE.
#' @param transform How to transform the model in case of non-diagonal
#' covariance matrix \eqn{H}. Defaults to \code{'ldl'}. See function \code{\link{transformSSM}} for
#' details. 
#' @param maxiter The maximum number of iterations used in linearisation. Default is 50. Only used for non-Gaussian model.
#' @param seed The value is used as a seed via set.seed function. Only used for non-Gaussian model.
#' @param convtol Tolerance parameter for convergence checks for Gaussian approximation.
#'  Iterations are continued until 
#'  \eqn{tol>abs(dev_{old}-dev_{new})/(abs(dev_{new})+0.1))}.
#' @param ... Ignored.
#' @return \item{}{log-likelihood of the state space model.}
logLik.SSModel <- function(object, nsim = 0, antithetics = TRUE, theta, check.model = FALSE, 
                           transform = c("ldl","augment"), maxiter = 50, 
                           seed, convtol=1e-8,...) {
  if (check.model) {
    if (!is.SSModel(object, na.check = TRUE)) {
      return(-.Machine$double.xmax)
    }
  }
  
  p <- attr(object, "p")
  m <- attr(object, "m")
  k <- attr(object, "k")
  n <- attr(object, "n")
  ymiss <- array(is.na(object$y), dim = c(n, p))
  storage.mode(ymiss) <- "integer"
  tv <- array(0, dim = 5)
  tv[1] <- dim(object$Z)[3] > 1
  tv[2] <- any(object$distribution != "gaussian") || dim(object$H)[3] > 1
  tv[3] <- dim(object$T)[3] > 1
  tv[4] <- dim(object$R)[3] > 1
  tv[5] <- dim(object$Q)[3] > 1
  if (all(object$distribution == "gaussian")) {
      if(all(c(object$Q,object$H)==0) || all(c(object$R,object$H)==0)|| any(!is.finite(c(object$R,object$Q,object$H)==0)))
        return(-.Machine$double.xmax^0.75)
    kfout <- NULL
    if (p == 1) {
      kfout <- .Fortran(fglogliku, NAOK = TRUE, object$y, ymiss, as.integer(tv), object$Z, object$H, object$T, object$R, 
                        object$Q, object$a1, object$P1, object$P1inf, as.integer(m), as.integer(k),as.integer(n), lik = double(1), object$tol, as.integer(sum(object$P1inf)))
      
    } else {
      if (any(abs(apply(object$H, 3, "[", !diag(p))) > object$tol)) {
        object <- tryCatch(transformSSM(object, type = match.arg(arg = transform, choices = c("ldl","augment"))), error = function(e) e)
        if (!inherits(object, "SSModel")) {
          warning(object$message)
          return(-.Machine$double.xmax^0.75)
        }
        tv[1] <- dim(object$Z)[3] > 1
        tv[2] <- dim(object$H)[3] > 1
        tv[5] <- dim(object$Q)[3] > 1
      }
      
      kfout <- .Fortran(fgloglik, NAOK = TRUE, object$y, ymiss, as.integer(tv), object$Z, object$H, object$T, object$R, object$Q, 
                        object$a1, object$P1, object$P1inf, as.integer(p), as.integer(m), as.integer(k),as.integer(n), lik = double(1), object$tol, as.integer(sum(object$P1inf)))
    }
    logLik <- kfout$lik
  } else {
    if(all(c(object$Q,object$u)==0) || all(c(object$R,object$u)==0) || any(!is.finite(c(object$R,object$Q,object$u)==0)))
      return(-.Machine$double.xmax^0.75)
    if (missing(theta)) {
      theta <- sapply(1:p, function(i)
        switch(object$distribution[i], 
               gaussian = object$y[, i], 
               poisson = log(pmax(object$y[,i]/object$u[, i], 0.1, na.rm = TRUE)), 
               binomial = qlogis((ifelse(is.na(object$y[, i]), 0.5, object$y[, i]) + 0.5)/(object$u[, i] + 1)), 
               gamma = log(pmax(object$y[, i], 1, na.rm = TRUE)), 
               `negative binomial` = log(pmax(object$y[, i], 1/6, na.rm = TRUE))))
    } else theta <- array(theta, dim = c(n, p))
    
    if (nsim == 0) {
      nsim <- 1
      sim <- 0
      epsplus <- array(0, c(1, 1, 1))
      etaplus <- array(0, c(1, 1, 1))
      aplus1 <- array(0, dim = c(1, 1))
      c2 <- numeric(1)
      nnd <- 0
      nd <- which(diag(object$P1inf) == 0)
    } else {
      sim <- 1
      epsplus <- array(0, c(p, n, nsim))
      etaplus <- array(0, c(k, n, nsim))
      aplus1 <- array(0, dim = c(m, nsim))
      c2 <- numeric(nsim)
      
      x <- array(t(!ymiss), c(p, n, nsim))
      dfeps <- sum(x)/nsim
      
      x2 <- array(apply(object$Q, 3, diag) > object$tol, c(k, (n - 1) * tv[5] + 1))
      x2 <- array(x2, c(k, n, nsim))
      dfeta <- sum(x2)/nsim
      
      nde <- which(diag(object$P1) > object$tol)
      nnd <- length(nde)
      nd <- which(diag(object$P1inf) == 0)
      dfu <- dfeps + dfeta + nnd
      if (missing(seed)) 
        seed <- 123
      set.seed(seed)
      u <- rnorm(n = dfu * nsim, mean = 0, sd = 1)
      
      if (dfeps > 0) 
        epsplus[x] <- u[1:(dfeps * nsim)]
      if (dfeta > 0) 
        etaplus[x2] <- u[(dfeps * nsim + 1):(dfeps * nsim + dfeta * nsim)]
      if (nnd > 0) 
        aplus1[nde, ] <- u[(dfeps * nsim + dfeta * nsim + 1):(dfu * nsim)]
      
      
      if (antithetics) {
        for (i in 1:nsim) {
          u <- c(etaplus[, , i], epsplus[, , i], aplus1[, i])
          c2[i] <- t(u) %*% c(u)
        }
        q <- pchisq(c2, df = dfu)
        c2 <- sqrt(qchisq(1 - q, dfu)/c2)
      }
    }      
    nsim2 <- as.integer(max(sim * (3 * antithetics * nsim + nsim), 1))
    
    out <- .Fortran(fngloglik, NAOK = TRUE, object$y, ymiss, as.integer(tv), object$Z, object$T, object$R, object$Q, object$a1, 
                    object$P1, object$P1inf, as.integer(p), as.integer(m), as.integer(k),as.integer(n), lik = double(1), theta = theta, object$u, pmatch(x = object$distribution, table = c("gaussian", 
                                                                                                                                                                                            "poisson", "binomial", "gamma", "negative binomial"), duplicates.ok = TRUE), maxiter=as.integer(maxiter), as.integer(sum(object$P1inf)), 
                    convtol, as.integer(nnd), as.integer(nsim), epsplus, etaplus, aplus1, c2, object$tol, info = integer(1), as.integer(antithetics), 
                    as.integer(sim), nsim2, as.integer(nd), as.integer(length(nd)),diff=double(1))
    if (!is.finite(out$diff)){
      warning("Non-finite difference in approximation algoritm.")
      return(-.Machine$double.xmax^0.75)
    }
    if(out$maxiter==maxiter){
      warning(paste("Maximum number of iterations reached, 
                    the approximation algorithm did not converge. Latest difference was",out$diff))
    }
    
    
    
    # add the scaling factor from approximating model
    logLik <- out$lik +
      sum(sapply(1:p,function(i) 
        switch(object$distribution[i], 
               gaussian = 0, 
               poisson = sum(dpois(x = object$y[,i], lambda = exp(out$theta[, i])*object$u[,i], log = TRUE), na.rm = TRUE),
               binomial = sum(dbinom(x = object$y[, i], size = object$u[, i], prob = (exp(out$theta[, i])/(1 + exp(out$theta[, i]))), log = TRUE), na.rm = TRUE), 
               gamma = sum(dgamma(x = object$y[,i], shape = object$u[, i], scale = exp(out$theta[, i])/object$u[, i], log = TRUE), na.rm = TRUE), 
               `negative binomial` = sum(dnbinom(x = object$y[, i], size = object$u[, i], 
                                                 mu = exp(out$theta[, i]), log = TRUE), na.rm = TRUE))))
    
  }
  logLik
} 
####$$$$ KFAS\R/predict.SSModel.R
#' State Space Model Predictions
#'
#' Function \code{predict.SSModel} predicts the future observations of a state space model of class \code{\link{SSModel}}
#'
#' For non-Gaussian models, the results depend whether importance sampling is used (\code{nsim>0}).
#' without simulations, the confidence intervals in response scale are computed in linear predictor scale, 
#' and then transformed to response scale. The prediction intervals are not supported.
#' With importance sampling, the confidence intervals are computed as the empirical quantiles from the weighted sample, 
#' whereas the prediction intervals contain additional step of simulating the response variables from the sampling distribution \eqn{p(y|\theta^i)}.
#' 
#' If no simulations are used, the standard errors in response scale are computed using delta method.
#' 
#' @export
#' @method predict SSModel
#' @S3method predict SSModel
#' @aliases predict predict.SSModel
#' @param object Object of class \code{SSModel}.
#' @param newdata A compatible \code{SSModel} object to be added in the end of the old object for 
#' which the predictions are required. If omitted, predictions are either for the whole data (fitted values), 
#' or if argument \code{n.ahead} is given, \code{n.ahead} time steps ahead.
#' @param n.ahead Number of steps ahead at which to predict. Only used if \code{newdata} is omitted. 
#' Note that when using \code{n.ahead}, object cannot contain time varying system matrices.
#' @param interval Type of interval calculation.
#' @param level Confidence level for intervals.
#' @param type Scale of the prediction, \code{'response'} or \code{'link'}.
#' @param states Which states are used in computing the predictions. Either a numeric vector containing the indices of the corresponding states,
#' or a character vector defining the types of the corresponding states. 
#' Possible choices are \dQuote{all}, \dQuote{arima}, \dQuote{custom}, \dQuote{cycle}, \dQuote{seasonal}, 
#' \dQuote{trend}, or \dQuote{regression}. These can be combined. Default is \dQuote{all}.
#' @param nsim Number of independent samples used in importance sampling. Used only for non-Gaussian models.
#' @param se.fit If TRUE, standard errors are computed. Default is FALSE.
#' @param prob if TRUE (default), the predictions in binomial case are probabilities instead of counts.
#' @param maxiter The maximum number of iterations used in approximation Default is 50. 
#' Only used for non-Gaussian model.
#' @param \dots Ignored.
#' @return A matrix or list of matrices containing the predictions, and optionally standard errors.
#' @examples
#' 
#'  \dontrun{
#' set.seed(1)
#' x<-runif(n=100,min=1,max=3)
#' y<-rpois(n=100,lambda=exp(-1+x))
#' model<-SSModel(y~x,distribution="poisson")
#' xnew<-seq(0.5,3.5,by=0.1)
#' newdata<-SSModel(rep(NA,length(xnew))~xnew,distribution="poisson")
#' pred<-predict(model,newdata=newdata,interval="prediction",level=0.9,nsim=1000)
#' plot(x=x,y=y,pch=19,ylim=c(0,25),xlim=c(0.5,3.5))
#' matlines(x=xnew,y=pred,col=c(2,2,2),lty=c(1,2,2),type="l")
#' 
#' model<-SSModel(Nile~SSMtrend(1,Q=1469),H=15099)
#' pred<-predict(model,n.ahead=10,interval="prediction",level=0.9)
#' }
predict.SSModel <- function(object, newdata, n.ahead, interval = c("none", "confidence", "prediction"), 
                            level = 0.95, type = c("response", "link"), states=NULL, se.fit = FALSE, nsim = 0, 
                            prob = TRUE, maxiter=50, ...) {
  
  
  interval <- match.arg(interval)
  type <- match.arg(type)
  
  
  is.SSModel(object, na.check = TRUE, return.logical = FALSE)
  
  m <- attr(object, "m")
  p <- attr(object, "p")
  k <- attr(object, "k")
  
  if (missing(states)) {
    states <- as.integer(1:m)
  } else {
    if (is.numeric(states)) {
      states <- as.integer(states)
      if (min(states) < 1 | max(states) > m) 
        stop("Vector states should contain the indices or types of the states which are combined.")
    } else {
      states <- match.arg(arg = states, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                          several.ok = TRUE)
      if ("all" %in% states) {
        states <- as.integer(1:m)
      } else states <- which(attr(object, "state_types") %in% states)
    }
  }
  gaussianmodel <- all(object$distribution == "gaussian")
  
  if (!missing(newdata) && !is.null(newdata)) {
    
    is.SSModel(newdata, na.check = TRUE, return.logical = FALSE)
    if (p != attr(newdata, "p")) 
      stop("Different number of time series for 'object' and 'newdata'.")
    if (m != attr(newdata, "m")) 
      stop("Different number of states for 'object' and 'newdata'.")
    if (k != attr(newdata, "k")) 
      stop("Different number of disturbance terms for 'object' and 'newdata'.")
    if (!identical(object$distribution, newdata$distribution)) 
      stop("Different distributions for 'object' and 'newdata'")
    
    no <- attr(object, "n")
    nn <- attr(newdata, "n")
    n <- attr(object, "n") <- no + nn
    timespan <- (no + 1):n
    
    object$y <- rbind(object$y, newdata$y)
    tvo <- tvn <- logical(5)
    tvo[1] <- dim(object$Z)[3] > 1
    tvo[2] <- gaussianmodel && (dim(object$H)[3] > 1)
    tvo[3] <- dim(object$T)[3] > 1
    tvo[4] <- dim(object$R)[3] > 1
    tvo[5] <- dim(object$Q)[3] > 1
    tvn[1] <- dim(newdata$Z)[3] > 1
    tvn[2] <- gaussianmodel && (dim(object$H)[3] > 1)
    tvn[3] <- dim(newdata$T)[3] > 1
    tvn[4] <- dim(newdata$R)[3] > 1
    tvn[5] <- dim(newdata$Q)[3] > 1
    
    if (tvo[1] || tvn[1] || !identical(object$Z, newdata$Z)) {
      object$Z <- array(data = c(array(object$Z, dim = c(m, p, no)), array(newdata$Z, dim = c(m, p, nn))), dim = c(p, m, 
                                                                                                                   n))
    }
    
    if (gaussianmodel && (tvo[2] || tvn[2] || !identical(object$H, newdata$H))) {
      object$H <- array(data = c(array(object$H, dim = c(p, p, no)), array(newdata$H, dim = c(p, p, nn))), dim = c(p, p, 
                                                                                                                   n))
    } else object$u <- array(data = c(array(object$u, dim = c(no, p)), array(newdata$u, dim = c(nn, p))), dim = c(n, p))
    
    if (tvo[3] || tvn[3] || !identical(object$T, newdata$T)) {
      object$T <- array(data = c(array(object$T, dim = c(m, m, no)), array(newdata$T, dim = c(m, m, nn))), dim = c(m, m, 
                                                                                                                   n))
    }
    
    if (tvo[4] || tvn[4] || !identical(object$R, newdata$R)) {
      object$R <- array(data = c(array(object$R, dim = c(m, k, no)), array(newdata$R, dim = c(m, k, nn))), dim = c(m, k, 
                                                                                                                   n))
    }
    
    if (tvo[5] || tvn[5] || !identical(object$Q, newdata$Q)) {
      object$Q <- array(data = c(array(data = object$Q, dim = c(k, k, no)), array(data = newdata$Q, dim = c(k, k, nn))), 
                        dim = c(k, k, n))
    }
    
  } else {
    if(!missing(n.ahead) && !is.null(n.ahead)){
     
      tv  <- logical(5)
      tv[1] <- dim(object$Z)[3] > 1
      tv[2] <- gaussianmodel && (dim(object$H)[3] > 1)
      tv[3] <- dim(object$T)[3] > 1
      tv[4] <- dim(object$R)[3] > 1
      tv[5] <- dim(object$Q)[3] > 1
      
      if(!gaussianmodel) tvu<-any(c(apply(object$u,2,function(x) length(unique(x))>1))) else tvu<-FALSE
      if(any(tv) || tvu)
        stop("Model contains time varying system matrices, cannot use argument 'n.ahead'. Use 'newdata' instead.")
      
      timespan <- attr(object, "n") + 1:n.ahead
      n<-attr(object, "n") <- attr(object, "n")+as.integer(n.ahead)
      object$y<-window(object$y,end=end(object$y)+c(n.ahead,0),extend=TRUE)     #!!
      if(any(object$distribution!="gaussian")) object$u<-rbind(object$u,matrix(object$u[1,],nrow=n.ahead,ncol=ncol(object$u),byrow=TRUE))
                      
    } else timespan <- 1:attr(object, "n")
    
  }
  
  
  if (!gaussianmodel && interval == "prediction") {
    if (type == "link") 
      stop("Prediction intervals can only be computed at response scale.")
    if (nsim < 1) 
      stop("Cannot compute prediction intervals for non-gaussian models without importance sampling.")
  }
  
  pred <- vector("list", length = p)
  
  if(gaussianmodel){
    if (identical(states, as.integer(1:m))) {
      out <- KFS(model = object, smoothing = "mean")
    } else {
      out <- signal(KFS(model = object, smoothing = "state"), states = states)
      names(out)<-c("muhat","V_mu")
    }
    
    for (i in 1:p) {
      pred[[i]] <- 
        cbind(fit=out$muhat[timespan, i], 
              switch(interval, none = NULL, 
                     confidence = out$muhat[timespan, i] +
                       qnorm((1 - level)/2) * 
                       sqrt(out$V_mu[i, i, timespan])%o% c(1, -1),
                     prediction = out$muhat[timespan, i] + 
                       qnorm((1 - level)/2) * 
                       sqrt(out$V_mu[i, i, timespan] + 
                              object$H[i, i, if (dim(object$H)[3] > 1) timespan else 1]) %o% c(1, -1)),
              se.fit=if(se.fit)  sqrt(out$V_mu[i, i, timespan]))
      if(interval!="none")
        colnames(pred[[i]])[2:3] <- c("lwr", "upr")
    }
  } else{
    if(nsim < 1){
      if (identical(states, as.integer(1:m))) {
        out <- KFS(model = object, smoothing = "signal")
      } else {
        out <- signal(KFS(model = object, smoothing = "state",maxiter=maxiter), states = states)
        names(out)<-c("thetahat","V_theta")
      }
      out <- KFS(model = object, smoothing = "signal",maxiter=maxiter)
      for (i in 1:p) {
        pred[[i]] <- cbind(fit=out$thetahat[timespan, i]+
                             (if(object$distribution[i]=="poisson") log(object$u[timespan, i]) else 0), 
                           switch(interval, none = NULL, out$thetahat[timespan, i] +
                                    (if(object$distribution[i]=="poisson") log(object$u[timespan, i]) else 0) +
                                    qnorm((1 - level)/2) * sqrt(out$V_theta[i, i, timespan]) %o% c(1, -1)),
                           se.fit=if (se.fit)  sqrt(out$V_theta[i, i, timespan])           )
        if(interval=="confidence")
          colnames(pred[[i]])[2:3] <- c("lwr", "upr")
      }
      if(type=="response"){
        if (se.fit) {
          tmp<-which(colnames(pred[[1]])=="se.fit")
          for (i in 1:p) {
            pred[[i]][,"se.fit"] <- switch(object$distribution[i], 
                                           gaussian = pred[[i]][,"se.fit"], 
                                           poisson = pred[[i]][,"se.fit"] * exp(pred[[i]][, 1]), 
                                           binomial = pred[[i]][,"se.fit"] * (if (!prob) object$u[timespan,i] else 1) * 
                                             exp(pred[[i]][, 1])/(1 + exp(pred[[i]][, 1]))^2, 
                                           gamma = pred[[i]][,"se.fit"] * exp(pred[[i]][, 1]), 
                                           `negative binomial` = pred[[i]][,"se.fit"] * exp(pred[[i]][, 1]))         
            pred[[i]][,-tmp] <- switch(object$distribution[i], gaussian = pred[[i]][,-tmp], 
                                       poisson = exp(pred[[i]][,-tmp]), 
                                       binomial = (if (!prob) object$u[timespan, i] else 1) * exp(pred[[i]][,-tmp])/(1 + exp(pred[[i]][,-tmp])), 
                                       gamma = exp(pred[[i]][,-tmp]), `negative binomial` = exp(pred[[i]][,-tmp]))  
          }
        } else {
          for (i in 1:p)     
            pred[[i]] <- switch(object$distribution[i], gaussian = pred[[i]], 
                                poisson = exp(pred[[i]]), 
                                binomial = (if (!prob) object$u[timespan, i] else 1) * exp(pred[[i]])/(1 + exp(pred[[i]])), 
                                gamma = exp(pred[[i]]), `negative binomial` = exp(pred[[i]]))
        }
      }
    } else{
      if (interval == "none") {
        imp <- importanceSSM(object, ifelse(identical(states, as.integer(1:m)), "signal", "states"), 
                             nsim = nsim, antithetics = TRUE,maxiter=maxiter) 
        if (!identical(states, as.integer(1:m))) 
          imp$samples <- .Fortran(fzalpha, as.integer(dim(object$Z)[3] > 1), object$Z, imp$samples, 
                                  signal = array(0, c(n, p, nsim)), p, n, m, nsim, 
                                  as.integer(length(states)), states)$signal
        
        
        imp <- importanceSSM(object, "signal", nsim = nsim, antithetics = TRUE,maxiter=maxiter)
        nsim <- as.integer(4 * nsim)
        w <- imp$weights/sum(imp$weights) 
        
        if (type == "response") {
          for (i in 1:p) {
            imp$samples[timespan, i, ] <- 
              switch(object$distribution[i], 
                     gaussian = imp$samples[timespan, i, ], 
                     poisson = object$u[timespan, i] * exp(imp$samples[timespan, i, ]), 
                     binomial = (if (!prob) object$u[timespan, i] else 1) * 
                       exp(imp$samples[timespan, i, ])/(1 + exp(imp$samples[timespan, i, ])), 
                     gamma = exp(imp$samples[timespan, i, ]), 
                     `negative binomial` = exp(imp$samples[timespan, i, ]))
          }
        } else{
          for (i in 1:p) 
            if(object$distribution[i]=="poisson")
              imp$samples[timespan, i, ] <- imp$samples[timespan, i, ]+ log(object$u[timespan, i])
          
        }
        varmean <- .Fortran(fvarmeanw, imp$samples[timespan, , ], w, p, as.integer(length(timespan)), 
                            nsim, mean = array(0, c(length(timespan), p)), 
                            var = array(0, c(length(timespan), p)), as.integer(se.fit))
        if (se.fit) {
          pred <- lapply(1:p, function(j) cbind(fit = varmean$mean[, j], se.fit = sqrt(varmean$var[, j])))
        } else {
          pred <- lapply(1:p, function(j) fit = varmean$mean[, j])
        }
        
      } else {
        pred <- interval(object, interval = interval, level = level, type = type, states = states, 
                         nsim = nsim, se.fit = se.fit, timespan = timespan, prob = prob,maxiter=maxiter)
      }
      
    }
  }
  
  
  names(pred) <- colnames(object$y)
  
  pred<-lapply(pred,ts,end=end(object$y),frequency=frequency(object$y))
  if (p==1)
    pred<-pred[[1]]
  pred
  
} 
####$$$$ KFAS\R/print.objects.R
#' Print SSModel Object
#' @S3method print SSModel
#' @method print SSModel
#' @param x SSModel object
#' @param ... Ignored.

print.SSModel <- function(x, ...) {
    cat("\nCall:\n", paste(deparse(x$call), sep = "\n", collapse = "\n"), "\n\n", sep = "")
    cat("State space model object of class SSModel\n\n")
    cat("Dimensions:\n")
    print(paste0("Number of time points: ", attr(x, "n")), quote = FALSE)
    print(paste0("Number of time series: ", attr(x, "p")), quote = FALSE)
    print(paste0("Number of disturbances: ", attr(x, "k")), quote = FALSE)
    print(paste0("Number of states: ", attr(x, "m")), quote = FALSE)
    cat("Names of the states:\n")
    print.default(format(rownames(x$a1)), quote = FALSE, print.gap = 2L)
    cat("Distributions of the time series:\n")
    print.default(format(x$distribution), quote = FALSE, print.gap = 2L)
    
    if (is.SSModel(x)) {
        cat("\nObject is a valid object of class SSModel.")
    } else {
        is.SSModel(x, return.logical = FALSE)
    }
}

#' Print Ouput of Kalman Filter and Smoother
#' @S3method print KFS
#' @method print KFS
#' @param x output object from function KFS.
#' @param digits minimum number of digits to be printed.
#' @param ... Ignored.

print.KFS <- function(x, digits = max(3L, getOption("digits") - 3L), ...) {
    p <- attr(x$model, "p")
    m <- attr(x$model, "m")
    n <- attr(x$model, "n")
    pdiag <- 1 + 0:(p - 1) * (p + 1)
    mdiag <- 1 + 0:(m - 1) * (m + 1)
    if (!is.null(x$a) && is.null(x$alphahat)){
        
        cat("\n Filtered values of the first and last states and their standard errors:\n")
        
        print_this <- cbind(t(x$a[c(1, n + 1), , drop = FALSE]), sqrt(x$P[, , 1][mdiag]), sqrt(x$P[, , n + 1][mdiag]))
        colnames(print_this) <- c("a_1", paste0("a_", n + 1), "se_1", paste0("se_", n + 1))
        print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
        
    }
    if (!is.null(x$theta) && is.null(x$thetahat)){
      
      cat("\n Filtered values of the first and last signals and their standard errors:\n")
      
      print_this <- cbind(t(x$theta[c(1, n), , drop = FALSE]), 
                          sqrt(x$P_theta[, , 1][pdiag]), 
                          sqrt(x$P_theta[, , n][pdiag]))
      colnames(print_this) <- c("theta_1", paste0("theta_", n), "se_1", paste0("se_", n))
      print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
      
    }
    if (!is.null(x$mu) && is.null(x$muhat)) {
      cat("\n Filtered values of the first and last mus and their standard errors:\n")
      
      print_this <- cbind(t(x$mu[c(1, n), ]), sqrt(x$P_mu[, , 1][pdiag]), sqrt(x$P_mu[, , n][pdiag]))
      colnames(print_this) <- c("mu_1", paste0("mu_", n), "se_1", paste0("se_", n))
      print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
      
    }
    
    if (!is.null(x$alphahat)) {
        cat("\n Smoothed values of the first and last states and their standard errors:\n")
        
        print_this <- cbind(t(x$alphahat[c(1, n), , drop = FALSE]), sqrt(x$V[, , 1][mdiag]), sqrt(x$V[, , n][mdiag]))
        colnames(print_this) <- c("alphahat_1", paste0("alphahat_", n), "se_1", paste0("se_", n))
        print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
    }
    
    if (!is.null(x$thetahat)) {
        cat("\n Smoothed values of the first and last signals and their standard errors:\n")
        
        print_this <- cbind(t(x$thetahat[c(1, n), ]), sqrt(x$V_theta[, , 1][pdiag]), sqrt(x$V_theta[, , n][pdiag]))
        colnames(print_this) <- c("thetahat_1", paste0("thetahat_", n), "se_1", paste0("se_", n))
        print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
        
    }
    if (!is.null(x$muhat)) {
        cat("\n Smoothed values of the first and last mus and their standard errors:\n")
        
        print_this <- cbind(t(x$muhat[c(1, n), ]), sqrt(x$V_mu[, , 1][pdiag]), sqrt(x$V_mu[, , n][pdiag]))
        colnames(print_this) <- c("mu_1", paste0("mu_", n), "se_1", paste0("se_", n))
        print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
        
    }
    
    if (!is.null(x$epshat)) {
        cat("\n Smoothed values of the first and last epsilon disturbances and their standard errors:\n")
        
        print_this <- cbind(t(x$epshat[c(1, n), ]), sqrt(x$V_eps[, 1]), sqrt(x$V_eps[, n]))
        colnames(print_this) <- c("epshat_1", paste0("epshat_", n), "se_1", paste0("se_", n))
        print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
    }
    if (!is.null(x$etahat)) {
        cat("\n Smoothed values of the first and last eta disturbances and their standard errors:\n")
        kdiag <- 1 + 0:(attr(x$model, "k") - 1) * (attr(x$model, "k") + 1)
        
        print_this <- cbind(t(x$etahat[c(1, n), ]), sqrt(x$V_eta[, , 1][kdiag]), sqrt(x$V_eta[, , n][kdiag]))
        colnames(print_this) <- c("etahat_1", paste0("etahat_", n), "se_1", paste0("se_", n))
        print.default(format(print_this, digits = digits), quote = FALSE, print.gap = 2)
    }
    
} 
####$$$$ KFAS\R/residuals.KFS.R
#' Extract Residuals of KFS output
#' 
#' @details For object of class KFS, several types of residuals can be computed:
#' 
#' \itemize{
#' \item 'recursive': One-step ahead prediction residuals
#' \deqn{v_{t,i}),}
#' with residuals being undefined in diffuse phase. Only supported for fully Gaussian models.
#' 
#' \item 'response': Data minus fitted values, \eqn{y-E(y)}{y-E(y)}. 
#' 
#' \item 'pearson':  \deqn{(y_{t,i}-\theta_{t,i})/\sqrt{V(\mu)_{t,i}}, \quad i=1,\ldots,p,t=1,\ldots,n,}{(y[t,i]-\theta[t,i])V(\mu)[t,i]^(-0.5), i=1,\ldots,p, t=1,\ldots,n,}
#'                   where \eqn{V(\mu_{t,i})}{V(\mu[t,i])} is the variance function of the model.
#'
#' \item 'state':  Residuals based on the smoothed disturbance terms \eqn{\eta} are defined as
#' \deqn{\hat \eta_t, \quad t=1,\ldots,n,}{L^{-1}[t] \eta[t], t=1,\ldots,n}.
#' 
#' \item 'deviance': Deviance residuals.
#' }
#' @S3method residuals KFS
#' @method residuals KFS
#' @param object KFS object
#' @param type Character string defining the type of residuals.
#' @param ... Ignored.

residuals.KFS <- function(object, type = c("recursive","deviance", "pearson", "response","state"), ...) {
  
  type <- match.arg(type)
  variance<-function(object){
    vars<-object$model$y
    for(i in 1:length(object$model$distribution))
      vars[,i]<-switch(object$model$distribution[i], 
                       gaussian = 1, 
                       poisson = object$muhat[, i],
                       binomial = object$muhat[, i] * (1 - object$muhat[, i])/object$model$u[,i], 
                       gamma = object$muhat[, i]^2, 
                       `negative binomial` = object$muhat[, i] + object$muhat[, i]^2/object$model$u[, i])
    vars
  }
  
  if ((type == "recursive" || type == "state") && any(object$model$distribution != "gaussian")) 
    stop("Recursive and state residuals are only supported for fully gaussian models.")
  
  series <- 
    switch(type,
           recursive = {
             if (is.null(object[["a",exact=TRUE]])) 
               stop("KFS object needs to contain filtered estimates of states. ")
             series <- object$v
             if(object$d>0){
             series[1:(object$d - 1), ] <- NA
             series[object$d, 1:object$j] <- NA
             }
             series
           },
           response = {
             series <- object$model$y
             if(sum(bins<-object$model$distribution=="binomial")>0)
               series[, bins]<-
               series[, bins]/
               object$model$u[, bins]    
             series-fitted(object)
           },
           state = {
             if (is.null(object$etahat)) {
               stop("KFS object needs to contain smoothed estimates of state disturbances eta.")
             } else {
               object$etahat
             }           
           },
           pearson = {
             series <- object$model$y
             if(sum(bins<-object$model$distribution=="binomial")>0)
               series[, bins]<-
               series[, bins]/
               object$model$u[, bins]           
             (series - fitted(object))/sqrt(variance(object))
           },
           deviance = {  
             series <- object$model$y
             if(sum(bins<-object$model$distribution=="binomial")>0)
               series[, bins]<-
               series[, bins]/
               object$model$u[, bins]
             
             for (i in 1:attr(object$model, "p")) 
               series[, i] <- ifelse(series[, i]>object$muhat[, i],1,-1)*
               sqrt(switch(object$model$distribution[i], 
                           gaussian = (series[,i] - object$muhat[, i])^2, 
                           poisson =
                             2*(series[,i]*log(ifelse(series[,i] == 0, 1, series[,i]/object$muhat[, i])) - 
                                  series[,i] + object$muhat[, i]), 
                           binomial = 2*object$model$u[,i]*(series[,i]*log(ifelse(series[,i] == 0, 1, 
                                                                                  series[,i]/object$muhat[, i])) + 
                                                              (1 - series[,i])* 
                                                              log(ifelse(series[, i] == 1 | object$muhat[, i]==1, 1,
                                                                         (1 - series[,i])/(1 - object$muhat[, i])))), 
                           gamma =
                             -2*(log(ifelse(series[, i] == 0, 1, 
                                            series[,  i]/object$muhat[, i])) - 
                                   (series[, i] - object$muhat[, i])/object$muhat[, i]),
                           `negative binomial` = 
                             2*(series[, i] * log(pmax(1, series[, i])/object$muhat[, i]) - 
                                  (series[, i] + object$model$u[, i]) * 
                                  log((series[, i] + object$model$u[, i])/(object$muhat[, i] + 
                                                                                     object$model$u[, i])))))   
             
             series
           })
 ts(drop(series),start=start(object$model$y),frequency=frequency(object$model$y),names=colnames(object$model$y))
} 
####$$$$ KFAS\R/rstandard.KFS.R
#' Extract Standardized Residuals from KFS output
#' @S3method rstandard KFS
#' @method rstandard KFS
#' @details For object of class KFS, several types of standardized residuals can be computed:
#' \itemize{
#' 
#' \item 'recursive': One-step ahead prediction residuals defined as 
#' \deqn{v_{t,i})/\sqrt{F_{i,t}},}
#' with residuals being undefined in diffuse phase. Only supported for fully Gaussian models.
#' 
#' 
#' \item 'pearson':  Standardized Pearson residuals 
#' \deqn{(y_{t,i}-\theta_{t,i})/\sqrt{V(\mu)_{t,i}\phi_i\sqrt{1-h_{t,i}}}, \quad i=1,\ldots,p,t=1,\ldots,n,}{(y[t,i]-\theta[t,i])/(V(\mu)[t,i]\phi[i](1-h[t,i]))^0.5, i=1,\ldots,p, t=1,\ldots,n,}
#'                   where \eqn{V(\mu_{t,i})}{V(\mu[t,i])} is the variance function of the model, 
#'                   \eqn{\phi_i}{\phi[i]} is the dispersion parameter and \eqn{h_{t,i}}{h[t,i]} 
#'                   is the hat value.  For gaussian models, these coincide with the smoothed 
#'                   \eqn{\epsilon} disturbance residuals.
#'
#' \item 'state':  Residuals based on the smoothed disturbance terms \eqn{\eta} are defined as
#' \deqn{L^{-1}_t \hat \eta_t, \quad t=1,\ldots,n,}{L^{-1}[t] \eta[t], t=1,\ldots,n,} where 
#' \eqn{L_t}{L[t]} is the lower triangular matrix from Cholesky decomposition of \eqn{V_{\eta,t}}{V[\eta,t]}.
#' 
#' \item 'deviance': Deviance residuals.
#' }
#'
#' @param model KFS object
#' @param type Type of residuals. See details.
#' @param ... Ignored.

rstandard.KFS <- function(model, type = c("recursive","deviance", "pearson", "state"), ...) {
  
  type <- match.arg(type)
  
  if ((type == "recursive" || type == "state") && any(model$model$distribution != "gaussian")) 
    stop("Recursive and state residuals are only supported for fully gaussian models.")
  
  recursive <- function(object) {
    if (is.null(object[["v",exact=TRUE]])) 
      stop("KFS object needs to contain innovations from state filtering. ")
    series <- object$v/sqrt(t(object$F))
    series[1:(object$d - 1), ] <- NA
    series[object$d, 1:object$j] <- NA
    series
  }
  
  
    
  pearson <- function(object) {
    if (all(object$model$distribution == "gaussian")) {
      w <- matrix(apply(object$model$H,3,diag), attr(object$model, "n"), attr(object$model, "p"),byrow=TRUE)    
    } else {
      w <- matrix(0, attr(object$model, "n"), attr(object$model, "p"))
      for (i in 1:attr(object$model, "p")) 
        w[, i] <- switch(object$model$distribution[i], 
                         gaussian = object$model$u[,i], 
                         poisson = 1, 
                         binomial = 1, 
                         gamma = 1/object$model$u[,i], 
                         `negative binomial` =1)
    }
    
    series <- object$model$y
    if(sum(bins<-object$model$distribution=="binomial")>0)
      series[, bins]<-
      series[, bins]/
      object$model$u[, bins]
    
    ((series - fitted(object))/sqrt(variance(object)))/sqrt(w*(1 - hatvalues(object)))
  }
  
  deviance <- function(object) {
    if (all(object$model$distribution == "gaussian")) { 
      w <- matrix(apply(object$model$H,3,diag), attr(object$model, "n"), attr(object$model, "p"),byrow=TRUE)
    } else {
      w <- matrix(0, attr(object$model, "n"), attr(object$model, "p"))
      for (i in 1:attr(object$model, "p")) 
        w[, i] <- switch(object$model$distribution[i], 
                         gaussian = object$model$u[,i], poisson = 1, 
                         binomial = 1, 
                         gamma = 1/object$model$u[,i], 
                         `negative binomial` =1)    
    }
    series <- object$model$y
    if(sum(bins<-object$model$distribution=="binomial")>0)
      series[, bins]<-
      series[, bins]/
      object$model$u[, bins]
    
    for (i in 1:attr(object$model, "p")) 
      series[, i] <- ifelse(series[, i]>object$muhat[,i],1,-1)*
      sqrt(switch(object$model$distribution[i], 
                  gaussian = (series[,i] - object$muhat[, i])^2, 
                  poisson =
                    2*(series[,i]*log(ifelse(series[,i] == 0, 1, series[,i]/object$muhat[, i])) - 
                         series[,i] + object$muhat[, i]), 
                  binomial = 2*object$model$u[,i]*(series[,i]*log(ifelse(series[,i] == 0, 1, 
                                                                         series[,i]/object$muhat[, i])) + 
                                                     (1 - series[,i])* 
                                                     log(ifelse(series[, i] == 1 | object$muhat[, i]==1, 1,
                                                                (1 - series[,i])/(1 - object$muhat[, i])))), 
                  gamma =
                    -2*(log(ifelse(object$model$y[, i] == 0, 1, 
                                   object$model$y[,  i]/object$muhat[, i])) - 
                          (object$model$y[, i] - object$muhat[, i])/object$muhat[, i]),
                  `negative binomial` = 
                    2*(object$model$y[, i] * log(pmax(1, object$model$y[, i])/object$muhat[, i]) - 
                         (object$model$y[, i] + object$model$u[, i]) * 
                         log((object$model$y[, i] + object$model$u[, i])/(object$muhat[, i] + 
                                                                            object$model$u[, i])))))   
    
    series/sqrt(w*(1 - hatvalues(object)))
  }
  
  state <- function(object) {
    if (is.null(object$etahat)) {
      stop("KFS object needs to contain smoothed estimates of state disturbances eta.")
    } else {
      k <- attr(object$model, "k")
      n <- attr(object$model, "n")
      if (dim(object$model$Q)[3] == 1) {
        z <- which(object$model$Q[, , 1][1 + 0:(k - 1) * (k + 1)] > 0)
        eta <- array(0, c(n, length(z)))
        for (i in 1:(n - 1)) {
          if (!isTRUE(all.equal(object$etahat[i, z], rep(0, length(z))))) {
            x <- try(chol(solve(object$model$Q[z, z, 1] - object$V_eta[z, z, i])) %*% object$etahat[i, z], TRUE)
            if (inherits(x, "try-error")) {
              warning(paste("Could not compute the standardized smoothed state residuals, V_eta[,,", i, "] is not invertible", 
                            sep = ""))
              break
            } else eta[i, ] <- x
          }
        }
        
      } else {
        z <- NULL
        for (i in 1:k) if (sum(object$model$Q[i, i, ]) > 0) 
          z <- c(z, i)
        zlength <- length(z)
        eta <- array(NA, c(n, zlength))
        if (zlength > 1) {
          for (i in 1:(n - 1)) {
            if (!isTRUE(all.equal(object$etahat[i, z][z2], rep(0, length(z2))))) {
              z2 <- which(object$V_eta[z, z, i][1 + 0:(zlength - 1) * (zlength + 1)] > 0)
              x <- try(chol(solve(object$model$Q[z, z, i][z2, z2] - object$V_eta[z, z, i][z2, z2])) %*% object$etahat[i, 
                                                                                                                      z][z2], TRUE)
              if (inherits(x, "try-error")) {
                warning(paste("Could not compute the standardized smoothed state residuals, V_eta[,,", i, "] is not invertible", 
                              sep = ""))
                break
              } else eta[i, z2] <- x
            }
          }
        } else {
          for (i in 1:n) {
            if (!isTRUE(all.equal(object$etahat[i, z], rep(0, length(z))))) 
              eta[i, 1] <- object$etahat[i, z]/sqrt(object$model$Q[z, z, i] - object$V_eta[z, z, i])
          }
        }
      }
      eta[n, ] <- 0
      eta
      
    }
    
  }
  variance<-function(object){
    vars<-object$model$y
    for(i in 1:length(object$model$distribution))
      vars[,i]<-switch(object$model$distribution[i], 
                       gaussian = 1, 
                       poisson = object$muhat[, i],
                       binomial = object$muhat[, i] * (1 - object$muhat[, i])/object$model$u[,i], 
                       gamma = object$muhat[, i]^2, 
                       `negative binomial` = object$muhat[, i] + object$muhat[, i]^2/object$model$u[, i])
    vars
  }
  
  
  return(ts(drop(do.call(type, list(model))),start=start(model$model$y),frequency=frequency(model$model$y),names=colnames(model$model$y)))
} 
####$$$$ KFAS\R/signals.R
#' Extracting the Partial Signal Of a State Space Model
#'
#' Function \code{signal} returns the signal of a state space model using only subset of states.
#'
#' @export
#' @param object Object of class \code{KFS}.
#' @param states Which states are combined? Either a numeric vector containing the indices of the corresponding states,
#' or a character vector defining the types of the corresponding states. 
#' Possible choices are \dQuote{all}, \dQuote{arima}, \dQuote{custom}, \dQuote{cycle}, \dQuote{seasonal}, 
#' \dQuote{trend}, or \dQuote{regression}. These can be combined. Default is \dQuote{all}.
#' @param filtered If TRUE, filtered signal is used. Otherwise smoothed signal is used.
#' @return
#'\item{signal}{Time series object of filtered signal \eqn{Z_ta_t}{Z[t]a[t]} or smoothed signal \eqn{Z_t\hat\alpha_t}{Z[t]\alpha[t]} using only the defined states.  }
#' \item{variance}{Cov(\eqn{Z_ta_t}{Z[t]a[t]}) or Cov(\eqn{Z_t\hat\alpha_t}{Z[t]\alpha[t]}) using only the defined states. 
#' For the covariance matrices of the filtered signal, only the non-diffuse part P is used.  }
signal <- function(object, states = "all", filtered = FALSE) {
  if(!inherits(object,"KFS"))
    stop("Object must be an output from function KFS.")
  if (is.numeric(states)) {
    states <- as.integer(states)
    if (min(states) < 1 | max(states) > attr(object$model, "m")) 
      stop("Vector states should contain the indices or names of the states which are combined.")
  } else {
    states <- match.arg(arg = states, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), several.ok = TRUE)
    if ("all" %in% states) {
      states <- as.integer(1:attr(object$model, "m"))
    } else states <- which(attr(object$model, "state_types") %in% states)
  }
  
  if (!isTRUE(length(states) > 0)) 
    stop("Selected states not in the model.")
  
  if (identical(states, as.integer(1:attr(object$model, "m")))){
    if(all(object$model$distribution=="gaussian")){
      if(filtered && !is.null(object$m)){
        return(list(signal = object$m, variance = object$P_mu))
      } else {
        if(!is.null(object$muhat))
          return(list(signal = object$muhat, variance = object$V_muhat))
      }
    } else{
      if(filtered && !is.null(object$t)){
        return(list(signal = object$t, variance = object$P_theta))
      } else {
        if(!is.null(object$thetahat))
          return(list(signal = object$thetahat, variance = object$V_theta))
      }
    }
  }
  
  if (filtered) {
    if(is.null(object[["a",exact=TRUE]]))
      stop("Object does not contain filtered estimates of states.")
    a <- object$a
    P <- object$P       
  } else {
    if(is.null(object$alphahat))
      stop("Object does not contain smoothed estimates of states.")   
    a <- object$alphahat
    P <- object$V        
  }
  
  signal <- .Fortran(fsignaltheta, NAOK = TRUE, as.integer(dim(object$model$Z)[3] > 1), 
                     object$model$Z, t(a)[1:attr(object$model, "m"), 1:attr(object$model, "n")], 
                     P[1:attr(object$model, "m"), 1:attr(object$model, "m"), 1:attr(object$model, "n")], 
                     as.integer(attr(object$model, "p")), as.integer(attr(object$model, "n")), 
                     as.integer(attr(object$model, "m")), 
                     theta = array(0, c(attr(object$model, "n"), attr(object$model, "p"))), 
                     V_theta = array(0, c(attr(object$model, "p"), attr(object$model, "p"), attr(object$model, "n"))), 
                     d = as.integer(0), states, as.integer(length(states)))
  
  
  attributes(signal$theta) <- attributes(object$model$y)
  list(signal = signal$theta, variance = signal$V_theta)
} 
####$$$$ KFAS\R/simulateSSM.R
#' Simulation of a gaussian State Space Model
#'
#' Function \code{simulateSMM} simulates states, signals, disturbances or missing observations of
#' the gaussian state space model.
#'
#'
#' Simulation smoother algorithm is based to article by J. Durbin and S.J. Koopman
#' (2002).
#'
#' Function can use two antithetic variables, one for location and other for
#' scale, so output contains four blocks of simulated values which correlate
#' which each other (ith block correlates negatively with (i+1)th block, and
#' positively with (i+2)th block etc.).
#'
#' @export
#' @param object gaussian state space object.
#' @param type What to simulate.
#' @param filtered Simulate from \eqn{p(\alpha_t|y_{t-1},...,y_1)} instead of \eqn{p(\alpha|y)}.
#' @param nsim Number of independent samples. Default is 1.
#' @param antithetics Use antithetic variables in simulation. Default is FALSE.
#' @param conditional Simulations are conditional to data.
#' If FALSE, the initial state \eqn{\alpha_1}{\alpha[1]} is set to \eqn{\hat \alpha_1}{alphahat[1]} computed by \code{KFS},
#' and all the observations are removed from the model. Default is TRUE.
#' @return An n x k x nsim array containing the simulated series, where k is number of observations, signals, states or disturbances.
#' @references Durbin J. and Koopman, S.J. (2002). A simple and efficient
#' simulation smoother for state space time series analysis, Biometrika, Volume
#' 89, Issue 3
simulateSSM <- function(object, type = c("states", "signals", "disturbances", "observations", "epsilon", "eta"), 
                        filtered=FALSE, nsim = 1, antithetics = FALSE, conditional = TRUE) {
  sim.what <- match.arg(arg = type, choices = c("states", "signals", "disturbances", "observations", "epsilon", "eta"))
  is.SSModel(object, na.check = TRUE, return.logical = FALSE)
  
  if (any(object$distribution != "gaussian")) 
    stop("Function is only for gaussian models.")
  if (!conditional) {
    out <- KFS(object, smoothing = "state")
    object$y[] <- NA
    object$a1[] <- out$alphahat[1, ]
    object$P1inf[] <- 0
    object$P1[] <- 0
  }
  
  if (sim.what=="observations" && sum(is.na(object$y)) == 0) 
    stop("There is no missing observations, nothing to simulate.")
  
  p <- attr(object, "p")    
  if(sim.what=="observations"){
    object <- transformSSM(object, type = "augment")
  } else {
    if(p>1 && any(abs(apply(object$H, 3, "[", !diag(p))) > object$tol))
      object <- transformSSM(object = object, type = "ldl") 
  }
  m <- attr(object, "m")
  k <- attr(object, "k")
  n <- attr(object, "n")    
  tv <- array(0, dim = 5)
  tv[1] <- dim(object$Z)[3] > 1
  tv[2] <- dim(object$H)[3] > 1
  tv[3] <- dim(object$T)[3] > 1
  tv[4] <- dim(object$R)[3] > 1
  tv[5] <- dim(object$Q)[3] > 1    
  ymiss <- is.na(object$y)
  storage.mode(ymiss) <- "integer"
  
  
  epsplus <- array(0, c(p, n, nsim))
  etaplus <- array(0, c(k, n, nsim))
  aplus1 <- array(0, dim = c(m, nsim))
  
  
  x <- array(abs(apply(object$H, 3, diag)) > object$tol, c(p, n)) & (!t(ymiss))
  x <- array(x, c(p, n, nsim))
  dfeps <- sum(x)/nsim
  
  x2 <- array(abs(apply(object$Q, 3, diag)) > object$tol, c(k, (n - 1) * tv[5] + 1))
  x2 <- array(x2, c(k, n, nsim))
  dfeta <- sum(x2)/nsim
  
  nde <- which(diag(object$P1) > object$tol)
  nd <- which(diag(object$P1inf) == 0)
  nnd <- length(nde)
  dfu <- dfeps + dfeta + nnd
  u <- rnorm(dfu * nsim, mean = 0, sd = 1)
  
  if (dfeps > 0) 
    epsplus[x] <- u[1:(dfeps * nsim)]
  if (dfeta > 0) 
    etaplus[x2] <- u[(dfeps * nsim + 1):(dfeps * nsim + dfeta * nsim)]
  if (nnd > 0) 
    aplus1[nde, ] <- u[(dfeps * nsim + dfeta * nsim + 1):(dfu * nsim)]
  
  c2 <- numeric(nsim)
  
  if (antithetics) {
    for (i in 1:nsim) {
      u <- c(etaplus[, , i], epsplus[, , i], aplus1[, i])
      c2[i] <- t(u) %*% c(u)
    }
    q <- pchisq(c2, df = dfu)
    c2 <- sqrt(qchisq(1 - q, dfu)/c2)
  }  
  
  sim.what<-which(c("epsilon", "eta","disturbances", "states", "signals", "observations")==sim.what)
  simdim <- as.integer(switch(sim.what,p,k,p+k,m,p,p))
  
  if(!filtered){
    sims.out <- .Fortran(fsimgaussian,NAOK = TRUE, 
                         ymiss, as.integer(tv), object$y, object$Z, object$H, object$T, object$R, 
                         object$Q, object$a1, object$P1, object$P1inf, as.integer(nnd), as.integer(nsim), 
                         epsplus, etaplus, aplus1, as.integer(p), as.integer(n), as.integer(m),as.integer(k),
                         info = as.integer(0), as.integer(sum(object$P1inf)), object$tol, as.integer(nd), 
                         as.integer(length(nd)), sim = array({if(sim.what==6) t(object$y) else 0}, c(simdim, n, 3 * nsim * antithetics + nsim)), 
                         c2,sim.what,simdim,as.integer(antithetics))
  } else {
    if(!(sim.what%in%(4:5)))
      stop("Only state and signal simulation filtering is supported.")
    sims.out <- .Fortran(fsimfilter,NAOK = TRUE, 
                         ymiss, as.integer(tv), object$y, object$Z, object$H, object$T, object$R, 
                         object$Q, object$a1, object$P1, object$P1inf, as.integer(nnd), as.integer(nsim), 
                         epsplus, etaplus, aplus1, as.integer(p), as.integer(n), as.integer(m),as.integer(k),
                         info = as.integer(0), as.integer(sum(object$P1inf)), object$tol, as.integer(nd), 
                         as.integer(length(nd)), sim = array(0, c(simdim, n, 3 * nsim * antithetics + nsim)), 
                         c2,sim.what,simdim,as.integer(antithetics))
  }
  if (sims.out$info != 0) {  
    if (sims.out$info == 2) 
      stop("Couldn't compute LDL decomposition of Q! Try changing the tol parameter of the model.")
    if (sims.out$info == 3) 
      stop("Couldn't compute LDL decomposition of P1! Try changing the tol parameter of the model.")
  }
  
  rownames(sims.out$sim)<-switch(sim.what,rep("eps",p),rep("eta",k),c(rep("eps",p),rep("eta",k)),
                                 rownames(object$a1),colnames(object$y),colnames(object$y))
  aperm(sims.out$sim, c(2, 1, 3))
  
  
} 
####$$$$ KFAS\R/SSMarima.R
#' @rdname SSModel
#' @export
SSMarima <- function(ar = NULL, ma = NULL, d = 0, Q, stationary = TRUE, index,  n, ynames) {
    # Q is either a p times p matrix or scalar (in univariate case)
  
    if(!is.null(ar) && stationary && !all(Mod(polyroot(c(1, -ar))) > 1))
      stop("ARIMA part is non-stationary.")
      
    if (missing(index)) 
        index <- 1
    p <- length(index)
    if (!missing(ynames) && !is.null(ynames)){
      ynames <- paste0(".", ynames)
    } else ynames<-""
    if (missing(Q)) {
        Q <- diag(p)
    } else {
        if (length(Q) == 1) 
            Q <- matrix(Q)
        if (any(dim(Q)[1:2] != p) || length(dim(Q)) > 2) 
            stop("Misspecified Q, argument Q must be (p x p) matrix where p is the number of series.")
    }
    ar_length <- length(ar)
    ma_length <- length(ma)
    d <- max(d, 0)
    m1 <- max(ar_length, ma_length + 1) + d
    k <- p
    
    
    Z_univariate <- matrix(0, 1, m1)
    T_univariate <- P1inf_univariate <- matrix(0, m1, m1)
    R_univariate <- matrix(0, m1, 1)
    
    Z_univariate[1, 1:(d + 1)] <- 1
    if (d > 0) {
        T_univariate[1:d, 1:d][upper.tri(T_univariate[1:d, 1:d], diag = TRUE)] <- 1
        T_univariate[1:d, (d + 1)] <- 1
        P1inf_univariate[1:d, 1:d] <- diag(1, d)
    }
    if (ar_length > 0) 
        T_univariate[(d + 1):(d + ar_length), d + 1] <- ar
    if (m1 > (d + 1)) 
        T_univariate[(d + 1):(m1 - 1), (d + 2):m1] <- diag(1, max(ar_length, ma_length + 1) - 1)
    
    R_univariate[d + 1, 1] <- 1
    if (ma_length > 0) 
        R_univariate[(d + 2):(d + 1 + ma_length)] <- ma
    
    
    m <- p * m1
    Z <- matrix(0, p, m)
    T <- P1 <- P1inf <- matrix(0, m, m)
    R <- matrix(0, m, p)
    
    for (i in 1:p) {
        Z[i, ((i - 1) * m1 + 1):(i * m1)] <- Z_univariate
        T[((i - 1) * m1 + 1):(i * m1), ((i - 1) * m1 + 1):(i * m1)] <- T_univariate
        R[((i - 1) * m1 + 1):(i * m1), i] <- R_univariate
        P1inf[((i - 1) * m1 + 1):(i * m1), ((i - 1) * m1 + 1):(i * m1)] <- P1inf_univariate
    }
    
    
    if (stationary) {
        nd <- which(diag(P1inf) == 0)
        temp <- try(solve(a = diag((m - d * p)^2) - matrix(kronecker(T[nd, nd], T[nd, nd]), (m - d * p)^2, (m - d * p)^2), b = c(R[nd, 
            , drop = FALSE] %*% Q %*% t(R[nd, , drop = FALSE]))), TRUE)        
        if (class(temp) == "try-error") {            
            stop("ARIMA part is numerically too close to non-stationarity.")
        } else P1[nd, nd] <- temp
    } else diag(P1inf) <- 1
    state_names <- paste0(rep(paste0("arima", 1:m1), p), rep(ynames, each = m1))
    
    list(index = index, m = m, k = k, Z = Z, T = T, R = R, Q = Q, a1 = matrix(0, m, 1), P1 = P1, P1inf = P1inf, tvq = 0, tvr = 0, 
        tvz = 0, state_names = state_names)
} 
####$$$$ KFAS\R/SSMcustom.R
#' @rdname SSModel
#' @export
SSMcustom <- function(Z, T, R, Q, a1, P1, P1inf, index, n) {
    if (missing(index)) 
        index <- 1
    p <- length(index)
    
    if (length(Z) == 1 && p == 1) {
        dim(Z) <- c(1, 1, 1)
        m <- 1
    } else {
        if (!(dim(Z)[1]== p) || !dim(Z)[3] %in% c(1, NA, n)) 
            stop("Misspecified Z, argument Z must be a (p x m) matrix, (p x m x 1) or (p x m x n) array, where p is the number of time series, m is the number of states.")
        m <- dim(Z)[2]
        dim(Z) <- c(p, m, (n - 1) * (max(dim(Z)[3], 0, na.rm = TRUE) > 1) + 1)
    }
    
    if (length(T) == 1 && m == 1) {
        dim(T) <- c(1, 1, 1)
    } else {
        if (any(dim(T)[1:2] != m) || !dim(T)[3] %in% c(1, NA, n)) 
            stop("Misspecified T, argument T must be a (m x m) matrix, (m x m x 1) or (m x m x n) array, where m is the number of states.")
        dim(T) <- c(m, m, (n - 1) * (max(dim(T)[3], 0, na.rm = TRUE) > 1) + 1)
    }
    
    if (length(Q) == 1) {
        dim(Q) <- c(1, 1, 1)
        k <- 1
    } else {
        if (!identical(dim(Q)[1], dim(Q)[2]) || dim(Q)[1] > m || !dim(Q)[3] %in% c(1, NA, n)) 
            stop("Misspecified Q, argument Q must be a (k x k) matrix, (k x k x 1) or (k x k x n) array, where k<=m is the number of disturbances eta, and m is the number of states.")
        k <- dim(Q)[1]
        dim(Q) <- c(k, k, (n - 1) * (max(dim(Q)[3], 0, na.rm = TRUE) > 1) + 1)
    }
    if (missing(R)) {
        R <- diag(m)[, 1:k, drop = FALSE]
        dim(R) <- c(m, k, 1)
    } else {
        if (all(c(length(R), k, m) == 1)) {
            dim(R) <- c(1, 1, 1)
        } else {
            if (!(dim(R)[1]== m) || dim(R)[2] != k || !dim(R)[3] %in% c(1, NA, n)) 
                stop("Misspecified R, argument R must be a (m x k) matrix, (m x k x 1) or (m x k x n) array, where k<=m is the number of disturbances eta, and m is the number of states.")
            dim(R) <- c(m, k, (n - 1) * (max(dim(R)[3], 0, na.rm = TRUE) > 1) + 1)
        }
    }
    
    if (missing(a1)) {
        a1 <- matrix(0, m, 1)
    } else {
        if (length(a1) <= m) {
            a1 <- matrix(a1, m, 1)
        } else stop("Misspecified a1, argument a1 must be a vector of length t, or (m x 1) matrix, where m is the number of state_names and 1<=t<=m.")
    }
    
    if (missing(P1)) {
        P1 <- matrix(0, m, m)
    } else {
        if (length(P1) == 1 && m == 1) {
            dim(P1) <- c(1, 1)
        } else {
            if (any(dim(P1)[1:2] != m)) 
                stop("Misspecified P1, argument P1 must be (m x m) matrix, where m is the number of states. ")
        }
    }
    if (missing(P1inf)) {
        P1inf <- matrix(0, m, m)
    } else {
        if (length(P1inf) == 1 && m == 1) {
            dim(P1inf) <- c(1, 1)
        } else {
            if (any(dim(P1inf)[1:2] != m)) 
                stop("Misspecified P1inf, argument P1inf must be a (m x m) matrix, where m is the number of states..")
        }
    }    
    diag(P1inf)[diag(P1) > 0 || is.na(diag(P1))] <- 0
    a1[diag(P1inf) > 0] <- 0
    state_names <- paste0("custom", 1:m)
    
    list(index = index, m = m, k = k, p = p, n = n, Z = Z, T = T, R = R, Q = Q, a1 = a1, P1 = P1, P1inf = P1inf, tvz = dim(Z)[3] > 
        1, tvt = dim(T)[3] > 1, tvr = dim(R)[3] > 1, tvq = dim(Q)[3] > 1, state_names = state_names)
} 
####$$$$ KFAS\R/SSMcycle.R
#' @rdname SSModel
#' @export
SSMcycle <- function(period, type, Q, index, a1, P1, P1inf, n, ynames) {
    if (missing(index)) 
        index <- 1
    p <- length(index)
    if (!missing(ynames) && !is.null(ynames)){
      ynames <- paste0(".", ynames)
    } else ynames<-""
    if (missing(type)) {
        type <- 1L
    } else {
        type <- pmatch(x = type, table = c("distinct", "common"))
        if (is.na(type)) 
            stop("type must be 'distinct' or 'common'.")
    }
    
    if (!(length(period) == 1 & period > 0)) 
        stop("Period of the cycle component must be larger than 0. ")
    
    
    lambda <- 2 * pi/period
    m <- 2 * ((p - 1) * (type == 1) + 1)
    Z <- matrix(0, p, m)
    T <- matrix(0, m, m)
    Z_univariate <- matrix(c(1,0), 1, 2)
    T_univariate <- matrix(c(cos(lambda), -sin(lambda), sin(lambda), cos(lambda)), 2, 2)
    if (type != 2) {
      for (i in 1:p) {
        Z[i, ((i - 1) * 2 + 1):(i * 2)] <- Z_univariate
        T[((i - 1) * 2 + 1):(i * 2), ((i - 1) * 2 + 1):(i * 2)] <- T_univariate
      }
    } else {
      Z <- matrix(Z_univariate, nrow = p, ncol = m, byrow = TRUE)
      T <- T_univariate
    }
    state_names <- paste0(c("cycle", "cycle*"), rep(ynames, each = 2))
    
    if (missing(a1)) {
        a1 <- matrix(0, m, 1)
    } else {
        if (length(a1) != m || any(dim(a1) != c(m, 1))) 
            stop("a1 must be a (m x 1) matrix where m is the number of states. ")
        a1 <- matrix(a1, m, 1)
    }
    if (missing(P1)) {
        P1 <- matrix(0, m, m)
    } else {
        if (length(P1) > 1 && any(dim(P1) != m)) 
            stop("P1 must be a (m x m) matrix where m is the number of states. ")
        P1 <- matrix(P1, m, m)
    }
    if (missing(P1inf)) {
        P1inf <- diag(m)
    } else {
        if (length(P1inf) > 1 && any(dim(P1inf) != m)) 
            stop("P1inf must be a (m x m) diagonal matrix where m is the number of states. ")
        P1inf <- matrix(P1inf, m, m)
    }
    diag(P1inf)[diag(P1) > 0 || is.na(diag(P1))] <- 0
    a1[diag(P1inf) > 0] <- 0
    
    if (missing(Q)) {
        k <- 0
        Qm <- R <- NULL
        tvq <- 0
    } else {
        if (type == 1) {
            if (length(Q) != 1 && (!identical(dim(Q)[1], dim(Q)[2]) || dim(Q)[1] != p || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% 
                c(1, n)))) 
                stop("Misspecified Q, argument Q must be (p x p) matrix, (p x p x 1), or (p x p x n) array where m is the number of time series.")
            
            tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
            
            Qm <- array(0, c(m, m, tvq * (n - 1) + 1))
            if (tvq) {
                for (i in 1:(tvq * (n - 1) + 1)) Qm[cbind(rep(1:(p * 2), p), rep(1:2, p^2) + rep(0:(p - 1) * 2, each = p * 2), 
                  i)] <- rep(Q[, , i], each = 2)
            } else Qm[cbind(rep(1:(p * 2), p), rep(1:2, p^2) + rep(0:(p - 1) * 2, each = p * 2), 1)] <- rep(Q, each = 2)
        } else {
            if (length(Q) != 1 && (!identical(dim(Q)[1], dim(Q)[2]) || isTRUE(dim(Q)[1] != 1) || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% 
                c(1, n)))) 
                stop("Misspecified Q, argument Q must be a scalar, (1 x 1) matrix, or (1 x 1 x 1)/(1 x 1 x n) array.")
            tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
            Qm <- array(0, c(m, m, tvq * (n - 1) + 1))
            if (tvq) {
              for (i in 1:(tvq * (n - 1) + 1)) 
                Qm[cbind(1:2, 1:2, i)] <- rep(Q[1, 1, i], 2)
            } else Qm[cbind(1:2, 1:2, 1)] <- rep(Q, 2)
                        
        }
        
        
        k <- dim(Qm)[1]
        R <- diag(k)
    }
    
    
    list(index = index, m = m, k = k, Z = Z, T = T, R = R, Q = Qm, a1 = a1, P1 = P1, P1inf = P1inf, tvq = tvq, tvr = 0, tvz = 0, 
        state_names = state_names, period = period)
} 
####$$$$ KFAS\R/SSModel.R
#' Create a State Space Model Object of Class SSModel
#'
#' Function \code{SSModel} creates a state space object object of class \code{SSModel}
#' which can be used as an input object for various functions of \code{KFAS} package.
#' 
#' Formula of the model can contain the usual regression part 
#' and additional functions defining different types of components of the model, named as
#' \code{SSMarima}, \code{SSMcustom}, \code{SSMcycle}, \code{SSMregression}, \code{SSMseasonal} and \code{SSMtrend}. 
#' 
#' 
#'
#' @export
#' @rdname SSModel
#' @name SSModel
#' @seealso \code{\link{KFAS}} for examples.
#' @param formula an object of class \code{\link{formula}} containing the symbolic description of the model. 
#' The intercept term can be removed with \code{-1} as in \code{lm}. 
#' In case of trend or differenced arima component intercept is removed automatically. 
#' Note that in order to be compatible with nonstationary elements, first level of each factor is 
#' always added to intercept, so if intercept is removed via \code{-1}, one level will be missing.
#' See details and examples in \code{\link{KFAS}} for special functions used in model construction.
#' @param data an optional data frame, list or environment containing the variables in the model.
#' @param H covariance matrix or array of disturbance terms \eqn{\epsilon_t}{\epsilon[t]} of observation equation. Omitted in case of non-gaussian distributions. Augment the state vector if you want to add additional noise.
#' @param u additional parameters for non-gaussian models. See details in \code{\link{KFAS}}.
#' @param distribution a vector of distributions of the observations. Default is \code{rep('gaussian',p)}.
#' @param tol a tolerance parameter for a diffuse phase. Smallest value of Finf not counted for zero.
#'  Defaults to \code{.Machine$double.eps^0.5}. 
#'  If smoothing gives negative variances for smoothed states, try adjusting this.
#' 
#' @param index a vector indicating for which series the corresponding components are constructed.
#' @param type for cycle, seasonal, trend and regression components, character string defining if \code{'distinct'} or \code{'common'} states are used for different series.
#' 
#' @param Q for arima, cycle and seasonal component, a \eqn{p \times p}{p x p} covariance matrix of the disturbances (or in the time varying case \eqn{p \times p \times n}{p x p x n} array), where where p=\code{length(index)}.
#'  For trend component, list of length \code{degree} containing the \eqn{p \times p} or \eqn{p \times p \times n} covariance matrices. For a custom component, arbitrary covariance matrix or array of disturbance terms \eqn{\eta_t}{\eta[t]}
#' @param a1 optional \eqn{m \times 1}{m x 1} matrix giving the expected value of the initial state vector \eqn{\alpha_1}{\alpha[1]}.
#' @param P1 optional \eqn{m \times m}{m x m} matrix giving the covariance matrix of \eqn{\alpha_1}{\alpha[1]}.  In the diffuse case the non-diffuse part of \eqn{P_1}{P[1]}.
#' @param P1inf optional \eqn{m \times m}{m x m} matrix giving the diffuse part of \eqn{P_1}{P[1]}. Diagonal matrix with ones on diagonal elements which correspond to the unknown initial states.
#' @param R for a custom and regression components, optional \eqn{m \times k} system matrix or array of transition equation.
#' @param ar for arima component, a numeric vector containing the autoregressive coeffients.
#' @param ma for arima component, a numericvector containing the moving average coeffients. 
#' @param d for arima component, a degree of differencing.  
#' @param stationary for arima component, logical value indicating whether a stationarity of the arima part is assumed. Defaults to TRUE. 
#' @param Z for a custom component, system matrix or array of observation equation.
#' @param T for a custom component, system matrix or array of transition equation.
#' @param period for a cycle and seasonal components, the length of the cycle/seasonal pattern.
#' @param sea.type for seasonal component, character string defining whether to use \code{'dummy'} or \code{'trigonometric'} form of the seasonal component.
#' @param degree for trend component, integer defining the degree of the polynomial trend. 1 corresponds to local level, 2 for local linear trend and so forth.
#' @param rformula for regression component, right hand side formula or list of of such formulas 
#' defining the custom regression part.
#' @param n length of the series, only used internally for dimensionality check.
#' @param ynames names of the times series, only used internally.
#' 
#' @return object of class \code{SSModel}, which is a list with the following components:
#' \item{y}{A n x p matrix containing the observations. }
#' \item{Z}{A p x m x 1 or p x m x n array corresponding to the system matrix of observation equation. }
#' \item{H}{A p x p x 1 or p x p x n array corresponding to the covariance matrix of observational disturbances epsilon. }
#' \item{T}{A m x m x 1 or m x m x n array corresponding to the first system matrix of state equation. }
#' \item{R}{A m x k x 1 or m x k x n array corresponding to the second system matrix of state equation. }
#' \item{Q}{A k x k x 1 or k x k x n array corresponding to the covariance matrix of state disturbances eta }
#' \item{a1}{A m x 1 matrix containing the expected values of the initial states. }
#' \item{P1}{A m x m matrix containing the covariance matrix of the nondiffuse part of the initial state vector. }
#' \item{P1inf}{A m x m matrix containing the covariance matrix of the diffuse part of the initial state vector. }
#' \item{u}{A n x p matrix of an additional parameters in case of non-Gaussian model.}
#' \item{distribution}{A vector of length p giving the distributions of the observations. }
#' \item{tol}{A tolerance parameter for the diffuse phase. }
#' \item{call}{Original call to the function. }
#' In addition, object of class \code{SSModel} contains following attributes:
#' \item{names}{Names of the list components. }
#' \item{p, m, k, n}{Integer valued scalars defining the dimensions of the model components. }
#' \item{state_types}{Types of the states in the model. } 
#' @examples
#' \dontrun{ 
#' examplemodel<-SSModel(cbind(y1,y2,y3)  ~ x1+x2 
#' + SSMregression(~-1+x3+x4,data=dataset,type='common',index=c(1,3),Q=diag(c(0.05,0.1)))                                   
#' + SSMtrend(degree=1,index=1,Q=list(matrix(0.2)))
#' + SSMtrend(degree=2,index=2:3,Q=list(matrix(c(0.2,0.1,0.1,0.2),2,2),diag(0.07,2)))
#' + SSMcycle(period=25,Q=matrix(c(0.3,0.2,0.1,0.2,0.4,0.05,0.1,0.05,0.1),3,3))            
#' , data=dataset, H=matrix(c(1,0.7,0.7,0.7,1,0.7,0.7,0.7,1),3,3))
#' }
SSModel <- function(formula, data, H, u, distribution, tol = .Machine$double.eps^0.5){
  
  # Modifying formula object, catching special functions
  
  mf <- mc <- match.call(expand.dots = FALSE)
  mf <- mf[c(1L, match(c("formula", "data"), names(mf), 0L))]
  mf[[1L]] <- as.name("model.frame")
  mf$na.action <- as.name("na.pass")
  
  components <- c("SSMregression", "SSMtrend", "SSMseasonal", "SSMcycle", "SSMarima", "SSMcustom")
  if (missing(data)){ 
    data <- environment(formula)
    tsp_data<-NULL
  } else tsp_data<-tsp(data)
  
  all_terms <- terms(formula, specials = components, data = data)  
  specials <- attr(all_terms, "specials")
  components <- components[!sapply(specials, is.null)]

#   errorterm <- attr(all_terms, "variables")[[1 + unlist(specials)]]
#   eTerm <- deparse(errorterm[[2L]], width.cutoff = 500L, 
#                    backtick = TRUE)
#   intercept <- attr(Terms, "intercept")
#   ecall <- lmcall
#   ecall$formula <- as.formula(paste(deparse(formula[[2L]], 
#                                             width.cutoff = 500L, backtick = TRUE), "~", eTerm, 
#                                     if (!intercept) 
#                                       "- 1"), env = environment(formula))
#   
  #browser()
  if (length(unlist(specials)) > 0) {
    if (length(attr(all_terms, "term.labels")) == length(unlist(specials))) 
      all_terms <- terms(update.formula(all_terms, . ~ . + .emptyx.), specials = components)
    drops<-which(attr(all_terms,"term.labels") %in%rownames(attr(all_terms,"factors")) [unlist(specials)]) 
    mf$formula <- formula(drop.terms(all_terms, drops, keep.response = TRUE))
    #mf$formula <- formula(drop.terms(all_terms, unlist(specials) - 1, keep.response = TRUE))
    mf$formula <- update.formula(mf$formula, . ~ . - .emptyx., simplify = TRUE)
  }
  
  if ("SSMtrend" %in% components || ("SSMarima" %in% components && isTRUE(eval(attr(all_terms, "variables")[[specials$SSMarima + 1]]$d,envir=parent.frame()) > 0))) {    
    mf$formula <- update.formula(mf$formula, . ~ . - 1)
    
  } #else remove_intercept<-FALSE
  mf <- eval(mf, parent.frame())
  y <- model.response(mf, "numeric")
  
  mt <- attr(mf, "terms")
  
  vars <- attr(all_terms, "variables")
  
  reg_in_formula <- as.integer(dim(model.matrix(mt, mf))[2] > 0)
  specials <- unlist(specials)
  lspecials <- length(specials)
  n_blocks <- lspecials + reg_in_formula
  blocks <- vector("list", n_blocks)
  
  # building y
  
  if (is.array(y)) {
    p <- dim(y)[2]
    n <- dim(y)[1]
  } else {
    y <- as.array(y)
    if (length(dim(y)) != 2) {
      p <- 1
      n <- length(y)
      dim(y) <- c(n, p)
    }
  }
  y_names <- colnames(y)
  if(is.null(y_names)){
    y_names <- if (p > 1){
      colnames(y)<-paste0("y", 1:p)
    } else ""
  }
  class(y)<-if(p>1) c("mts","ts","matrix") else "ts"
  
  if(is.null(tsp(y))){
    if(!is.null(tsp_data)){
    tsp(y)<-tsp_data       
    } else tsp(y)<-c(1,n,1)
  }
  
  
  # defining the distributions of y
  if (missing(distribution)) {
    distribution <- rep("gaussian", length = p)
  } else {
    if (length(distribution) == 1 | length(distribution) == p) {
      distribution <- rep(pmatch(x = distribution, table = c("gaussian", "poisson", "binomial", "gamma", "negative binomial"), 
                                 duplicates.ok = TRUE), length = p)
    } else stop("Length of the argument 'distribution' must be either 1 or p, the number of series.")
    if (any(is.na(distribution))) 
      stop("Misspeficied distribution, only 'gaussian', 'poisson', 'binomial', 'gamma', and 'negative binomial' are allowed.")
    distribution <- c("gaussian", "poisson", "binomial", "gamma", "negative binomial")[distribution]
  }
  
  # building H and u
  if (all(distribution == "gaussian")) {
    if (!missing(H)) {
      if (length(H) == 1) 
        dim(H) <- c(1, 1)
      dims <- dim(H)
      if (dims[1] != p || dims[2] != p) 
        stop("Misspecified H, argument H must be NULL, a scalar, p x p matrix or p x p x n array, where p is the number of time series.")
      H <- array(H, dim = c(p, p, 1 + (n - 1) * (max(dims[3], 0, na.rm = TRUE) > 1)))
    } else {
      H <- array(diag(p), dim = c(p, p, 1))
    }   
    u <- "Omitted"
  } else {
    if (!missing(H)) 
      warning("H ignored as model contains non-gaussian series.")
    H <- "Omitted"
    if (missing(u)) {
      u <- array(1, c(n, p))
    } else {
      if (is.data.frame(u)) {
        u <- data.matrix(u)
        if (!identical(dim(u), c(n, p))) 
          stop("Mispecified u, argument u must be either vector of length p, or n x p matrix, where p is the number of time series.")
      } else u <- matrix(u, n, p, byrow = is.vector(u))
      storage.mode(u) <- "double"
    }
    class(u)<-class(y)
    tsp(u)<-tsp(y)
  }
  
  
  # building model components by calling appropriate component functions
  
  if (reg_in_formula) {
    blocks[[1]] <- SSMregression(rformula = formula(delete.response(mt)), 
                                 data = mf, index = 1:p, n = n, ynames = if(p > 1) y_names)
    blocks[[1]]$state_types <- "regression"
  }  

  if (lspecials > 0) 
    for (i in 1:lspecials) {      
      comp <- vars[[1 + specials[i]]]    
      comp <- match.call(definition = eval(comp[[1]]), call = comp)      
      if (is.null(comp$index)) {
        comp$index <- 1:p
      } else if (!all(eval(comp$index) %in% (1:p))) 
        stop("Index must have values between 1 to p. ")
      comp$n <- n
      if (comp[[1]] != "SSMcustom" && p > 1 && is.null(comp$ynames) && (is.null(comp$type) || comp$type!='common')) 
        comp$ynames <- y_names[eval(comp$index)]
      
      blocks[[i + reg_in_formula]] <- eval(comp,envir=parent.frame())###
      blocks[[i + reg_in_formula]]$state_types <- substr(as.character(comp[[1]]),start=4,stop=15L)
    }
  
  
  # building combined model arrays
  
  cum_m <- c(0, cumsum(unlist(sapply(blocks, "[", "m"))))
  cum_k <- c(0, cumsum(unlist(sapply(blocks, "[", "k"))))
  m <- max(cum_m)
  k <- max(cum_k, 1)
  Z <- array(0, c(p, m, 1 + (n - 1) * max(0, unlist(sapply(blocks, "[", "tvz")))))
  T <- array(0, c(m, m, 1 + (n - 1) * max(0, unlist(sapply(blocks, "[", "tvt")))))
  R <- array(0, c(m, k, 1 + (n - 1) * max(0, unlist(sapply(blocks, "[", "tvr")))))
  Q <- array(0, c(k, k, 1 + (n - 1) * max(0, unlist(sapply(blocks, "[", "tvq")))))
  P1 <- P1inf <- matrix(0, m, m)
  a1 <- matrix(0, nrow = m)  
  
  state_names <- unname(unlist(sapply(blocks, "[", "state_names")))   
  rownames(a1) <- rownames(T) <- colnames(T) <- colnames(Z) <- rownames(R) <- rownames(P1) <- colnames(P1) <- rownames(P1inf) <- colnames(P1inf) <- state_names
  rownames(Z) <- colnames(y)
  
  state_types <- character(m)
  eta_types <- character(k)
  for (i in 1:n_blocks) {
    Z[blocks[[i]]$index, (cum_m[i] + 1):cum_m[i + 1], ] <- blocks[[i]]$Z
    T[(cum_m[i] + 1):cum_m[i + 1], (cum_m[i] + 1):cum_m[i + 1], ] <- blocks[[i]]$T
    R[(cum_m[i] + 1):cum_m[i + 1], seq_len(cum_k[i + 1] - cum_k[i]) + cum_k[i], ] <- blocks[[i]]$R
    Q[seq_len(cum_k[i + 1] - cum_k[i]) + cum_k[i], seq_len(cum_k[i + 1] - cum_k[i]) + cum_k[i], ] <- blocks[[i]]$Q
    a1[(cum_m[i] + 1):cum_m[i + 1], ] <- blocks[[i]]$a1
    P1[(cum_m[i] + 1):cum_m[i + 1], (cum_m[i] + 1):cum_m[i + 1]] <- blocks[[i]]$P1
    P1inf[(cum_m[i] + 1):cum_m[i + 1], (cum_m[i] + 1):cum_m[i + 1]] <- blocks[[i]]$P1inf
    state_types[(cum_m[i] + 1):cum_m[i + 1]] <- eta_types[seq_len(cum_k[i + 1] - cum_k[i]) + cum_k[i]] <- blocks[[i]]$state_types
    
  }
  if(all(dim(R)==c(1,1,1)) && R[1]==0)
    R[1]<-1
  
  model <- list(y = y, Z = Z, H = H, T = T, R = R, Q = Q, a1 = a1, P1 = P1, P1inf = P1inf, u = u, distribution = distribution, 
                tol = tol)
  
  class(model) <- "SSModel"
  attr(model, "p") <- as.integer(p)
  attr(model, "m") <- as.integer(m)
  attr(model, "k") <- as.integer(k)
  attr(model, "n") <- as.integer(n)
  attr(model, "state_types") <- state_types
  attr(model, "eta_types") <- eta_types
  model$call <- mc
  invisible(model)
} 
####$$$$ KFAS\R/SSMregression.R
#' @rdname SSModel
#' @export
SSMregression <- function(rformula, data, type, Q, index, R, a1, P1, P1inf,  n, ynames) {
  if (missing(index)) 
    index <- 1
  p <- length(index)
  if (!missing(ynames) && !is.null(ynames)){
    ynames <- paste0(".", ynames)
  } else ynames<-""
  
  if (missing(data)) 
  {
    data <- environment(rformula)
  }  #else data<-model.frame(data,na.action=na.pass)
  
  if (missing(type)) {
    type <- 1L
  } else {
    type <- pmatch(x = type, table = c("distinct", "common"))
    if (is.na(type)) 
      stop("type must be 'distinct' or 'common'.")
  }
  old_option<-getOption("na.action")
  options(na.action="na.pass")
  # case 1, input is formula
 
  if (inherits(rformula, "formula")) {
    #data<-cbind(data,".dummyresponse"=1)
    if(length(attr(terms(rformula,data=data),"term.labels"))==0 && attr(terms(rformula,data=data),"intercept")==1){
      X<-matrix(1,nrow=n,ncol=1)
      colnames(X)<-"(Intercept)"
    } else {
      if(attr(terms(rformula,data=data),"intercept")==0 && attr(terms(rformula,data=data),"factors")!=0){ #any(sapply(data,is.factor))
        rformula<-update.formula(rformula,~.+1)
        #data<-cbind(data,"(Intercept)"=1)
        X <- model.matrix(rformula, data = data)
        X<-X[,-(colnames(X)=="(Intercept)"),drop=FALSE]
      } else X <- model.matrix(rformula, data = data)
    }
    #if(remove_intercept && any(colnames(X)=="(Intercept)"))
    #  X<-X[,-(colnames(X)=="(Intercept)")]
    Xnames <- colnames(X)
    
    
    dims <- dim(X)
    if (missing(n)) {
      n <- dims[1]
    } else {
      if (n != dims[1]) 
        stop("Length of the series and covariates differ.")
    }
    if (any(is.na(X))) 
      warning("Missing covariate values.")
    
    m <- dims[2] + dims[2] * ((p - 1) * (type != 2))
    Z <- array(0, c(p, m, n))
    
    if (type == 2) {
      for (i in 1:m) Z[, i, ] <- rep(X[, i], each = p)            
    } else {
      for (i in 1:p) Z[i, ((i - 1) * dims[2] + 1):(i * dims[2]), ] <- t(X)
      
    }
    state_names <- paste0(rep(Xnames, times = (p-1)*(type==1)+1), rep(ynames, each = dims[2]))
  } else {
    
    if (length(rformula) != p) 
      stop("Length of the formula list is not equal to the number of series.")
    X <- vector("list", length = p)
    
    if(is.list(data) && !is.data.frame(data)){
      if (length(data) != p) 
        stop("Length of the data list is not equal to the number of series.")
      
      for (i in 1:p) {
        if(length(attr(terms(rformula[[i]],data=data[[i]]),"term.labels"))==0 && 
             attr(terms(rformula[[i]],data=data[[i]]),"intercept")==1){
          X[[i]]<-matrix(1,nrow=n,ncol=1)
          colnames(X[[i]])<-"(Intercept)"
        } else {
          if(attr(terms(rformula[[i]],data=data[[i]]),"intercept")==0 && 
               attr(terms(rformula[[i]],data=data[[i]]),"factors")!=0){
            rformula[[i]]<-update.formula(rformula[[i]],~.+1)
            data[[i]]<-cbind(data[[i]],"(Intercept)"=1)
            X[[i]] <- model.matrix(rformula[[i]], data = data[[i]])
            X[[i]]<-X[[i]][,-(colnames(X[[i]])=="(Intercept)"),drop=FALSE]
          } else X[[i]] <- model.matrix(rformula[[i]], data = data[[i]])            
        }
      }
    } else { 
      for (i in 1:p) {
        if(length(attr(terms(rformula[[i]],data=data),"term.labels"))==0 && 
             attr(terms(rformula[[i]],data=data),"intercept")==1){
          X[[i]]<-matrix(1,nrow=n,ncol=1)
          colnames(X[[i]])<-"(Intercept)"
        } else {
          if(attr(terms(rformula[[i]],data=data),"intercept")==0 && 
               attr(terms(rformula[[i]],data=data),"factors")!=0){
            rformula[[i]]<-update.formula(rformula[[i]],~.+1)
            data<-cbind(data,"(Intercept)"=1)
            X[[i]] <- model.matrix(rformula[[i]], data = data)
            X[[i]]<-X[[i]][,-(colnames(X[[i]])=="(Intercept)"),drop=FALSE]
          } else X[[i]] <- model.matrix(rformula[[i]], data = data)            
        }
      }
    }
    
    if (any(sapply(X, is.na))) 
      warning("Missing values in X.")
    
    dims <- sapply(X, dim)
    if (missing(n)) {
      n <- dims[1, 1]
    } else {
      if (any(dims[1, ] != n)) 
        stop("Length of the series and covariates differ.")
    }
    
    if (type == 2 & length(unique(dims[2, ])) > 1) 
      stop("Unequal number of covariates for different series.")
    
    if (type == 1) {
      m <- sum(dims[2, ])
      m_cumsum <- c(0, cumsum(dims[2, ]))
      Z <- array(0, dim = c(p, m, n))
      
      state_names <- NULL
      for (i in 1:p) {
        state_names<-c(state_names,paste0(colnames(X[[i]]),ynames[i]))
        Z[i, (m_cumsum[i] + 1):m_cumsum[i + 1], ] <- t(X[[i]])                
      }
      
    } else {
      
      dims <- dims[, 1]
      m <- dims[2]
      Z <- array(0, c(p, m, n))
      
      for (j in 1:p) {
        for (i in 1:dims[2]) {
          Z[j, i, ] <- X[[j]][, i]
        }
      }
      
      state_names <- colnames(X[[1]])#paste0(rep("beta",m),1:m)
    }
  }
  T <- diag(m)
  
  if (missing(a1)) {
    a1 <- matrix(0, m, 1)
  } else {
    if (length(a1) != m || any(dim(a1) != c(m, 1))) 
      stop("a1 must be a (m x 1) matrix where m is the number of states. ")
    a1 <- matrix(a1, m, 1)
  }
  if (missing(P1)) {
    P1 <- matrix(0, m, m)
  } else {
    if (length(P1) > 1 && any(dim(P1) != m)) 
      stop("P1 must be a (m x m) matrix where m is the number of states. ")
    P1 <- matrix(P1, m, m)
  }
  if (missing(P1inf)) {
    P1inf <- diag(m)
  } else {
    if (length(P1inf) > 1 && any(dim(P1inf) != m)) 
      stop("P1inf must be a (m x m) diagonal matrix where m is the number of states. ")
    P1inf <- matrix(P1inf, m, m)
  }
  diag(P1inf)[diag(P1) > 0 || is.na(diag(P1))] <- 0
  a1[diag(P1inf) > 0] <- 0
  
  if (missing(Q)) {
    k <- 0
    Q <- NULL
    tvq <- 0
  } else {
    if (length(Q) == 1) 
      Q <- matrix(Q)
    if (!identical(dim(Q)[1], dim(Q)[2]) || isTRUE(dim(Q)[1] > m) || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% c(1, n))) 
      stop("Misspecified Q, argument Q must be (k x k) matrix, (k x k x 1), or (k x k x n) array where m is the number of disturbance terms.")
    k <- dim(Q)[1]
    tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
  }
  if (missing(R)) {
    tvr <- 0
    if (k > 0) {
      R <- diag(m)[, 1:k, drop = FALSE]
    } else R <- NULL
  } else {
    if (isTRUE(!(dim(R)[1]==m)) || isTRUE(dim(R)[2] != k) || !(max(dim(R)[3], 1, na.rm = TRUE) %in% c(1, n))) 
      stop("Misspecified R, argument R must be (m x k) matrix, (m x k x 1), or (m x k x n) array where m is the number of states and k is the number of disturbance terms.")
    tvr <- max(dim(R)[3] == n, 0, na.rm = TRUE)
  }
  options(na.action=old_option)
  list(index = index, m = m, k = k, Z = Z, T = T, R = R, Q = Q, a1 = a1, P1 = P1, P1inf = P1inf, tvq = tvq, tvr = tvr, tvz = 1, 
       state_names = state_names)
  
} 
####$$$$ KFAS\R/SSMseasonal.R
#' @rdname SSModel
#' @export
SSMseasonal <- function(period, sea.type = c("dummy", "trigonometric"), type, Q, index, a1, 
                        P1, P1inf,  n, ynames) {
  if (missing(index)) 
    index <- 1
  p <- length(index)
  if (!missing(ynames) && !is.null(ynames)){
    ynames <- paste0(".", ynames)
  } else ynames<-""
  if (missing(type)) {
    type <- 1L
  } else {
    type <- pmatch(x = type, table = c("distinct", "common"))
    if (is.na(type)) 
      stop("type must be 'distinct' or 'common'.")
  }
  sea.type <- match.arg(arg = sea.type)
  
  if (!(length(period) == 1 & period > 1)) 
    stop("Period of the seasonal component must be larger than 1.")
  period <- floor(period)
  m1 <- period - 1
  
  Z_univariate <- matrix(0, 1, m1)
  T_univariate <- matrix(0, m1, m1)
  
  if (sea.type == "dummy") {
    Z_univariate[1, 1] <- 1        
    state_names <- paste0(rep(paste0("sea_dummy", 1:(period - 1)), each=1), rep(ynames, each = period - 1))        
    T_univariate[1, ] <- -1
    T_univariate[cbind(2:m1, 1:(m1 - 1))] <- 1
    
  } else {
    Z_univariate[1, ] <- rep(c(1, 0), length.out = period - 1)
    
    state_names <- paste0(rep(c("sea_trig", "sea_trig*"), each = 1, length.out = (period - 1)), 
                          rep(1:floor(period/2), each = 2, length.out = (period - 1)), 
                          rep(ynames, each = period - 1))
    
    lambda <- 2 * pi * 1:floor((period - 1)/2)/period
    T_univariate[cbind(1:m1, 1:m1)] <- rep(c(cos(lambda), -1), each = 2, length = m1)
    T_univariate[which((col(T_univariate)-row(T_univariate))==1)[seq(from=1,by=2,length=length(lambda))]] <- sin(lambda)
    T_univariate[which((col(T_univariate)-row(T_univariate))==-1)[seq(from=1,by=2,length=length(lambda))]] <- -sin(lambda)
  }
  m <- ((p - 1) * (type != 2) + 1) * (period - 1)
  # k <- ((p-1)*(type != 2)+1)*((sea.type=='dummy') + (sea.type=='trigonometric')*(period - 1))
  
  T <- matrix(0, m, m)
  Z <- matrix(0, p, m)
  if (type != 2) {
    for (i in 1:p) {
      Z[i, ((i - 1) * m1 + 1):(i * m1)] <- Z_univariate
      T[((i - 1) * m1 + 1):(i * m1), ((i - 1) * m1 + 1):(i * m1)] <- T_univariate
    }
  } else {
    Z <- matrix(Z_univariate, nrow = p, ncol = m, byrow = TRUE)
    T <- T_univariate
  }
  if (missing(a1)) {
    a1 <- matrix(0, m, 1)
  } else {
    if (length(a1) != m || any(dim(a1) != c(m, 1))) 
      stop("a1 must be a (m x 1) matrix where m is the number of states. ")
    a1 <- matrix(a1, m, 1)
  }
  if (missing(P1)) {
    P1 <- matrix(0, m, m)
  } else {
    if (length(P1) > 1 && any(dim(P1) != m)) 
      stop("P1 must be a (m x m) matrix where m is the number of states. ")
    P1 <- matrix(P1, m, m)
  }
  if (missing(P1inf)) {
    P1inf <- diag(m)
  } else {
    if (length(P1inf) > 1 && any(dim(P1inf) != m)) 
      stop("P1inf must be a (m x m) diagonal matrix where m is the number of states. ")
    P1inf <- matrix(P1inf, m, m)
  }
  diag(P1inf)[diag(P1) > 0 || is.na(diag(P1))] <- 0
  a1[diag(P1inf) > 0] <- 0
  
  if (missing(Q)) {
    k <- 0
    Qm <- R <- NULL
    tvq <- 0
  } else {
    if (sea.type == "dummy") {
      if (type == 1) {
        if (length(Q) != 1 && (!identical(dim(Q)[1], dim(Q)[2]) || dim(Q)[1] != p || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% 
                                                                                         c(1, n)))) 
          stop("Misspecified Q, argument Q must be (p x p) matrix, (p x p x 1), or (p x p x n) array where m is the number of time series.")
        
        tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
        
        Qm <- array(Q, c(p, p, tvq * (n - 1) + 1))
        k <- p
        R <- matrix(0, m, k)
        R[cbind(seq(1, by = k, length = k), 1:k)] <- 1
      } else {
        if (length(Q) != 1 && (!identical(dim(Q)[1], dim(Q)[2]) || dim(Q)[1] != 1 || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% 
                                                                                         c(1, n)))) 
          stop("Misspecified Q, argument Q must be a scalar, (1 x 1) matrix, or (1 x 1 x 1)/(1 x 1 x n) array.")
        tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
        Qm <- array(Q, c(1, 1, tvq * (n - 1) + 1))
        k <- 1
        R <- diag(m)[, 1, drop = FALSE]
        
      }
      
      # 
    } else {
      if (type == 1) {
        if (length(Q) != 1 && (!identical(dim(Q)[1], dim(Q)[2]) || dim(Q)[1] != p || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% 
                                                                                         c(1, n)))) 
          stop("Misspecified Q, argument Q must be (p x p) matrix, (p x p x 1), or (p x p x n) array where m is the number of time series.")
        
        tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
        
        Qm <- array(0, c(m, m, tvq * (n - 1) + 1))
        if (tvq == 1) {
          for (i in 1:(tvq * (n - 1) + 1)) Qm[cbind(rep(1:(p * (period - 1)), p), rep(1:(period - 1), p^2) + rep(0:(p - 
                                                                                                                      1) * (period - 1), each = p * (period - 1)), i)] <- rep(Q[, , i], each = (period - 1))
        } else Qm[cbind(rep(1:(p * (period - 1)), p), rep(1:(period - 1), p^2) + rep(0:(p - 1) * (period - 1), each = p * 
                                                                                       (period - 1)), 1)] <- rep(Q, each = (period - 1))
      } else {
        if (length(Q) != 1 && (!identical(dim(Q)[1], dim(Q)[2]) || dim(Q)[1] != 1 || !(max(dim(Q)[3], 1, na.rm = TRUE) %in% 
                                                                                         c(1, n)))) 
          stop("Misspecified Q, argument Q must be a scalar, (1 x 1) matrix, or (1 x 1 x 1)/(1 x 1 x n) array.")
        tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
        Qm <- array(0, c(m, m, tvq * (n - 1) + 1))
        if (tvq == 1) {
          for (i in 1:(tvq * (n - 1) + 1)) Qm[cbind(1:(period - 1), 1:(period - 1), i)] <- Q[, , i]
        } else Qm[cbind(1:(period - 1), 1:(period - 1), 1)] <- Q
        
      }
      
      k <- dim(Qm)[1]
      R <- diag(k)
    }
  }
  
  
  
  list(index = index, m = m, k = k, Z = Z, T = T, R = R, Q = Qm, a1 = a1, P1 = P1, P1inf = P1inf, tvq = tvq, tvr = 0, tvz = 0, 
       state_names = state_names, period = period, sea.type = sea.type)
} 
####$$$$ KFAS\R/SSMtrend.R
#' @rdname SSModel
#' @export
SSMtrend <- function(degree = 1, type, Q, index, a1, P1, P1inf, n, ynames) {
    if (missing(index)) 
        index <- 1
    p <- length(index)
    if (!missing(ynames) && !is.null(ynames)){
      ynames <- paste0(".", ynames)
    } else ynames<-""
    if (missing(type)) {
        type <- 1L
    } else {
        type <- pmatch(x = type, table = c("distinct", "common"))
        if (is.na(type)) 
            stop("type must be 'distinct' or 'common'.")
    }
    if (!(length(degree) == 1 & degree > 0 & abs(degree - round(degree)) == 0)) 
        stop("Degree of the trend component must be positive integer. ")
    
    
    m <- ((p - 1) * (type == 1) + 1) * degree
    
    Z <- matrix(0, p, m)
    T <- matrix(0, m, m)
    
    if (type == 2) {
        Z[, 1] <- 1
        p <- 1
       # state_names <- switch(degree, `1` = "level", `2` = c("level", "slope"), paste0("trend", 1:degree))
    } else {
        for (i in 1:p) Z[i, (i - 1) * degree + 1] <- 1

    }
    state_names <- switch(degree, `1` = paste0("level", ynames), 
                          `2` = paste0(c("level", "slope"), rep(ynames, each = degree)), 
                          paste0("trend", rep(1:degree), rep(ynames, each = degree)))
    dxm <- 1 + 0:(m - 1) * (m + 1)
    T[dxm] <- 1
    if (degree > 1) 
        T[dxm[-m] + m] <- rep(c(rep(1, degree - 1), 0), length = m - 1)
    
    if (missing(a1)) {
        a1 <- matrix(0, m, 1)
    } else {
        if (length(a1) != m || any(dim(a1) != c(m, 1))) 
            stop("a1 must be a (m x 1) matrix where m is the number of states. ")
        a1 <- matrix(a1, m, 1)
    }
    if (missing(P1)) {
        P1 <- matrix(0, m, m)
    } else {
        if (length(P1) > 1 && any(dim(P1) != m)) 
            stop("P1 must be a (m x m) matrix where m is the number of states. ")
        P1 <- matrix(P1, m, m)
    }
    if (missing(P1inf)) {
        P1inf <- diag(m)
    } else {
        if (length(P1inf) > 1 && any(dim(P1inf) != m)) 
            stop("P1inf must be a (m x m) diagonal matrix where m is the number of states. ")
        P1inf <- matrix(P1inf, m, m)
    }
    diag(P1inf)[diag(P1) > 0 || is.na(diag(P1))] <- 0
    a1[diag(P1inf) > 0] <- 0
    
    if (missing(Q)) {
        k <- 0
        Qm <- R <- NULL
        tvq <- 0
    } else {
        
        if (type == 1) {
            if (!is.list(Q)){ 
              if(degree>1){
                stop("Q must be a list of length degree, which contains (p x p) matrices, (p x p x 1), or (p x p x n) arrays, where p is the number of series. ")
              } else Q<-list(Q)
            }
            tvq <- max(unlist(sapply(lapply(Q, dim), "[", 3)) > 1, 0, na.rm = TRUE)
            
            Qm <- array(0, c(m, m, tvq * (n - 1) + 1))
            if(!is.list(Q))
              stop("Q must be a list of length degree.")
            for (i in 1:degree) {
                if ((p>1 && length(Q[[i]]) == 1) || 
                      (p==1 && length(Q[[i]]) != 1) || (p>1 &&( dim(Q[[i]])[1:2] != p || !(max(1,dim(Q[[i]])[3],na.rm=TRUE) %in% c(1, n)))))
                  stop("Q must be a list of length degree, which contains (p x p) matrices, (p x p x 1), or (p x p x n) arrays, where p is the number of series. ")
                Qm[seq(from = i, by = degree, length = p), seq(from = i, by = degree, length = p), ] <- Q[[i]]
            }
            k <- dim(Qm)[1]
            R <- diag(k)
            
        } else {
            if (is.list(Q) || (length(Q) != degree && is.null(dim(Q))) || 
                  (any(dim(Q)[1:2] != degree) || !(max(1,dim(Q)[3],na.rm=TRUE) %in% c(1, n, NA))))
                stop("Misspecified Q, argument Q must be a vector of length d, (d x d) matrix, or (d x d x 1)/(d x d x n) array where d is the degree of the trend.")
            if (length(Q) == degree) 
                Q <- diag(drop(Q), degree)
            tvq <- max(dim(Q)[3] == n, 0, na.rm = TRUE)
            Qm <- Q
            k <- dim(Qm)[1]
            R <- diag(k)
            
        }
    }
    
    list(index = index, m = m, k = k, Z = Z, T = T, R = R, Q = Qm, a1 = a1, P1 = P1, P1inf = P1inf, tvq = tvq, tvr = 0, tvz = 0, 
        state_names = state_names)
    
} 
####$$$$ KFAS\R/subset.SSModel.R
#' @method subset<- SSModel
#' @S3method subset<- SSModel
#' @rdname Extract.SSModel
`subset<-.SSModel` <- function(x, element, states, etas, series, times, ..., value) {
    
    # is.SSModel(x,return.logical=FALSE)
    element <- match.arg(arg = element, choices = c("y", "Z", "H", "T", "R", "Q", "a1", "P1", "P1inf", "u"))
    
    if (!(element %in% c("y", "u", "Q"))) {
        if (missing(states)) {
            states <- 1:attr(x, "m")
        } else {
            if (is.numeric(states)) {
                states <- as.integer(states)
                if (min(states) < 1 | max(states) > attr(x, "m")) 
                  stop("Vector states should contain the indices or names of the states which are modified.")
            } else {
                states <- match.arg(arg = states, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% states) {
                  states <- 1:attr(x, "m")
                } else states <- which(attr(x, "state_types") %in% states)
            }
        }
    }
    if (element %in% c("R", "Q")) {
        if (missing(etas)) {
            etas <- 1:attr(x, "k")
        } else {
            if (is.numeric(etas)) {
                etas <- as.integer(etas)
                if (min(etas) < 1 | max(etas) > attr(x, "k")) 
                  stop("Vector etas should contain the indices or names of the etas which are modified.")
            } else {
                etas <- match.arg(arg = etas, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% etas) {
                  etas <- 1:attr(x, "k")
                } else etas <- which(attr(x, "eta_types") %in% etas)
            }
        }
    }
    if (element %in% c("y", "u", "Z")) {
        if (missing(series)) {
            series <- 1:attr(x, "p")
        } else if (!all(series %in% (1:attr(x, "p")))) 
            stop("Argument series must have values between 1 to p, where p is the number of time series in model. ")
    }
    
    if (missing(times)) {
        switch(element, y = , u = x[[element]][, series] <- value, Z = x[[element]][series, states, ] <- value, H = x[[element]][series, 
            series, ] <- value, T = x[[element]][states, states, ] <- value, R = x[[element]][states, etas, ] <- value, Q = x[[element]][etas, 
            etas, ] <- value, a1 = x[[element]][states, 1] <- value, P1 = x[[element]][states, states] <- value, P1inf = x[[element]][states, 
            states] <- value, )
        
    } else {
        switch(element, y = , u = x[[element]][times, series] <- value, Z = x[[element]][series, states, times] <- value, H = x[[element]][series, 
            series, times] <- value, T = x[[element]][states, states, times] <- value, R = x[[element]][states, etas, times] <- value, 
            Q = x[[element]][etas, etas, times] <- value, a1 = x[[element]][states, 1] <- value, P1 = x[[element]][states, states] <- value, 
            P1inf = x[[element]][states, states] <- value, )
    }
    
    x
}
#' @rdname Extract.SSModel
#' @export
`subset<-` <- function(x, ..., value) UseMethod("subset<-")

#' @method subset SSModel
#' @S3method subset SSModel
#' @rdname Extract.SSModel
#' @param ... ignored.
subset.SSModel <- function(x, element, states, etas, series, times, ...) {
    
    # is.SSModel(x,return.logical=FALSE)
    element <- match.arg(arg = element, choices = c("y", "Z", "H", "T", "R", "Q", "a1", "P1", "P1inf", "u"))
    
    if (!(element %in% c("y", "u", "Q"))) {
        if (missing(states)) {
            states <- 1:attr(x, "m")
        } else {
            if (is.numeric(states)) {
                states <- as.integer(states)
                if (min(states) < 1 | max(states) > attr(x, "m")) 
                  stop("Vector states should contain the indices or types of the states which are modified.")
            } else {
                states <- match.arg(arg = states, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% states) {
                  states <- 1:attr(x, "m")
                } else states <- which(attr(x, "state_types") %in% states)
            }
        }
    }
    if (element %in% c("R", "Q")) {
        if (missing(etas)) {
            etas <- 1:attr(x, "k")
        } else {
            if (is.numeric(etas)) {
                etas <- as.integer(etas)
                if (min(etas) < 1 | max(etas) > attr(x, "k")) 
                  stop("Vector etas should contain the indices or types of the etas which are modified.")
            } else {
                etas <- match.arg(arg = etas, choices = c("all", "arima", "custom", "cycle", "seasonal", "trend", "regression"), 
                  several.ok = TRUE)
                if ("all" %in% etas) {
                  etas <- 1:attr(x, "k")
                } else etas <- which(attr(x, "eta_types") %in% etas)
            }
        }
    }
    if (element %in% c("y", "u", "Z")) {
        if (missing(series)) {
            series <- 1:attr(x, "p")
        } else if (!all(series %in% (1:attr(x, "p")))) 
            stop("Argument series must have values between 1 to p, where p is the number of time series in model. ")
    }
    
    if (missing(times)) {
        switch(element, y = , u = x[[element]][, series,drop=FALSE], Z = x[[element]][series, states, ,drop=FALSE], H = x[[element]][series, series,,drop=FALSE 
            ], T = x[[element]][states, states, ,drop=FALSE], R = x[[element]][states, etas,,drop=FALSE ], Q = x[[element]][etas, etas, ,drop=FALSE], a1 = x[[element]][states, 
            1,drop=FALSE], P1 = x[[element]][states, states,drop=FALSE], P1inf = x[[element]][states, states,drop=FALSE], )
        
    } else {
        switch(element, y = , u = x[[element]][times, series,drop=FALSE], Z = x[[element]][series, states, times,drop=FALSE], H = x[[element]][series, 
            series, times,drop=FALSE], T = x[[element]][states, states, times,drop=FALSE], R = x[[element]][states, etas, times,drop=FALSE], Q = x[[element]][etas, 
            etas, times,drop=FALSE], a1 = x[[element]][states, 1,drop=FALSE], P1 = x[[element]][states, states,drop=FALSE], P1inf = x[[element]][states, states,drop=FALSE], 
            )
    }
    
} 
####$$$$ KFAS\R/transformSSM.R
#' Transform the SSModel object with multivariate observations
#'
#' Function transform.SSModel transforms original model by LDL decomposition or state vector augmentation,
#'
#' @details As all the functions in KFAS use univariate approach, \eqn{H_t}{H[t]}, a covariance matrix of
#' an observation equation needs to be either diagonal or zero matrix. Function transformSSM performs
#' either the LDL decomposition of the covariance matrix of the observation equation, or augments the state vector with
#' the disturbances of the observation equation.
#'
#' In case of a LDL decomposition, the new \eqn{H_t}{H[t]} contains the diagonal part of the decomposition,
#' whereas observations \eqn{y_t}{Z[t]} and system matrices \eqn{Z_t}{Z[t]} are multiplied with the inverse of \eqn{L_t}{L[t]}.
#'
#'
#' @export
#' @param object State space model object from function SSModel.
#' @param type Option \code{'ldl'} performs LDL decomposition for covariance
#' matrix \eqn{H_t}{H[t]}, and multiplies the observation equation with the \eqn{L_t^{-1}}{L[t]^-1}, so
#' \eqn{\epsilon_t^* \sim N(0,D_t)}{\epsilon[t]* ~ N(0,D[t])}. Option \code{'augment'} adds \eqn{\epsilon_t}{\epsilon[t]} to the state vector, when
#' \eqn{Q_t}{Q[t]} becomes block diagonal with blocks \eqn{Q_t}{Q[t]} and \eqn{H_t}{H[t]}.
#' @return \item{model}{Transformed model.}
transformSSM <- function(object, type = c("ldl", "augment")) {
    if (any(object$distribution != "gaussian")) 
        stop("Nothing to transform as matrix H is not defined for non-gaussian model.")
    
    is.SSModel(object, return.logical = FALSE)
    
    type <- match.arg(type, choices = c("ldl", "augment"))
    
    p <- attr(object, "p")
    n <- attr(object, "n")
    m <- attr(object, "m")
    r <- attr(object, "k")
    
    tv <- array(0, dim = 5)
    tv[1] <- dim(object$Z)[3] > 1
    tv[2] <- tvh <- dim(object$H)[3] > 1
    tv[3] <- dim(object$T)[3] > 1
    tv[4] <- dim(object$R)[3] > 1
    tv[5] <- dim(object$Q)[3] > 1
    
    
    
    if (type == "ldl") {
        if (p > 1) {
            yt <- t(object$y)
            ymiss <- is.na(yt)
            tv[1] <- max(tv[1], tv[2])
            if (sum(ymiss) > 0) {
                positions <- unique(ymiss, MARGIN = 2)
                nh <- dim(positions)[2]
                tv[1:2] <- 1
                Z <- array(object$Z, dim = c(p, m, n))
            } else {
                Z <- array(object$Z, dim = c(p, m, (n - 1) * tv[1] + 1))
                positions <- rep(FALSE, p)
                nh <- 1
            }
            positions <- as.matrix(positions)
            H <- array(object$H, c(p, p, n))
            if (tvh) {
                nh <- n
                hchol <- 1:n
                uniqs <- 1:n
            } else {
                hchol <- rep(0, n)
                uniqs <- numeric(nh)
                for (i in 1:nh) {
                  nhn <- which(colSums(ymiss == positions[, i]) == p)
                  hchol[nhn] <- i
                  uniqs[i] <- nhn[1]  #which(hchol==i)[1]
                }
            }
            
            ichols <- H[, , uniqs, drop = FALSE]  #array(p,p,nh) #.Fortran('ldlinv2', PACKAGE = 'KFAS', NAOK = TRUE, H=H[,,uniqs],p,as.integer(ydimt[uniqs]),nh)$H
            
            ydims <- as.integer(colSums(!ymiss))
            yobs <- array(1:p, c(p, n))
            if (sum(ymiss) > 0) 
                for (i in 1:n) {
                  if (ydims[i] != p && ydims[i] != 0) 
                    yobs[1:ydims[i], i] <- yobs[!ymiss[, i], i]
                  if (ydims[i] < p) 
                    yobs[(ydims[i] + 1):p, i] <- NA
                }
            
            
            unidim <- ydims[uniqs]
            hobs <- yobs[, uniqs, drop = FALSE]
            storage.mode(yobs) <- storage.mode(hobs) <- storage.mode(hchol) <- "integer"
            out <- .Fortran(fldlssm, NAOK = TRUE, yt = yt, ydims = ydims, yobs = yobs, tv = as.integer(tv), Zt = Z, p = as.integer(p), m = as.integer(m), 
                n = as.integer(n), ichols = ichols, nh = as.integer(nh), hchol = hchol, unidim = as.integer(unidim), info = as.integer(0), 
                hobs = hobs, tol = max(abs(apply(object$H,3,diag))) * .Machine$double.eps)
            if (out$info == -1) 
                stop("Error in diagonalization of H. Matrix is not positive semidefinite.")
            
            H <- array(0, c(p, p, ((n - 1) * tv[2] + 1)))
            for (t in 1:((n - 1) * tv[2] + 1)) diag(H[, , t]) <- diag(out$ichols[, , out$hchol[t]])
            attry <- attributes(object$y)
            object$y <- t(out$yt)
            attributes(object$y) <- attry
            object$Z <- out$Z
            object$H <- H
        }
    } else {
        T <- array(object$T, dim = c(m, m, (n - 1) * tv[3] + 1))
        R <- array(object$R, dim = c(m, r, (n - 1) * tv[4] + 1))
        Q <- array(object$Q, dim = c(r, r, (n - 1) * tv[5] + 1))
        H <- array(object$H, c(p, p, (n - 1) * tv[2] + 1))
        Z <- array(object$Z, dim = c(p, m, (n - 1) * tv[1] + 1))
        
        r2 <- r + p
        m2 <- m + p
        tv[5] <- max(tv[c(2, 5)])
        Qt2 <- array(0, c(r2, r2, 1 + (n - 1) * tv[5]))
        Qt2[1:r, 1:r, ] <- Q
        if (tv[2]) {
            Qt2[(r + 1):r2, (r + 1):r2, -n] <- H[, , -1]
        } else Qt2[(r + 1):r2, (r + 1):r2, ] <- H
        Zt2 <- array(0, c(p, m2, (n - 1) * tv[1] + 1))
        Zt2[1:p, 1:m, ] <- Z
        Zt2[1:p, (m + 1):m2, ] <- diag(p)
        Tt2 <- array(0, c(m2, m2, (n - 1) * tv[3] + 1))
        Tt2[1:m, 1:m, ] <- T
        Rt2 <- array(0, c(m2, r + p, (n - 1) * tv[4] + 1))
        Rt2[1:m, 1:r, ] <- R
        Rt2[(m + 1):m2, (r + 1):r2, ] <- diag(p)
        P12 <- P1inf2 <- matrix(0, m2, m2)
        P12[1:m, 1:m] <- object$P1
        P1inf2[1:m, 1:m] <- object$P1inf
        P12[(m + 1):m2, (m + 1):m2] <- H[, , 1]
        a12 <- matrix(0, m2, 1)
        a12[1:m, ] <- object$a1
        object$Z <- Zt2
        object$H <- array(0, c(p, p, 1))
        
        object$T <- Tt2
        object$R <- Rt2
        object$Q <- Qt2
        attr(object, "m") <- m2
        attr(object, "k") <- r2
        if (attr(object, "p") == 1) {
            rownames(a12) <- c(rownames(object$a1), "eps")
        } else {
            rownames(a12) <- c(rownames(object$a1), paste0(rep("eps.", attr(object, "p")), 1:attr(object, "p")))
        }
        object$a1 <- a12
        object$P1 <- P12
        object$P1inf <- P1inf2
        
    }
    
    invisible(object)
} 
####$$$$ KFAS\src/approx.f95
! Subroutine for computation of the approximating gaussian model for non-gaussian models

subroutine approx(yt, ymiss, timevar, zt, tt, rtv, ht, qt, a1, p1,p1inf, p,n,m,r,&
theta, u, ytilde, dist,maxiter,tol,rankp,convtol,diff)

    implicit none

    integer, intent(in) ::  p,m, r, n
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    integer, intent(in), dimension(p) :: dist
    integer, intent(inout) :: maxiter,rankp
    integer ::  j,i, k,rankp2,tv
    double precision, intent(in) :: tol,convtol
    double precision, intent(in), dimension(n,p) :: u
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(inout), dimension(n,p) :: theta
    double precision, intent(inout), dimension(n,p) :: ytilde
    double precision, intent(inout), dimension(p,p,n) :: ht
    double precision, intent(inout) :: diff
    double precision, dimension(m,r) :: mr
    double precision, dimension(m,m,(n-1)*max(timevar(4),timevar(5))+1) :: rqr
    double precision dev, devold
    double precision, dimension(n,p) :: muhat
    double precision, external :: ddot


    !compute rqr
    tv = max(timevar(4),timevar(5))
    do i=1, (n-1)*tv+1
        call dgemm('n','n',m,r,r,1.0d0,rtv(:,:,(i-1)*timevar(4)+1),m,&
        qt(:,:,(i-1)*timevar(5)+1),r,0.0d0,mr,m)
        call dgemm('n','t',m,m,r,1.0d0,mr,m,rtv(:,:,(i-1)*timevar(4)+1),m,0.0d0,rqr(:,:,i),m)
    end do

    diff = 1000.0d0
    k=0


    do j=1,p
        select case(dist(j))
            case(1)
                do i=1,n
                    if(ymiss(i,j).EQ.0) then
                        ht(j,j,i) =  u(i,j)
                        ytilde(i,j) =  yt(i,j)
                    end if
                end do
            case(2)
                do i=1,n
                    if(ymiss(i,j).EQ.0) then
                        ht(j,j,i) =  1.0d0/(exp(theta(i,j))*u(i,j))
                        ytilde(i,j) =  yt(i,j)*ht(j,j,i) + theta(i,j) - 1.0d0
                    end if
                end do
            case(3)
                do i=1,n
                    if(ymiss(i,j).EQ.0) then
                        ht(j,j,i) = (1.0d0+exp(theta(i,j)))**2/(u(i,j)*exp(theta(i,j)))
                        ytilde(i,j) = theta(i,j) + ht(j,j,i)*yt(i,j) - 1.0d0 - exp(theta(i,j))
                    end if
                end do
            case(4)
                do i=1,n
                    if(ymiss(i,j).EQ.0) then
                        ht(j,j,i) =1.0d0/u(i,j)
                        ytilde(i,j) = theta(i,j)+yt(i,j)/exp(theta(i,j))-1.0d0
                    end if
                end do
            case(5)
                do i=1,n
                    if(ymiss(i,j).EQ.0) then
                        ht(j,j,i) = (1.0d0/u(i,j)+1.0d0/exp(theta(i,j)))
                        ytilde(i,j) = theta(i,j)+yt(i,j)/exp(theta(i,j))-1.0d0
                    end if
                end do
        end select
    end do


    muhat = theta
    call mu(dist,u,n,p,muhat)
    call deviance(yt,muhat,u,ymiss,n,p,dist,devold)

    do while(diff > convtol .AND. k < maxiter)

        k=k+1
        rankp2 = rankp

        call kfstheta(ytilde, ymiss, timevar, zt, ht,tt, rtv,qt,rqr, a1, p1, p1inf, &
        p, n, m, r,tol,rankp2,theta)

        do j=1,p
            select case(dist(j))
                case(2)
                    do i=1,n
                        if(ymiss(i,j).EQ.0) then
                            ht(j,j,i) =  1.0d0/(exp(theta(i,j))*u(i,j))
                            ytilde(i,j) =  yt(i,j)*ht(j,j,i) + theta(i,j) - 1.0d0
                        end if
                    end do
                case(3)
                    do i=1,n
                        if(ymiss(i,j).EQ.0) then
                            ht(j,j,i) = (1.0d0+exp(theta(i,j)))**2/(u(i,j)*exp(theta(i,j)))
                            ytilde(i,j) = theta(i,j) + ht(j,j,i)*yt(i,j) - 1.0d0 - exp(theta(i,j))
                        end if
                    end do
                case(4)
                    do i=1,n
                        if(ymiss(i,j).EQ.0) then
                            ytilde(i,j) = theta(i,j)+yt(i,j)/exp(theta(i,j))-1.0d0
                        end if
                    end do
                case(5)
                    do i=1,n
                        if(ymiss(i,j).EQ.0) then
                            ht(j,j,i) = (1.0d0/u(i,j)+1.0d0/exp(theta(i,j)))
                            ytilde(i,j) = theta(i,j)+yt(i,j)/exp(theta(i,j))-1.0d0
                        end if
                    end do
            end select
        end do
        muhat = theta
        call mu(dist,u,n,p,muhat)
        call deviance(yt,muhat,u,ymiss,n,p,dist,dev)
        diff = abs(dev - devold)/(0.1d0 + abs(dev))
        devold=dev
    end do
    maxiter=k

end subroutine approx
####$$$$ KFAS\src/artransform.f95
subroutine artransform(u,phi,p)
    implicit none
 
    integer, intent(in) :: p   
    integer :: i, j
    double precision, intent(inout), dimension(p) :: u
    double precision, intent(inout), dimension(p,p) :: phi

    do i= 2, p
        do j= 1, i-1
           phi(i,j) = phi(i-1,j) - u(i)*phi(i-1,i-j)
        end do
    end do
    
end subroutine artransform####$$$$ KFAS\src/covmeanw.f95
! Subroutines for mean, covariance and variance computation from weighted sample

subroutine covmeanw(x,w,m,n,k,meanx,covx)

    implicit none
    integer, intent(in) :: m, n, k
    integer :: t,i
    double precision, intent(inout), dimension(m,n,k) :: x
    double precision, intent(in), dimension(k) :: w
    double precision, intent(inout), dimension(m,n) :: meanx
    double precision, intent(inout), dimension(m,m,n) :: covx


    do i = 1, k
        meanx = meanx + x(:,:,i)*w(i)
    end do
    do i = 1, k
        x(:,:,i) = sqrt(w(i))*(x(:,:,i) - meanx)
    end do

    do t = 1, n
        call dgemm('n','t',m,m,k,1.0d0,x(:,t,:),m,x(:,t,:),m,0.0d0,covx(:,:,t),m)
    end do

end subroutine covmeanw

subroutine covmeanwprotect(x,w,m,n,k,meanx,covx)

    implicit none
    integer, intent(in) :: m, n, k
    integer :: t,i
    double precision, intent(inout), dimension(m,n,k) :: x
    double precision, intent(in), dimension(k) :: w
    double precision, intent(inout), dimension(m,n) :: meanx
    double precision, intent(inout), dimension(m,m,n) :: covx

    double precision, dimension(m,n,k) :: x2

    x2 = x
    do i = 1, k
        meanx = meanx + x2(:,:,i)*w(i)
    end do
    do i = 1, k
        x2(:,:,i) = sqrt(w(i))*(x2(:,:,i) - meanx)
    end do

    do t = 1, n
        call dgemm('n','t',m,m,k,1.0d0,x2(:,t,:),m,x2(:,t,:),m,0.0d0,covx(:,:,t),m)
    end do

end subroutine covmeanwprotect

subroutine varmeanw(x,w,m,n,k,meanx,varx,var)

    implicit none
    integer, intent(in) :: m, n, k,var
    integer :: t,i
    double precision, intent(inout), dimension(n,m,k) :: x
    double precision, intent(in), dimension(k) :: w
    double precision, intent(inout), dimension(n,m) :: meanx
    double precision, intent(inout), dimension(n,m) :: varx


    do i = 1, k
        meanx = meanx + x(:,:,i)*w(i)
    end do
    if(var==1) then
    do i = 1, m
        do t = 1, n
            varx(t,i) = sum(w*x(t,i,:)**2)-meanx(t,i)**2
        end do
    end do
end if
end subroutine varmeanw
####$$$$ KFAS\src/declarations.h
void F77_NAME(ldl)(double *a, int *n, double *tol, int *info);
void F77_NAME(ldlssm)(double *yt, int *ydimt, int *yobs, int *timevar, double *zt, int *p, int *m, int *n, double *ichols,int *nh,int *hchol,int *dim,int *info, int *hobs,double *tol);
void F77_NAME(signaltheta)(int *tvz, double *zt, double *ahat, double *vt, int *p, int *n, int *m, double *theta, double *thetavar,int *d,int *states,int *m2);
void F77_NAME(approx)(double *yt, int *ymiss, int *timevar, double *zt, double *tt, double *rtv, double *ht, double *qt, double *a1, double *p1,double *p1inf, int *p,int *n,int *m,int *r, double *theta, double *u, double *ytilde, int *dist,int *maxiter,double *tol,int *rankp,double *convtol, double *diff);
void F77_NAME(gsmoothall)(int *ymiss, int *timevar, double *zt, double *ht,double *tt, double *rtv, double *qt, int *p, int *n, int *m, int *r, int *d,int *j, double *at, double *pt, double *vt, double *ft, double *kt, double *rt, double *rt0, double *rt1, double *nt, double *nt0, double *nt1, double *nt2, double *pinf, double *kinf,double *finf,  double *tol,double *ahat, double *vvt,double *epshat,double *epshatvar, double *etahat,double *etahatvar,double *thetahat,double *thetahatvar, int *ldlsignal,double *zorig, int *zorigtv, int *aug,int *state,int *dist,int *signal);
void F77_NAME(ngsmooth)(double *yt, int *ymiss, int *timevar, double *zt, double *tt, double *rtv, double *qt, double *a1, double *p1,double *p1inf, double *u, double *theta,int *dist, int *p,int *n, int *m, int *r, int *rankp, int *nnd,int *nsim,double *epsplus,double *etaplus,double *aplus1,double *c,double *tol,int *info, int *maxiter,double *convtol,int *nd,int *ndl,double *alphahat,double *alphavar,double *thetahat,double *thetavar,double *yhat,double *yvar,int *smootha, int *smooths, int *smoothy);
void F77_NAME(kfilter)(double *yt, int *ymiss, int *timevar, double *zt, double *ht,double *tt, double *rt, double *qt, double *a1, double *p1, double *p1inf, int *p,int *n,int *m,int *r,int *d,int *j,double *at, double *pt, double *vt, double *ft,double *kt, double *pinf, double *finf, double *kinf, double *lik, double *tol,int *rankp, double *theta, double *thetavar, int *filtersignal);
void F77_NAME(glogliku)(double *yt, int *ymiss, int *timevar, double *zt, double *ht,double *tt, double *rt, double *qt, double *a1, double *p1, double *p1inf,int *m, int *r, int *n, double *lik, double *tol,int *rankp);
void F77_NAME(gloglik)(double *yt, int *ymiss, int *timevar, double *zt, double *ht, double *tt, double *rt, double *qt, double *a1, double *p1, double *p1inf,int *p, int *m, int *r, int *n, double *lik, double *tol,int *rankp);
void F77_NAME(ngloglik)(double *yt, int *ymiss, int *timevar, double *zt, double *tt, double *rtv, double *qt, double *a1, double *p1,double *p1inf, int *p,int *m,int *r, int *n, double *lik, double *theta, double *u, int *dist,int *maxiter,int *rankp,double *convtol, int *nnd,int *nsim,double *epsplus,double *etaplus,double *aplus1,double *c,double *tol,int *info,int *antit,int *sim,int *nsim2,int *nd,int *ndl, double *diff);
void F77_NAME(isample)(double *yt, int *ymiss, int *timevar, double *zt, double *tt, double *rtv, double *qt, double *a1, double *p1,double *p1inf, double *u, int *dist, int *p, int *n, int *m, int *r, double *theta, int *maxiter,int *rankp,double *convtol, int *nnd,int *nsim, double *epsplus,double *etaplus,double *aplus1,double *c,double *tol,int *info,int *antithetics,double *w,double *sim,int *nd,int *ndl, int *simwhat, int *simdim);
void F77_NAME(zalpha)(int *timevar, double *zt, int *alpha, double *theta, int *p, int *m, int *n, int *nsim, int *m2, int *states);
void F77_NAME(varmeanw)(double *x,double *w,int *m,int *n,int *k,double *meanx,double *varx,int *var);
void F77_NAME(artransform)(double *u, double *phi, int *p);
void F77_NAME(simfilter)(int *ymiss,int *timevar, double *yt, double *zt, double *ht, double *tt, double *rtv, double *qt, double *a1, double *p1, double *p1inf, int *nnd, int *nsim, double *epsplus, double *etaplus, double *aplus1, int *p, int *n, int *m, int *r, int *info,int *rankp, double *tol, int *nd, int *ndl, double *sim, double *c, int *simwhat, int *simdim, int *antithetics);
void F77_NAME(ngfilter)(double *yt, int *ymiss, int *timevar, double *zt, double *tt, double *rtv, double *qt, double *a1, double *p1,double *p1inf, double *u, double *theta,int *dist, int *p,int *n, int *m, int *r, int *rankp, int *nnd,int *nsim,double *epsplus,double *etaplus,double *aplus1,double *c,double *tol,int *info, int *maxiter,double *convtol,int *nd,int *ndl,double *alphahat,double *alphavar,double *thetahat,double *thetavar,double *yhat,double *yvar,int *smootha, int *smooths, int *smoothy);
void F77_NAME(isamplefilter)(double *yt, int *ymiss, int *timevar, double *zt, double *tt, double *rtv, double *qt, double *a1, double *p1,double *p1inf, double *u, int *dist, int *p, int *n, int *m, int *r, double *theta, int *maxiter,int *rankp,double *convtol, int *nnd,int *nsim, double *epsplus,double *etaplus,double *aplus1,double *c,double *tol,int *info, int *antithetics, double *w,double *sim, int *nd,int *ndl, int *simwhat, int *simdim);
void F77_NAME(simgaussian)(int *ymiss, int *timevar, double *yt, double *zt, double *ht, double *tt, double *rtv, double *qt, double *a1, double *p1, double *p1inf, int *nnd, int *nsim, double *epsplus, double *etaplus, double *aplus1, int *p, int *n, int *m, int *r, int *info,int *rankp, double *tol, int *nd, int *ndl, double *sim, double *c, int *simwhat, int *simdim, int *antithetics);
void F77_NAME(deviance)(double *y,double *mu,double *u,int *ymiss,int *n,int *p,int *dist,double *dev);

####$$$$ KFAS\src/deviance.f95
subroutine mu(dist,u,n,p,theta)
    implicit none

    integer, intent(in) :: n,p
    integer, intent(in), dimension(p) :: dist
    double precision, intent(in), dimension(n,p) :: u
    double precision, intent(inout), dimension(n,p) :: theta
    integer j

    do j=1, p
        select case(dist(j))
            case(2)
                theta(:,j) = exp(theta(:,j))*u(:,j)
            case(3)
                theta(:,j) = exp(theta(:,j))/(1.0d0+exp(theta(:,j)))
            case(4)
                theta(:,j) = exp(theta(:,j))
            case(5)
                theta(:,j) = exp(theta(:,j))
        end select
    end do

end subroutine mu

subroutine deviance(y,mu,u,ymiss,n,p,dist,dev)

    implicit none

    integer, intent(in) :: n,p
    integer, intent(in), dimension(p) :: dist
    integer j
    integer, intent(in), dimension(n,p) :: ymiss
    double precision, intent(in), dimension(n,p) :: y, mu,u
    double precision, intent(inout) :: dev
    double precision, dimension(n,p) :: res
    double precision, dimension(n) :: tmp,tmp2

    res = y
    where(ymiss /= 0) res = 0.0d0

    do j=1, p
        select case(dist(j))
            case(1)
                where(ymiss(:,j) == 0) res(:,j) = (res(:,j) - mu(:,j))**2
            case(2)
                tmp = 1.0d0
                where (res(:,j)/=0.0d0) tmp = res(:,j)/mu(:,j)
                where(ymiss(:,j) == 0) res(:,j) =  2.0d0*(res(:,j)*log(tmp) - res(:,j) + mu(:,j))
            case(3)
                where(ymiss(:,j) == 0) res(:,j) = res(:,j)/u(:,j)

                tmp = 1.0d0
                where (res(:,j)/=0.0d0) tmp = res(:,j)/mu(:,j)
                tmp2 = 1.0d0
                where (res(:,j)/=1.0d0 .and. mu(:,j)/=1.0d0) tmp2 = (1.0d0-res(:,j))/(1.0d0-mu(:,j))

                where(ymiss(:,j) == 0) res(:,j) =  2.0d0*u(:,j)*(res(:,j)*log(tmp)+(1.0d0-res(:,j))*log(tmp2))

            case(4)
                tmp = 1.0d0
                where (res(:,j)/=0.0d0) tmp = res(:,j)/mu(:,j)
                where(ymiss(:,j) == 0) res(:,j) = -2.0d0*(log(tmp)-(res(:,j)-mu(:,j))/mu(:,j))
            case(5)
                tmp = res(:,j)/mu(:,j)
                where (res(:,j)<1.0d0) tmp = 1.0d0/mu(:,j)
                where(ymiss(:,j) == 0) res(:,j) = 2.0d0*(res(:,j)*log(tmp) - &
                (res(:,j)+u(:,j))*log((res(:,j)+u(:,j))/(mu(:,j)+u(:,j))))
        end select
    end do
    dev = sum(res)
end subroutine deviance
####$$$$ KFAS\src/filtersimfast.f95
subroutine filtersimfast(yt, ymiss, timevar, zt,tt, &
a1, ft,kt,finf, kinf, dt, jt, p, m, n,tol,at)

    implicit none

    integer, intent(in) ::  p, m,n,dt,jt
    integer ::  t, i,d,j
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(p,n) :: ft,finf
    double precision, intent(in), dimension(m,p,n) :: kt,kinf
    double precision, intent(in) :: tol
    double precision, intent(inout), dimension(m,n+1) :: at
    double precision, dimension(p,n) :: vt
    double precision, dimension(m) :: arec
    double precision :: meps
    double precision, external :: ddot

 meps = tiny(meps)

    j=0
    d=0
    if(dt.GT.0) then
        arec = a1
        diffuse: do while(d .LT. (dt-1))
            d = d+1
            do j=1, p
                if(ymiss(d,j).EQ.0) then
                    vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1) !arec
                    if (finf(j,d) .GT. tol) then
                        call daxpy(m,vt(j,d)/finf(j,d),kinf(:,j,d),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                    else
                        if(ft(j,d) .GT. meps) then
                            call daxpy(m,vt(j,d)/ft(j,d),kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                        end if
                    end if
                end if
            end do
           
            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:,d+1),1)
            call dcopy(m,at(:,d+1),1,arec,1)
            
        end do diffuse

        d = dt
        do j=1, jt
            if(ymiss(d,j).EQ.0) then
                vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1) !arec
      
                if (finf(j,d) .GT. tol) then
                    call daxpy(m,vt(j,d)/finf(j,d),kinf(:,j,d),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                else
                    if(ft(j,d) .GT. meps ) then
                        call daxpy(m,vt(j,d)/ft(j,d),kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                    end if
                end if
            end if
        end do
   
  
        !non-diffuse filtering begins
 
        do i = jt+1, p
            if(ymiss(d,i).EQ.0) then
                vt(i,d) = yt(d,i) - ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,arec,1) !vt
                if (ft(i,d) .GT.  meps) then !ft.NE.0
                    call daxpy(m,vt(i,d)/ft(i,d),kt(:,i,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                end if
            end if
        end do
   
call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:,d+1),1)
   call dcopy(m,at(:,d+1),1,arec,1)
    end if

    if(dt.LT.n) then

        !Non-diffuse filtering continues from t=d+1, i=1


        if(dt.EQ.0) then
            arec = a1
        end if
        do t = dt+1, n
            do i = 1, p
                if(ymiss(t,i).EQ.0) then
                    vt(i,t) = yt(t,i) - ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,arec,1) !variate vt
                    if (ft(i,t) .GT.  meps) then !ft.NE.0
                        call daxpy(m,vt(i,t)/ft(i,t),kt(:,i,t),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                    end if
                end if
            end do
   
call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,at(:,t+1),1)
call dcopy(m,at(:,t+1),1,arec,1)
        end do

    end if

end subroutine filtersimfast
####$$$$ KFAS\src/gloglik.f95
! Subroutine for computing the log-Likelihood of general linear gaussian state space model

subroutine gloglik(yt, ymiss, timevar, zt, ht, tt, rt, qt, a1, p1, p1inf,&
p, m, r, n, lik, tol,rankp)


    implicit none

    integer, intent(in) ::  p, m, r, n
    integer, intent(inout) :: rankp
    integer ::  t, i,d,j
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rt
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in) :: tol
    double precision, intent(inout) :: lik
    double precision, dimension(m) :: at,arec
    double precision, dimension(p) :: vt,ft,finf
    double precision, dimension(m,p) :: kt,kinf
    double precision, dimension(m,m) :: pt,pinf,prec,pirec,im,mm
    double precision, dimension(m,r) :: mr
    double precision :: c
    double precision, external :: ddot
    double precision :: meps

    meps = tiny(meps)
    c = 0.5d0*log(8.0d0*atan(1.0d0))
    at=0.0d0
    pt=0.0d0
    vt=0.0d0
    ft=0.0d0
    kt=0.0d0
    pinf=0.0d0
    kinf=0.0d0
    finf=0.0d0
    lik = 0.0d0

    pinf=p1inf

    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do
    j=0
    d=0
    ! Diffuse initialization
    if(maxval(p1inf) .GT.  0.0d0) then

        pt = p1
        prec = pt
        pirec = pinf
        at = a1
        arec = a1
        diffuse: do while(d .LT. n)
            d = d+1
            do j=1, p !univariate approach
                if(ymiss(d,j).EQ.0) then
                    vt(j) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1)
                    call dsymv('u',m,1.0d0,prec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,j),1) ! kt_t,i = pt_t,i*t(z_t,i)
                    ft(j) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kt(:,j),1)+ ht(j,j,(d-1)*timevar(2)+1)
                    call dsymv('u',m,1.0d0,pirec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kinf(:,j),1) ! kinf_t,i = pinf_t,i*t(z_t,i)
                    finf(j) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kinf(:,j),1)
                    if (finf(j) .GT. tol) then
                        call daxpy(m,vt(j)/finf(j),kinf(:,j),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                        call dsyr('u',m,ft(j)/(finf(j)**2),kinf(:,j),1,prec,m) !prec = prec +  kinf*kinf'*ft/finf^2
                        call dsyr2('u',m,-1.0d0/finf(j),kt(:,j),1,kinf(:,j),1,prec,m) !prec = prec -(kt*kinf'+kinf*kt')/finf
                        call dsyr('u',m,-1.0d0/finf(j),kinf(:,j),1,pirec,m) !pirec = pirec -kinf*kinf'/finf
                        lik = lik - 0.5d0*log(finf(j))
                        rankp = rankp -1
                        do i = 1, m
                            if(pirec(i,i) .LT. tol) then
                                pirec(i,:) = 0.0d0
                                pirec(:,i) = 0.0d0
                            end if
                        end do
                    else
                        if (ft(j) .GT. meps) then
                            call daxpy(m,vt(j)/ft(j),kt(:,j),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                            call dsyr('u',m,(-1.0d0)/ft(j),kt(:,j),1,prec,m) !prec = prec -kt*kt'/ft
                            lik = lik - 0.5d0*(log(ft(j)) + vt(j)**2/ft(j))
                        end if
                    end if
                    if (ft(j) .GT. meps) then
                        lik = lik -c
                    end if
                    if(rankp .EQ. 0) then
                        exit diffuse
                    end if
                end if
            end do
           
            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)
            call dcopy(m,at(:),1,arec,1) ! a_rec = at(:,t+1)
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)
      
     
            call dsymm('r','u',m,r,1.0d0,qt(:,:,(d-1)*timevar(5)+1),r,rt(:,:,(d-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(d-1)*timevar(4)+1),m,1.0d0,pt,m)
       
            prec = pt
            call dsymm('r','u',m,m,1.0d0,pirec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pinf,m)
            pirec = pinf
     
        end do diffuse
        if(rankp .EQ. 0) then
            !non-diffuse filtering begins
            prec = prec
            do i = j+1, p
                if(ymiss(d,i).EQ.0) then
                    vt(i) = yt(d,i) - ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,arec,1)
                    call dsymv('u',m,1.0d0,prec,m,zt(i,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,i),1)
                    ft(i) = ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,kt(:,i),1) + ht(i,i,(d-1)*timevar(2)+1)
                    if (ft(i) .GT. meps) then !ft.NE.0
                        call daxpy(m,vt(i)/ft(i),kt(:,i),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                        call dsyr('u',m,-1.0d0/ft(i),kt(:,i),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,t)
                        lik = lik - 0.5d0*(log(ft(i)) + vt(i)**2/ft(i))-c
                    end if
                end if
            end do
   
            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)
  
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)
 
            call dsymm('r','u',m,r,1.0d0,qt(:,:,(d-1)*timevar(5)+1),r,rt(:,:,(d-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(d-1)*timevar(4)+1),m,1.0d0,pt,m)
    
   
            call dcopy(m,at(:),1,arec,1)
            prec = pt
            pt = prec
        end if
    end if



    !Non-diffuse filtering continues from t=d+1, i=1


    if(d.EQ.0) then
        prec = p1
        arec = a1
    end if
    do t = d+1, n
        do i = 1, p
            if(ymiss(t,i).EQ.0) then
                vt(i) = yt(t,i) - ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,arec,1)
                call dsymv('u',m,1.0d0,prec,m,zt(i,:,(t-1)*timevar(1)+1),1,0.0d0,kt(:,i),1)
                ft(i) = ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,kt(:,i),1) + ht(i,i,(t-1)*timevar(2)+1)
                if (ft(i) .GT. meps) then
                    call daxpy(m,vt(i)/ft(i),kt(:,i),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                    call dsyr('u',m,-1.0d0/ft(i),kt(:,i),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,i,t)
                    lik = lik - 0.5d0*(log(ft(i)) + vt(i)**2/ft(i))-c
                end if
            end if
        end do
        call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)
        call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,mm,m)
        call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,pt,m)
        call dsymm('r','u',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rt(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
        call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(t-1)*timevar(4)+1),m,1.0d0,pt,m)
        call dcopy(m,at(:),1,arec,1)
        prec = pt
    end do



end subroutine gloglik
####$$$$ KFAS\src/glogliku.f95
! Subroutine for computing the log-Likelihood of univariate linear gaussian state space model

subroutine glogliku(yt, ymiss, timevar, zt, ht,tt, rt, qt, a1, p1, p1inf,&
m, r, n, lik, tol,rankp)

    implicit none

    integer, intent(in) ::  m, r, n
    integer, intent(in), dimension(n,1) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    integer, intent(inout) :: rankp
    integer ::  t, i, d
    double precision, intent(in), dimension(n,1) :: yt
    double precision, intent(in), dimension(1,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(1,1,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rt
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in) :: tol
    double precision, intent(inout) :: lik
    double precision, dimension(m) :: at,arec
    double precision  :: vt,ft,finf
    double precision, dimension(m,1) :: kt,kinf
    double precision, dimension(m,m) :: pt, pinf,mm,im,prec,pirec
    double precision, dimension(m,r) :: mr
    double precision :: c
    double precision, external :: ddot
    double precision :: meps

    meps = tiny(meps)
    c = 0.5d0*log(8.0d0*atan(1.0d0))
    at=0.0d0
    pt=0.0d0
    vt=0.0d0
    ft=0.0d0
    kt=0.0d0
    pinf=0.0d0
    kinf=0.0d0
    finf=0.0d0
    lik = 0.0d0

    pinf=p1inf

    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do
    d=0
    ! Diffuse initialization
    if(maxval(p1inf) .GT.  0.0d0) then

        pt = p1
        prec = pt
        pirec = pinf
        at = a1
        arec = a1
        diffuse: do while(d .LT. n)
            d = d+1
            if(ymiss(d,1).EQ.0) then
                vt = yt(d,1) - ddot(m,zt(1,:,(d-1)*timevar(1)+1),1,arec,1)
                call dsymv('u',m,1.0d0,prec,m,zt(1,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,1),1) ! kt_t,i = pt_t,i*t(z_t,i)
                ft = ddot(m,zt(1,:,(d-1)*timevar(1)+1),1,kt(:,1),1)+ ht(1,1,(d-1)*timevar(2)+1)
                call dsymv('u',m,1.0d0,pirec,m,zt(1,:,(d-1)*timevar(1)+1),1,0.0d0,kinf(:,1),1) ! kinf_t,i = pinf_t,i*t(z_t,i)
                finf = ddot(m,zt(1,:,(d-1)*timevar(1)+1),1,kinf(:,1),1)
                if (finf .GT. tol) then
                    call daxpy(m,vt/finf,kinf(:,1),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                    call dsyr('u',m,ft/(finf**2),kinf(:,1),1,prec,m) !prec = prec +  kinf*kinf'*ft/finf^2
                    call dsyr2('u',m,-1.0d0/finf,kt(:,1),1,kinf(:,1),1,prec,m) !prec = prec -(kt*kinf'+kinf*kt')/finf
                    call dsyr('u',m,-1.0d0/finf,kinf(:,1),1,pirec,m) !pirec = pirec -kinf*kinf'/finf
                    lik = lik - 0.5d0*log(finf)
                    do i = 1, m
                        if(pirec(i,i) .LT. tol) then
                            pirec(i,:) = 0.0d0
                            pirec(:,i) = 0.0d0
                        end if
                    end do
                    rankp = rankp -1
                else
                    if (ft .GT. meps) then
                        call daxpy(m,vt/ft,kt(:,1),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                        call dsyr('u',m,(-1.0d0)/ft,kt(:,1),1,prec,m) !prec = prec -kt*kt'/ft
                        lik = lik - 0.5d0*(log(ft) + vt**2/ft)
                    end if
                end if
                if (ft .GT. meps) then
                    lik = lik -c
                end if
                if(rankp .EQ. 0) then
                    exit diffuse
                end if

            end if

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)
            call dcopy(m,at(:),1,arec,1) ! a_rec = at(:,t+1)
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)


            call dsymm('r','u',m,r,1.0d0,qt(:,:,(d-1)*timevar(5)+1),r,rt(:,:,(d-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(d-1)*timevar(4)+1),m,1.0d0,pt,m)

            prec = pt
            call dsymm('r','u',m,m,1.0d0,pirec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pinf,m)
            pirec = pinf


        end do diffuse

        !non-diffuse filtering begins
        if(rankp .EQ. 0) then

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)

            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)

            call dsymm('r','u',m,r,1.0d0,qt(:,:,(d-1)*timevar(5)+1),r,rt(:,:,(d-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(d-1)*timevar(4)+1),m,1.0d0,pt,m)


            call dcopy(m,at(:),1,arec,1)
            prec = pt
        end if
    end if

   
    !Non-diffuse filtering continues from t=d+1, i=1


    if(d.EQ.0) then
        prec = p1
        arec = a1!   call dcopy(m,a1,1,arec,1)
       !!at(:) = a1 !call dcopy(m,a1,1,at(:),1) !at(:,1) = a1
       !!pt = p1
    end if
    do t = d+1, n
        if(ymiss(t,1).EQ.0) then
            vt = yt(t,1) - ddot(m,zt(1,:,(t-1)*timevar(1)+1),1,arec,1)
            call dsymv('u',m,1.0d0,prec,m,zt(1,:,(t-1)*timevar(1)+1),1,0.0d0,kt(:,1),1)
            ft = ddot(m,zt(1,:,(t-1)*timevar(1)+1),1,kt(:,1),1)+ht(1,1,(t-1)*timevar(2)+1)
            if (ft .GT. meps) then
                call daxpy(m,vt/ft,kt(:,1),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                call dsyr('u',m,-1.0d0/ft,kt(:,1),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,i,t)
                lik = lik - 0.5d0*(log(ft) + vt**2/ft)-c
            end if
        end if
        call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)
        call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,mm,m)
        call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,pt,m)
        call dsymm('r','u',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rt(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
        call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(t-1)*timevar(4)+1),m,1.0d0,pt,m)
        call dcopy(m,at(:),1,arec,1) ! a_rec =at(:,t+1)
        prec = pt
    end do



end subroutine glogliku

####$$$$ KFAS\src/gsmoothall.f95
! Subroutine for Kalman smoothing of linear gaussian state space model

subroutine gsmoothall(ymiss, timevar, zt, ht,tt, rtv, qt, p, n, m, r, d,j, at, pt, vt, ft, kt, &
rt, rt0, rt1, nt, nt0, nt1, nt2, pinf, kinf,finf,  tol,ahat, vvt,epshat,epshatvar, &
etahat,etahatvar,thetahat,thetahatvar, ldlsignal,zorig, zorigtv,aug,state,dist,signal)

    implicit none

    integer, intent(in) :: d, j, p, r, m, n,aug,state,dist,signal,ldlsignal,zorigtv
    integer :: t, i
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m,n+1) :: at
    double precision, intent(in), dimension(m,m,n+1) :: pt
    double precision, intent(in), dimension(p,n) ::  vt,ft
    double precision, intent(in), dimension(m,p,n) :: kt
    double precision, intent(in), dimension(m,m,d+1) ::  pinf
    double precision, intent(in),dimension(m,p,d) ::  kinf
    double precision, intent(in), dimension(p,d) ::  finf
    double precision, intent(in) :: tol
    double precision, intent(inout), dimension(m,m,n+1) :: nt !n_1 = n_0, ..., n_201 = n_200
    double precision, intent(inout), dimension(m,n+1) :: rt !same as n, r_1 = r_0 etc.
    double precision, intent(inout), dimension(m,d+1) :: rt0,rt1
    double precision, intent(inout), dimension(m,m,d+1) :: nt0,nt1,nt2
    double precision, intent(inout), dimension(m*state,n*state) :: ahat
    double precision, intent(inout), dimension(m*state,m*state,n*state) :: vvt
    double precision, intent(inout), dimension(p*dist*aug,n*dist*aug) :: epshat
    double precision, intent(inout), dimension(p*dist*aug,n*dist*aug) :: epshatvar
    double precision, intent(inout), dimension(r*dist,n*dist) :: etahat
    double precision, intent(inout), dimension(r*dist,r*dist,n*dist) :: etahatvar
    double precision, intent(inout), dimension(p*signal,n*signal) :: thetahat
    double precision, intent(inout), dimension(p*signal,p*signal,n*signal) :: thetahatvar

    double precision, intent(in), dimension(ldlsignal*p,ldlsignal*m,ldlsignal*((n-1)*zorigtv+1)) :: zorig

    double precision, dimension(m,m) :: linf,l0
    double precision, dimension(m,m) :: nrec,nrec1,nrec2,im,mm,mm2
    double precision, dimension(m) :: rrec,rrec1,rhelp, help
    double precision, dimension(m,r) :: mr, mr2
    double precision, dimension(p,m) :: pm
    double precision, dimension(p,n) ::  ftinv
    double precision, dimension(p,d) ::  finfinv
    double precision, external :: ddot

    if(aug.EQ.1 .AND. dist.EQ.1) then
        do i = 1, p
            do t = 1, n
                epshatvar(i,t) =  ht(i,i,(t-1)*timevar(2)+1)
            end do
        end do
    end if


    ftinv = 1.0d0/ft
    finfinv = 1.0d0/finf

    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do

    rrec = 0.0d0
    nrec = 0.0d0
    nt(:,:,n+1) = 0.0d0 !t goes from n+1 to 1, not from n to 0 !
    rt(:,n+1) = 0.0d0


    do t = n, d+1, -1 !do until diffuse starts


        do i = p, 1 , -1
            if(ymiss(t,i).EQ.0) then
                if(ft(i,t) .GT. 0.0d0) then
                    if(aug.EQ.1 .AND. dist.EQ.1) then
                        epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)/ft(i,t)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))
                        call dgemv('n',m,m,ftinv(i,t)**2, nrec,m,kt(:,i,t),1,0.0d0,rhelp,1)
                        epshatvar(i,t) = ht(i,i,(t-1)*timevar(2)+1)-(ht(i,i,(t-1)*timevar(2)+1)**2)*&
                        (ftinv(i,t)+ddot(m,kt(:,i,t),1,rhelp,1))
                    end if

                    rhelp = -zt(i,:,(t-1)*timevar(1)+1)*ftinv(i,t)
                    l0 = im
                    call dgemm('n','n',m,m,1,1.0d0,kt(:,i,t),&
                    m,rhelp,1,1.0d0,l0,m)


                    call dgemv('t',m,m,1.0d0,l0,m,rrec,1,0.0d0,rhelp,1)
                    rrec = rhelp + vt(i,t)*ftinv(i,t)*zt(i,:,(t-1)*timevar(1)+1)
                    call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !n = l'nl
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,0.0d0,nrec,m)
                    call dgemm('t','n',m,m,1,1.0d0,zt(i,:,(t-1)*timevar(1)+1),&
                    1,zt(i,:,(t-1)*timevar(1)+1),1,0.0d0,mm,m)
                    nrec = nrec+mm*ftinv(i,t)

                end if
            end if
        end do

        rt(:,t) =rrec
        nt(:,:,t) = nrec !n_t-1 = n_t,0

        if(t.GT.1) then
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1) !r_t,p=t_t-1'*r_t+1
            rrec = rhelp
            call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec,m,0.0d0,mm,m) !n*t
            call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec,m) !n_t,p = t'nt
        end if

    end do


    if(d.GT.0) then
        t=d
        rt0(:,d+1)=rt(:,d+1)
        nt0(:,:,d+1) =  nt(:,:,d+1)

        do i = p, (j+1) , -1
            if(ymiss(t,i).EQ.0) then
                if(ft(i,t) .GT. 0.0d0) then
                    if(aug .EQ. 1 .AND. dist.EQ.1) then
                        epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)/ft(i,t)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))
                        call dgemv('n',m,m,ftinv(i,t)**2,nrec,m,kt(:,i,t),1,0.0d0,rhelp,1)
                        epshatvar(i,t) = ht(i,i,(t-1)*timevar(2)+1)-(ht(i,i,(t-1)*timevar(2)+1)**2)*&
                        (ftinv(i,t)+ddot(m,kt(:,i,t),1,rhelp,1))
                    end if

                    rhelp = -zt(i,:,(t-1)*timevar(1)+1)*ftinv(i,t)
                    l0 = im
                    call dgemm('n','n',m,m,1,1.0d0,kt(:,i,t),&
                    m,rhelp,1,1.0d0,l0,m)


                    call dgemv('t',m,m,1.0d0,l0,m,rrec,1,0.0d0,rhelp,1)
                    rrec = rhelp + vt(i,t)*ftinv(i,t)*zt(i,:,(t-1)*timevar(1)+1)
                    call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !n = l'nl
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,0.0d0,nrec,m)
                    call dgemm('t','n',m,m,1,1.0d0,zt(i,:,(t-1)*timevar(1)+1),&
                    1,zt(i,:,(t-1)*timevar(1)+1),1,0.0d0,mm,m)
                    nrec = mm*ftinv(i,t)+nrec
                end if
            end if
        end do

        rrec1 = 0.0d0
        nrec1 = 0.0d0
        nrec2 = 0.0d0

        do i = j, 1, -1
            if(ymiss(t,i).EQ.0) then
                if(finf(i,t).GT.tol) then
                    if(aug .EQ. 1 .AND. dist.EQ.1) then
                        epshat(i,t) = -ht(i,i,(t-1)*timevar(2)+1)*ddot(m,kinf(:,i,t),1,rrec,1)/finf(i,t)
                        call dgemv('n',m,m,1.0d0,nrec,m,kinf(:,i,t),1,0.0d0,rhelp,1)
                        epshatvar(i,t) = ht(i,i,(t-1)*timevar(2)+1)-(ht(i,i,(t-1)*timevar(2)+1)**2)*&
                        ddot(m,kinf(:,i,t),1,rhelp,1)/finf(i,t)**2
                    end if


                    linf = im
                    rhelp = -zt(i,:,(t-1)*timevar(1)+1)*finfinv(i,t)
                    call dger(m,m,1.0d0,kinf(:,i,t),1,rhelp,1,linf,m)

                    rhelp = (kinf(:,i,t)*ft(i,t)*finfinv(i,t)-kt(:,i,t))*finfinv(i,t)
                    l0=0.0d0
                    call dger(m,m,1.0d0,rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0=  (-kt + ft/finf*kinf)*z/finf

                    call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                    rrec1 = rhelp + zt(i,:,(t-1)*timevar(1)+1)*vt(i,t)*finfinv(i,t)
                    call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                    call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                    rrec = rhelp

                    call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec2,m,0.0d0,mm,m) !mm =linf'*nt2
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,0.0d0,nrec2,m) !nt2 = linf'*nt2*linf
                    call dger(m,m,-1.0d0*ft(i,t)*finfinv(i,t)**2.0d0,zt(i,:,(t-1)*timevar(1)+1)&
                    ,1,zt(i,:,(t-1)*timevar(1)+1),1,nrec2,m) !nt2 = linf'nt2'linf + z'z*ft/finf^2
                    call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !mm= nt0*l0
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,1.0d0,nrec2,m) !nt2 = linf'nt2'linf + z'z*ft/finf^2 + l0'*nt0*l0

                    call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec1,m,0.0d0,mm,m) !mm = linf'*nt1
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,0.0d0,mm2,m) !nt2 = nt2 + linf'*nt1*l0
                    nrec2 = nrec2 +mm2 + transpose(mm2)

                    call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec1,m,0.0d0,mm,m) !mm = linf'*nt1
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,0.0d0,nrec1,m) !nt1 = mm*linf

                    call dger(m,m,finfinv(i,t),zt(i,:,(t-1)*timevar(1)+1),1,zt(i,:,(t-1)*timevar(1)+1),1,nrec1,m)
                    !nt1 = linf'nt1'linf + z'z/finf
                    call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !mm= nt0*linf
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,1.0d0,nrec1,m) !nt1 = l0'*nt0*linf+ linf'nt1*linf + z'z/finf

                    call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec,m,0.0d0,mm,m) !mm= nt0*linf
                    call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,0.0d0,nrec,m)

                else
                    if(ft(i,t).GT.0.0d0) then
                        if(aug .EQ. 1 .AND. dist.EQ.1) then
                            epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)/ft(i,t)-&
                            ddot(m,kt(:,i,t),1,rrec,1)/ft(i,t))
                            call dgemv('n',m,m,1.0d0,nrec,m,kt(:,i,t),1,0.0d0,rhelp,1)
                            epshatvar(i,t) = ht(i,i,(t-1)*timevar(2)+1)-(ht(i,i,(t-1)*timevar(2)+1)**2)*&
                            (ftinv(i,t)+ddot(m,kt(:,i,t),1,rhelp,1)/ft(i,t)**2)
                        end if
                        l0= im
                        call dger(m,m,-ftinv(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0 = I -Kt*Z/Ft
                        call dgemv('t',m,m,1.0d0,l0,m,rrec,1,0.0d0,rhelp,1)
                        rrec = rhelp+zt(i,:,(t-1)*timevar(1)+1)*vt(i,t)*ftinv(i,t)
                        call dgemv('t',m,m,1.0d0,l0,m,rrec1,1,0.0d0,rhelp,1)
                        rrec1=rhelp

                        call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !mm =l0'*nt0
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,0.0d0,nrec,m) !nt0 = l0'*nt0*l0
                        call dger(m,m,ftinv(i,t),zt(i,:,(t-1)*timevar(1)+1),1,&
                        zt(i,:,(t-1)*timevar(1)+1),1,nrec,m)  !nt0 = z'z/ft+l0'*nt0*l0
                        call dgemm('n','n',m,m,m,1.0d0,nrec1,m,l0,m,0.0d0,mm,m) !mm = nt1*l0
                        nrec1 = mm
                        call dgemm('n','n',m,m,m,1.0d0,nrec2,m,l0,m,0.0d0,mm,m) !mm = nt1*l0
                        nrec2 = mm !onko oikein?
                    end if
                end if
            end if
        end do
        rt0(:,t) = rrec
        rt1(:,t) = rrec1
        nt0(:,:,t) = nrec
        nt1(:,:,t) = nrec1
        nt2(:,:,t) = nrec2



        if(t.GT.1) then
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
            rrec = rhelp
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,rrec1,1,0.0d0,rhelp,1,1)
            rrec1 = rhelp
            call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec,m,0.0d0,mm,m) !n*t
            call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec,m) !n_t,p = t'nt
            call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec1,m,0.0d0,mm,m) !n*t
            call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec1,m) !n_t,p = t'nt
            call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec2,m,0.0d0,mm,m) !n*t
            call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec2,m) !n_t,p = t'nt

        end if

        do t=(d-1), 1, -1

            do i = p, 1, -1
                if(ymiss(t,i).EQ.0) then
                    if(finf(i,t).GT. tol) then
                        if(aug .EQ. 1 .AND. dist.EQ.1) then
                            epshat(i,t) = -ht(i,i,(t-1)*timevar(2)+1)*ddot(m,kinf(:,i,t),1,rrec,1)/finf(i,t)
                            call dgemv('n',m,m,1.0d0,nrec,m,kinf(:,i,t),1,0.0d0,rhelp,1)
                            epshatvar(i,t) = ht(i,i,(t-1)*timevar(2)+1)-(ht(i,i,(t-1)*timevar(2)+1)**2)*&
                            ddot(m,kinf(:,i,t),1,rhelp,1)/finf(i,t)**2
                        end if

                        linf = im
                        rhelp = -zt(i,:,(t-1)*timevar(1)+1)*finfinv(i,t)
                        call dger(m,m,1.0d0,kinf(:,i,t),1,rhelp,1,linf,m)

                        rhelp = (kinf(:,i,t)*ft(i,t)*finfinv(i,t)-kt(:,i,t))*finfinv(i,t)
                        l0=0.0d0
                        call dger(m,m,1.0d0,rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0=  (-kt + ft/finf*kinf)*z/finf

                        call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                        rrec1 = rhelp + zt(i,:,(t-1)*timevar(1)+1)*vt(i,t)*finfinv(i,t)
                        call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                        call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                        rrec = rhelp

                        call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec2,m,0.0d0,mm,m) !mm =linf'*nt2
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,0.0d0,nrec2,m) !nt2 = linf'*nt2*linf
                        call dger(m,m,-1.0d0*ft(i,t)*finfinv(i,t)**2.0d0,zt(i,:,(t-1)*timevar(1)+1)&
                        ,1,zt(i,:,(t-1)*timevar(1)+1),1,nrec2,m) !nt2 = linf'nt2'linf + z'z*ft/finf^2
                        call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !mm= nt0*l0
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,1.0d0,nrec2,m) !nt2 = linf'nt2'linf + z'z*ft/finf^2 + l0'*nt0*l0

                        call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec1,m,0.0d0,mm,m) !mm = linf'*nt1
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,0.0d0,mm2,m) !nt2 = nt2 + linf'*nt1*l0
                        nrec2 = nrec2 +mm2 + transpose(mm2)

                        call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec1,m,0.0d0,mm,m) !mm = linf'*nt1
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,0.0d0,nrec1,m) !nt1 = mm*linf

                        call dger(m,m,finfinv(i,t),zt(i,:,(t-1)*timevar(1)+1),1,zt(i,:,(t-1)*timevar(1)+1),1,nrec1,m)
                        !nt1 = linf'nt1'linf + z'z/finf
                        call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !mm= nt0*linf
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,1.0d0,nrec1,m) !nt1 = l0'*nt0*linf+ linf'nt1*linf + z'z/finf

                        call dgemm('t','n',m,m,m,1.0d0,linf,m,nrec,m,0.0d0,mm,m) !mm= nt0*linf
                        call dgemm('n','n',m,m,m,1.0d0,mm,m,linf,m,0.0d0,nrec,m)

                    else
                        if(ft(i,t).GT.0.0d0) then !lis?tty 12.1.2012
                            if(aug .EQ. 1 .AND. dist.EQ.1) then
                                epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)/ft(i,t)-&
                                ddot(m,kt(:,i,t),1,rrec,1)/ft(i,t))
                                call dgemv('n',m,m,1.0d0,nrec,m,kt(:,i,t),1,0.0d0,rhelp,1)
                                epshatvar(i,t) = ht(i,i,(t-1)*timevar(2)+1)-(ht(i,i,(t-1)*timevar(2)+1)**2)*&
                                (ftinv(i,t)+ddot(m,kt(:,i,t),1,rhelp,1)/ft(i,t)**2 )
                            end if
                            l0= im
                            call dger(m,m,-ftinv(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0 = I -Kt*Z/Ft
                            call dgemv('t',m,m,1.0d0,l0,m,rrec,1,0.0d0,rhelp,1)
                            rrec = rhelp+zt(i,:,(t-1)*timevar(1)+1)*vt(i,t)*ftinv(i,t)
                            call dgemv('t',m,m,1.0d0,l0,m,rrec1,1,0.0d0,rhelp,1)
                            rrec1=rhelp

                            call dgemm('t','n',m,m,m,1.0d0,l0,m,nrec,m,0.0d0,mm,m) !mm =l0'*nt0
                            call dgemm('n','n',m,m,m,1.0d0,mm,m,l0,m,0.0d0,nrec,m) !nt0 = l0'*nt0*l0
                            call dger(m,m,ftinv(i,t),zt(i,:,(t-1)*timevar(1)+1),1,&
                            zt(i,:,(t-1)*timevar(1)+1),1,nrec,m)  !nt0 = z'z/ft+l0'*nt0*l0
                            call dgemm('n','n',m,m,m,1.0d0,nrec1,m,l0,m,0.0d0,mm,m) !mm = nt1*l0
                            nrec1 = mm
                            call dgemm('n','n',m,m,m,1.0d0,nrec2,m,l0,m,0.0d0,mm,m) !mm = nt1*l0
                            nrec2 = mm !onko oikein?
                        end if
                    end if
                end if
            end do


            rt0(:,t) = rrec
            rt1(:,t) = rrec1
            nt0(:,:,t) = nrec
            nt1(:,:,t) = nrec1
            nt2(:,:,t) = nrec2


            if(t.GT.1) then
                call dgemv('t',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
                rrec = rhelp
                call dgemv('t',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,rrec1,1,0.0d0,rhelp,1,1)
                rrec1 = rhelp
                call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec,m,0.0d0,mm,m) !n*t
                call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec,m) !n_t,p = t'nt
                call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec1,m,0.0d0,mm,m) !n*t
                call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec1,m) !n_t,p = t'nt
                call dgemm('t','n',m,m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,nrec2,m,0.0d0,mm,m) !n*t
                call dgemm('n','n',m,m,m,1.0d0,mm,m,tt(:,:,(t-2)*timevar(3)+1),m,0.0d0,nrec2,m) !n_t,p = t'nt
            end if


        end do
    end if

    if(state.EQ.1) then
        do t = 1, d
            ahat(:,t) = at(:,t)
            call dsymv('u',m,1.0d0,pt(:,:,t),m,rt0(:,t),1,1.0d0,ahat(:,t),1)
            call dsymv('u',m,1.0d0,pinf(:,:,t),m,rt1(:,t),1,1.0d0,ahat(:,t),1)

            vvt(:,:,t) = pt(:,:,t)
            call dsymm('l','u',m,m,1.0d0,pt(:,:,t),m,nt0(:,:,t),m,0.0d0,mm,m) !mm = pt*nt0
            call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,1.0d0,vvt(:,:,t),m) !vvt = pt - pt*nt0*pt
            call dsymm('l','u',m,m,1.0d0,pinf(:,:,t),m,nt1(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt1
            call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,0.0d0,mm2,m) !mm2 = -pinf*nt1*pt
            vvt(:,:,t) = vvt(:,:,t) + mm2 + transpose(mm2) !vvt = pt - pt*nt0*pt  -pinf*nt1*pt - t(pinf*nt1*pt)
            call dsymm('l','u',m,m,1.0d0,pinf(:,:,t),m,nt2(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt2
            call dsymm('r','u',m,m,-1.0d0,pinf(:,:,t),m,mm,m,1.0d0,vvt(:,:,t),m) !vvt = vvt - pinf*nt2*pinf
        end do
        do t = d+1, n
            ahat(:,t) = at(:,t)
            call dsymv('u',m,1.0d0,pt(:,:,t),m,rt(:,t),1,1.0d0,ahat(:,t),1) !ahat = ahat+pt*r_t-1
            !call dgemm('n','n',m,m,m,1.0d0,pt(:,:,t),m,nt(:,:,t),m,0.0d0,mm,m) !pt*n_t-1
            !call dgemm('n','t',m,m,m,1.0d0,mm,m,pt(:,:,t),m,0.0d0,vvt(:,:,t),m) !pt*n_t-1*pt
            !vvt(:,:,t) = pt(:,:,t)-vvt(:,:,t)
            !vvt(:,:,t) = pt(:,:,t)
            call dsymm('l','u',m,m,1.0d0,pt(:,:,t),m,nt(:,:,t),m,0.0d0,mm,m) !pt*n_t-1
            mm = im - mm
            call dsymm('r','u',m,m,1.0d0,pt(:,:,t),m,mm,m,0.0d0,vvt(:,:,t),m) !pt*n_t-1*pt
        end do
        if(m > 1) then
            do t=1, n
                do i=1,m-1
                    vvt((i+1):m,i,t) =vvt(i,(i+1):m,t)
                end do
            end do
        end if
    end if
    !    if(state.EQ.1) then
    !        do t = 1, d
    !            call dcopy(m,at(:,t),1,ahat(:,t),1) !ahat = at
    !            call dgemv('n',m,m,1.0d0,pt(:,:,t),m,rt0(:,t),1,1.0d0,ahat(:,t),1) !ahat = at + pt * rt0_t
    !            call dgemv('n',m,m,1.0d0,pinf(:,:,t),m,rt1(:,t),1,1.0d0,ahat(:,t),1) !ahat = at + pt * rt0_t + pinf*rt1_t
    !            vvt(:,:,t) = pt(:,:,t)
    !            call dgemm('n','n',m,m,m,1.0d0,pt(:,:,t),m,nt0(:,:,t),m,0.0d0,mm,m) !mm = pt*nt0
    !            call dgemm('n','t',m,m,m,-1.0d0,mm,m,pt(:,:,t),m,1.0d0,vvt(:,:,t),m) !vvt = pt - pt*nt0*pt
    !            call dgemm('n','n',m,m,m,1.0d0,pinf(:,:,t),m,nt1(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt1
    !            call dgemm('n','n',m,m,m,-1.0d0,mm,m,pt(:,:,t),m,0.0d0,mm2,m) !mm2 = -pinf*nt1*pt
    !            vvt(:,:,t) = vvt(:,:,t) + mm2 + transpose(mm2) !vvt = pt - pt*nt0*pt  -pinf*nt1*pt - t(pinf*nt1*pt)
    !            call dgemm('n','n',m,m,m,1.0d0,pinf(:,:,t),m,nt2(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt2
    !            call dgemm('n','t',m,m,m,-1.0d0,mm,m,pinf(:,:,t),m,1.0d0,vvt(:,:,t),m) !vvt = vvt - pinf*nt2*pinf
    !        end do
    !        do t = d+1, n
    !            call dcopy(m,at(:,t),1,ahat(:,t),1) !ahat = at
    !            call dgemv('n',m,m,1.0d0,pt(:,:,t),m,rt(:,t),1,1.0d0,ahat(:,t),1) !ahat = ahat+pt*r_t-1
    !            !vvt(:,:,t) = pt(:,:,t)
    !            !call dgemm('n','n',m,m,m,1.0d0,pt(:,:,t),m,nt(:,:,t),m,0.0d0,mm,m) !pt*n_t-1
    !            !call dgemm('n','n',m,m,m,-1.0d0,mm,m,pt(:,:,t),m,1.0d0,vvt(:,:,t),m) !pt*n_t-1*pt
    !
    !            call dgemm('n','n',m,m,m,1.0d0,pt(:,:,t),m,nt(:,:,t),m,0.0d0,mm,m)
    !            mm = im - mm
    !            call dgemm('n','n',m,m,m,1.0d0,mm,m,pt(:,:,t),m,0.0d0,vvt(:,:,t),m) !pt*n_t-1*pt
    !
    !        end do
    !        do t= 1,n
    !            vvt(:,:,t) = (vvt(:,:,t)+transpose(vvt(:,:,t)))/2.0d0
    !        end do
    !    end if

    if(dist.EQ.1) then
        do t = 1, d
            call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rt0(:,t+1),1,0.0d0,help,1)
            call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
            etahatvar(:,:,t) = qt(:,:,(t-1)*timevar(5)+1)
            call dsymm('r','u',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rtv(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','n',m,r,m,1.0d0,nt0(:,:,t+1),m,mr,m,0.0d0,mr2,m)
            call dgemm('t','n',r,r,m,-1.0d0,mr,m,mr2,m,1.0d0,etahatvar(:,:,t),r)
        end do
        do t = d+1, n
            call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rt(:,t+1),1,0.0d0,help,1)
            call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
            etahatvar(:,:,t) = qt(:,:,(t-1)*timevar(5)+1)
            call dsymm('r','l',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rtv(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','n',m,r,m,1.0d0,nt(:,:,t+1),m,mr,m,0.0d0,mr2,m)
            call dgemm('t','n',r,r,m,-1.0d0,mr,m,mr2,m,1.0d0,etahatvar(:,:,t),r)
        end do
    end if

    if(signal.EQ.1) then
        if(ldlsignal .EQ. 1) then
            if(state .EQ. 1) then
                do t = 1, n
                    call dgemv('n',p,m,1.0d0,zorig(:,:,(t-1)*zorigtv+1),p,ahat(:,t),1,0.0d0,thetahat(:,t),1)
                    call dsymm('r','u',p,m,1.0d0,vvt(:,:,t),m,zorig(:,:,(t-1)*zorigtv+1),p,0.0d0,pm,p)
                    call dgemm('n','t',p,p,m,1.0d0,pm,p,zorig(:,:,(t-1)*zorigtv+1),p,0.0d0,thetahatvar(:,:,t),p)
                end do
            else
                do t = 1, d
                    call dcopy(m,at(:,t),1,rrec,1) !ahat = at
                    call dsymv('u',m,1.0d0,pt(:,:,t),m,rt0(:,t),1,1.0d0,rrec,1) !ahat = at + pt * rt0_t
                    call dsymv('u',m,1.0d0,pinf(:,:,t),m,rt1(:,t),1,1.0d0,rrec,1) !ahat = at + pt * rt0_t + pinf*rt1_t
                    call dgemv('n',p,m,1.0d0,zorig(:,:,(t-1)*zorigtv+1),p,rrec,1,0.0d0,thetahat(:,t),1)

                    nrec = pt(:,:,t)
                    call dsymm('l','u',m,m,1.0d0,pt(:,:,t),m,nt0(:,:,t),m,0.0d0,mm,m) !mm = pt*nt0
                    call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,1.0d0,nrec,m) !vvt = pt - pt*nt0*pt
                    call dsymm('l','u',m,m,1.0d0,pinf(:,:,t),m,nt1(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt1
                    call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,0.0d0,mm2,m) !mm2 = -pinf*nt1*pt
                    nrec = nrec + mm2 + transpose(mm2) !vvt = pt - pt*nt0*pt  -pinf*nt1*pt - t(pinf*nt1*pt)
                    call dsymm('l','u',m,m,1.0d0,pinf(:,:,t),m,nt2(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt2
                    call dsymm('r','u',m,m,-1.0d0,pinf(:,:,t),m,mm,m,1.0d0,nrec,m) !vvt = vvt - pinf*nt2*pinf
                    call dsymm('r','u',p,m,1.0d0,nrec,m,zorig(:,:,(t-1)*zorigtv+1),p,0.0d0,pm,p)
                    call dgemm('n','t',p,p,m,1.0d0,pm,p,zorig(:,:,(t-1)*zorigtv+1),p,0.0d0,thetahatvar(:,:,t),p)
                end do
                do t = d+1, n
                    call dcopy(m,at(:,t),1,rrec,1) !ahat = at
                    call dsymv('u',m,1.0d0,pt(:,:,t),m,rt(:,t),1,1.0d0,rrec,1) !ahat = ahat+pt*r_t-1
                    call dgemv('n',p,m,1.0d0,zorig(:,:,(t-1)*zorigtv+1),p,rrec,1,0.0d0,thetahat(:,t),1)
                    nrec = pt(:,:,t)
                    call dsymm('l','u',m,m,1.0d0,pt(:,:,t),m,nt(:,:,t),m,0.0d0,mm,m) !pt*n_t-1
                    call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,1.0d0,nrec,m) !pt*n_t-1*pt
                    call dsymm('r','u',p,m,1.0d0,nrec,m,zorig(:,:,(t-1)*zorigtv+1),p,0.0d0,pm,p)
                    call dgemm('n','t',p,p,m,1.0d0,pm,p,zorig(:,:,(t-1)*zorigtv+1),p,0.0d0,thetahatvar(:,:,t),p)
                end do
            end if
        else

            if(state .EQ. 1) then
                do t = 1, n
                    call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,ahat(:,t),1,0.0d0,thetahat(:,t),1)
                    call dsymm('r','u',p,m,1.0d0,vvt(:,:,t),m,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,pm,p)
                    call dgemm('n','t',p,p,m,1.0d0,pm,p,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,thetahatvar(:,:,t),p)
                end do
            else
                do t = 1, d
                    call dcopy(m,at(:,t),1,rrec,1) !ahat = at
                    call dsymv('u',m,1.0d0,pt(:,:,t),m,rt0(:,t),1,1.0d0,rrec,1) !ahat = at + pt * rt0_t
                    call dsymv('u',m,1.0d0,pinf(:,:,t),m,rt1(:,t),1,1.0d0,rrec,1) !ahat = at + pt * rt0_t + pinf*rt1_t
                    call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,rrec,1,0.0d0,thetahat(:,t),1)

                    nrec = pt(:,:,t)
                    call dsymm('l','u',m,m,1.0d0,pt(:,:,t),m,nt0(:,:,t),m,0.0d0,mm,m) !mm = pt*nt0
                    call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,1.0d0,nrec,m) !vvt = pt - pt*nt0*pt
                    call dsymm('l','u',m,m,1.0d0,pinf(:,:,t),m,nt1(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt1
                    call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,0.0d0,mm2,m) !mm2 = -pinf*nt1*pt
                    nrec = nrec + mm2 + transpose(mm2) !vvt = pt - pt*nt0*pt  -pinf*nt1*pt - t(pinf*nt1*pt)
                    call dsymm('l','u',m,m,1.0d0,pinf(:,:,t),m,nt2(:,:,t),m,0.0d0,mm,m) !mm = pinf*nt2
                    call dsymm('r','u',m,m,-1.0d0,pinf(:,:,t),m,mm,m,1.0d0,nrec,m) !vvt = vvt - pinf*nt2*pinf
                    call dsymm('r','u',p,m,1.0d0,nrec,m,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,pm,p)
                    call dgemm('n','t',p,p,m,1.0d0,pm,p,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,thetahatvar(:,:,t),p)
                end do
                do t = d+1, n
                    call dcopy(m,at(:,t),1,rrec,1) !ahat = at
                    call dsymv('u',m,1.0d0,pt(:,:,t),m,rt(:,t),1,1.0d0,rrec,1) !ahat = ahat+pt*r_t-1
                    call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,rrec,1,0.0d0,thetahat(:,t),1)
                    nrec = pt(:,:,t)
                    call dsymm('l','u',m,m,1.0d0,pt(:,:,t),m,nt(:,:,t),m,0.0d0,mm,m) !pt*n_t-1
                    call dsymm('r','u',m,m,-1.0d0,pt(:,:,t),m,mm,m,1.0d0,nrec,m) !pt*n_t-1*pt
                    call dsymm('r','u',p,m,1.0d0,nrec,m,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,pm,p)
                    call dgemm('n','t',p,p,m,1.0d0,pm,p,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,thetahatvar(:,:,t),p)
                end do
            end if
        end if
    end if

end subroutine gsmoothall

####$$$$ KFAS\src/init.c
#include <R.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>

#include "declarations.h"

static R_FortranMethodDef FortEntries[] = {
		{"fdeviance", (DL_FUNC) &F77_SUB(deviance), 8},
		{"fartransform", (DL_FUNC) &F77_SUB(artransform), 3},
		{"fldl", (DL_FUNC) &F77_SUB(ldl), 4},
		{"fldlssm", (DL_FUNC) &F77_SUB(ldlssm), 15},
		{"fsignaltheta", (DL_FUNC) &F77_SUB(signaltheta), 12},
		{"fapprox", (DL_FUNC) &F77_SUB(approx), 24},
		{"fgsmoothall", (DL_FUNC) &F77_SUB(gsmoothall), 44},
		{"fngsmooth", (DL_FUNC) &F77_SUB(ngsmooth), 39},
		{"fkfilter", (DL_FUNC) &F77_SUB(kfilter), 31},
		{"fglogliku", (DL_FUNC) &F77_SUB(glogliku), 17},
		{"fgloglik", (DL_FUNC) &F77_SUB(gloglik), 18},
		{"fngloglik", (DL_FUNC) &F77_SUB(ngloglik), 35},
		{"fisample", (DL_FUNC) &F77_SUB(isample), 35},
		{"fzalpha", (DL_FUNC) &F77_SUB(zalpha), 10},
		{"fvarmeanw", (DL_FUNC) &F77_SUB(varmeanw), 8},
		{"fsimfilter", (DL_FUNC) &F77_SUB(simfilter), 30},
		{"fngfilter", (DL_FUNC) &F77_SUB(ngfilter), 39},
		{"fisamplefilter", (DL_FUNC) &F77_SUB(isamplefilter), 35},
		{"fsimgaussian", (DL_FUNC) &F77_SUB(simgaussian), 30},
		{NULL, NULL, 0}
};

void R_init_KFAS(DllInfo *dll)
{
	R_registerRoutines(dll, NULL, NULL, FortEntries, NULL);
	R_useDynamicSymbols(dll, FALSE);
}
####$$$$ KFAS\src/isample.f95
! Importance sampling of the signal of non-gaussian model

subroutine isample(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, dist, &
p, n, m, r, theta, maxiter,rankp,convtol, nnd,nsim,epsplus,etaplus,&
aplus1,c,tol,info,antithetics,w,sim,nd,ndl,simwhat,simdim)


    implicit none

    integer, intent(in) ::  p,m, r, n,nnd,info,antithetics,nsim&
    ,ndl,simwhat,simdim
    integer, intent(in), dimension(p) :: dist
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(in), dimension(5) :: timevar
    integer, intent(inout) :: maxiter,rankp
    integer ::  t, j,i
    double precision, intent(in) :: convtol,tol
    double precision, intent(in), dimension(n,p) :: u
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in),dimension(nsim) :: c
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout), dimension(m,nsim) :: aplus1
    double precision, intent(inout), dimension(n,p) :: theta
    double precision, dimension(p,p,n) :: ht
    double precision, intent(inout), dimension(simdim,n,3 * nsim * antithetics + nsim) :: sim
    double precision, dimension(p,(3 * nsim * antithetics + nsim)*(5-simwhat)) :: tsim
    double precision, dimension(n,p) :: ytilde
    double precision, dimension(n,p) :: dn
    double precision, dimension(n) :: tmp
    double precision, dimension(3 * nsim * antithetics + nsim) :: w
    double precision :: diff
    double precision, external :: ddot

    ht=0.0d0

    ! approximate
    call approx(yt, ymiss, timevar, zt, tt, rtv, ht, qt, a1, p1,p1inf, p,n,m,r,&
    theta, u, ytilde, dist,maxiter,tol,rankp,convtol,diff)

    ! simulate signals
    call simgaussian(ymiss,timevar, ytilde, zt, ht, tt, rtv, qt, a1, p1, &
    p1inf, nnd,nsim, epsplus, etaplus, aplus1, p, n, m, r, info,rankp,&
    tol,nd,ndl,sim,c,simwhat,simdim,antithetics)


    ! compute importance weights

    where(ymiss .EQ. 0) dn=(ytilde-theta)**2
    w=1.0d0

    if(simwhat==5) then
        do j=1,p
            select case(dist(j))
                case(2)    !poisson
                    tmp = exp(theta(:,j))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then

                            w = w*exp(yt(t,j)*(sim(j,t,:)-theta(t,j))-&
                            u(t,j)*(exp(sim(j,t,:))-tmp(t)))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim(j,t,:))**2 - dn(t,j)))
                     
                        end if
                    end do
                case(3) !binomial
                    tmp = log(1.0d0+exp(theta(:,j)))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                       
                            w = w*exp( yt(t,j)*(sim(j,t,:)-theta(t,j))-&
                            u(t,j)*(log(1.0d0+exp(sim(j,t,:)))-tmp(t)))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim(j,t,:))**2 -dn(t,j)))
                     
                        end if
                    end do
                case(4) ! gamma
                    tmp = exp(-theta(:,j))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                            w = w*exp( u(t,j)*(yt(t,j)*(tmp(t)-exp(-sim(j,t,:)))+theta(t,j)-sim(j,t,:)))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim(j,t,:))**2 -dn(t,j)))
                        end if
                    end do
                case(5) !negbin
                    tmp = exp(theta(:,j))
                    !tmp = u(t,j)/(u(t,j)+exp(theta(:,j)))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                            w = w*exp(yt(t,j)*(sim(j,t,:)-theta(t,j)) +&
                            (yt(t,j)+u(t,j))*log((u(t,j)+tmp(t))/(u(t,j)+exp(sim(j,t,:)))))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim(j,t,:))**2 -dn(t,j)))
                            !w = w*((u(t,j)+exp(sim(j,t,:)))/(u(t,j)+tmp(t)))**u(t,j)*&
                            !(exp(sim(j,t,:))/(exp(sim(j,t,:))+u(t,j)))**yt(t,j)&
                            !*(tmp/(tmp+u(t,j)))**(-yt(t,j))/&
                            !w = w*(exp(sim(j,t,:)-theta(:,j)))**yt(t,j)*&
                            !      ((tmp+u(t,j))/(exp(sim(j,t,:))+u(t,j)))**(u(t,j)+yt(t,j))/&
                            !ps = u(t,j)/(u(t,j)+exp(sim(j,t,:)))
                            !w= w*(ps/tmp)**u(t,j)*((1.0d0-ps)/(1.0d0-tmp))**yt(t,j)/&

                        end if
                    end do
            end select
        end do

    else
        do j=1,p
            select case(dist(j))
                case(2)    !poisson
                    tmp = exp(theta(:,j))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                            do i=1,3 * nsim * antithetics + nsim
                                tsim(j,i) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim(:,t,i),1)
                            end do
                            w = w*exp(yt(t,j)*(tsim(j,:)-theta(t,j))-&
                            u(t,j)*(exp(tsim(j,:))-tmp(t)))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 - dn(t,j)))

                        end if
                    end do
                case(3) !binomial
                    tmp = log(1.0d0+exp(theta(:,j)))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                            do i=1,3 * nsim * antithetics + nsim
                                tsim(j,i) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim(:,t,i),1)
                            end do
                            w = w*exp( yt(t,j)*(tsim(j,:)-theta(t,j))-&
                            u(t,j)*(log(1.0d0+exp(tsim(j,:)))-tmp(t)))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 -dn(t,j)))

                        end if
                    end do
                case(4) ! gamma
                    tmp = exp(-theta(:,j))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                            do i=1,3 * nsim * antithetics + nsim
                                tsim(j,i) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim(:,t,i),1)
                            end do
                            w = w*exp( u(t,j)*(yt(t,j)*(tmp(t)-exp(-tsim(j,:)))+theta(t,j)-tsim(j,:)))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 -dn(t,j)))
                        end if
                    end do
                case(5) !negbin
                    tmp = exp(theta(:,j))
                    do t=1,n
                        if(ymiss(t,j) .EQ. 0) then
                            do i=1,3 * nsim * antithetics + nsim
                                tsim(j,i) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim(:,t,i),1)
                            end do
                            w = w*exp(yt(t,j)*(tsim(j,:)-theta(t,j)) +&
                            (yt(t,j)+u(t,j))*log((u(t,j)+tmp(t))/(u(t,j)+exp(tsim(j,:)))))/&
                            exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 -dn(t,j)))
                            !w = w*((u(t,j)+exp(tsim(j,:)))/(u(t,j)+tmp(t)))**u(t,j)*&
                            !(exp(tsim(j,:))/(exp(tsim(j,:))+u(t,j)))**yt(t,j)&
                            !*(tmp/(tmp+u(t,j)))**(-yt(t,j))/&
                        end if
                    end do
            end select
        end do


    end if



end subroutine isample
####$$$$ KFAS\src/isamplefilter.f95
! Importance sampling of the signal of non-gaussian model

subroutine isamplefilter(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, dist, &
p, n, m, r, theta, maxiter,rankp,convtol, nnd,nsim,epsplus,etaplus,&
aplus1,c,tol,info,antithetics,w,sim,nd,ndl,simwhat,simdim)

    implicit none

    integer, intent(in) ::  p,m, r, n,nnd,info,antithetics,nsim&
    ,ndl,simwhat,simdim
    integer, intent(in), dimension(p) :: dist
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(in), dimension(5) :: timevar
    integer, intent(inout) :: maxiter,rankp
    integer ::  t, j,i,rankp2,k,maxiter2,maxitermax
    double precision, intent(in) :: convtol,tol
    double precision, intent(in), dimension(n,p) :: u
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in),dimension(nsim) :: c
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout), dimension(m,nsim) :: aplus1
    double precision, intent(inout), dimension(n,p) :: theta
    double precision, dimension(p,p,n) :: ht
    double precision, intent(inout), dimension(simdim,n,3 * nsim * antithetics + nsim) :: sim
    double precision, dimension(p,(3 * nsim * antithetics + nsim)*(5-simwhat)) :: tsim
    double precision, dimension(n,p) :: ytilde
    double precision, dimension(n,p) :: dn
    double precision, dimension(n) :: tmp
    double precision, dimension(n,3 * nsim * antithetics + nsim) :: w
    double precision, external :: ddot

    integer, dimension(n,p) :: ymiss2
    double precision, dimension(p,n,nsim) :: epsplus2
    double precision, dimension(r,n,nsim) :: etaplus2
    double precision, dimension(m,nsim) :: aplus12
    double precision, dimension(simdim,n,3 * nsim * antithetics + nsim) :: sim2
    double precision :: diff

    ht=0.0d0
    ytilde=0.0d0
    w=1.0d0
    rankp2=rankp
    epsplus2 = epsplus
    etaplus2 = etaplus
    aplus12  = aplus1
    ymiss2 = ymiss
    ymiss2(1,:) = 1

    call simgaussian(ymiss2(1,:),timevar, ytilde(1,:), zt(:,:,1), &
    ht(:,:,1), tt(:,:,1), rtv(:,:,1), &
    qt(:,:,1), a1, p1, p1inf, nnd,nsim, epsplus2(:,1,:), etaplus2(:,1,:), aplus12(:,:), &
    p, 1, m, r, info,rankp2,tol,nd,ndl,sim(:,1,:),c,simwhat,simdim,antithetics)

    maxitermax = 0
    do i=1,(n-1)
        ht=0.0d0
        ytilde=0.0d0
        rankp2=rankp
        maxiter2=maxiter
        ! approximate
        call approx(yt(1:i,:), ymiss(1:i,:), timevar, zt(:,:,1:((i-1)*timevar(1)+1)), &
        tt(:,:,1:((i-1)*timevar(3)+1)), rtv(:,:,1:((i-1)*timevar(4)+1)), ht(:,:,1:i),&
        qt(:,:,1:((i-1)*timevar(5)+1)), a1, p1,p1inf, p,i,m,r,&
        theta(1:i,:), u(1:i,:), ytilde(1:i,:), dist,maxiter2,tol,rankp2,convtol,diff)
        if(maxiter2>maxitermax) then
            maxitermax = maxiter2
        end if
        rankp2=rankp
        epsplus2 = epsplus
        etaplus2 = etaplus
        aplus12  = aplus1
        ymiss2 = ymiss
        ymiss2(i+1,:) = 1
        sim2=0.0d0
        ! simulate signals
        call simgaussian(ymiss2(1:(i+1),:),timevar, ytilde(1:(i+1),:), zt(:,:,1:(i*timevar(1)+1)), &
        ht(:,:,1:(i+1)), tt(:,:,1:(i*timevar(3)+1)), rtv(:,:,1:(i*timevar(4)+1)), &
        qt(:,:,1:(i*timevar(5)+1)), a1, p1, p1inf, nnd,nsim, epsplus2(:,1:(i+1),:), &
        etaplus2(:,1:(i+1),:), aplus12(:,:),p, i+1, m, r, info,rankp2,tol,&
        nd,ndl,sim2(:,1:(i+1),:),c,simwhat,simdim,antithetics)

        !do t=1,n
        !   do j=1,p
         !       theta(t,j) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,at(:,t),1)
        !    end do
        !end do

        ! compute importance weights

        where(ymiss2(1:i,:) .EQ. 0) dn=(ytilde(1:i,:)-theta(1:i,:))**2


        if(simwhat==5) then
            do j=1,p
                select case(dist(j))
                    case(2)    !poisson
                        tmp = exp(theta(1:i,j))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                w(i+1,:) = w(i+1,:)*exp(yt(t,j)*(sim2(j,t,:)-theta(t,j))-&
                                u(t,j)*(exp(sim2(j,t,:))-tmp(t)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim2(j,t,:))**2 - dn(t,j)))
                            end if
                        end do
                    case(3) !binomial
                        tmp = log(1.0d0+exp(theta(1:i,j)))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                       
                                w(i+1,:) = w(i+1,:)*exp( yt(t,j)*(sim2(j,t,:)-theta(t,j))-&
                                u(t,j)*(log(1.0d0+exp(sim2(j,t,:)))-tmp(t)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim2(j,t,:))**2 -dn(t,j)))
                     
                            end if
                        end do
                    case(4) ! gamma
                        tmp = exp(-theta(1:i,j))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                w(i+1,:) = w(i+1,:)*exp( u(t,j)*(yt(t,j)*(tmp(t)-exp(-sim2(j,t,:)))&
                                +theta(t,j)-sim2(j,t,:)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim2(j,t,:))**2 -dn(t,j)))
                            end if
                        end do
                    case(5) !negbin
                        tmp = exp(theta(1:i,j))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                w(i+1,:) = w(i+1,:)*exp(yt(t,j)*(sim2(j,t,:)-theta(t,j)) +&
                                (yt(t,j)+u(t,j))*log((u(t,j)+tmp(t))/(u(t,j)+exp(sim2(j,t,:)))))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-sim2(j,t,:))**2 -dn(t,j)))
                            end if
                        end do
                end select
            end do

        else
            do j=1,p
                select case(dist(j))
                    case(2)    !poisson
                        tmp = exp(theta(1:i,j))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                do k=1,3 * nsim * antithetics + nsim
                                    tsim(j,k) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim2(:,t,k),1)
                                end do
                                w(i+1,:) = w(i+1,:)*exp(yt(t,j)*(tsim(j,:)-theta(t,j))-&
                                u(t,j)*(exp(tsim(j,:))-tmp(t)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 - dn(t,j)))

                            end if
                        end do
                    case(3) !binomial
                        tmp = log(1.0d0+exp(theta(1:i,j)))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                do k=1,3 * nsim * antithetics + nsim
                                    tsim(j,k) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim2(:,t,k),1)
                                end do
                                w(i+1,:) = w(i+1,:)*exp( yt(t,j)*(tsim(j,:)-theta(t,j))-&
                                u(t,j)*(log(1.0d0+exp(tsim(j,:)))-tmp(t)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 -dn(t,j)))

                            end if
                        end do
                    case(4) ! gamma
                        tmp = exp(-theta(1:i,j))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                do k=1,3 * nsim * antithetics + nsim
                                    tsim(j,k) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim2(:,t,k),1)
                                end do
                                w(i+1,:) = w(i+1,:)*exp( u(t,j)*(yt(t,j)*(tmp(t)-exp(-tsim(j,:)))+theta(t,j)-tsim(j,:)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 -dn(t,j)))
                            end if
                        end do
                    case(5) !negbin
                        tmp = exp(theta(1:i,j))
                        do t=1,i
                            if(ymiss2(t,j) .EQ. 0) then
                                do k=1,3 * nsim * antithetics + nsim
                                    tsim(j,k) = ddot(m,zt(j,:,(t-1)*timevar(1)+1),1,sim2(:,t,k),1)
                                end do
                                w(i+1,:) = w(i+1,:)*exp(yt(t,j)*(tsim(j,:)-theta(t,j)) +&
                                (yt(t,j)+u(t,j))*log((u(t,j)+tmp(t))/(u(t,j)+exp(tsim(j,:)))))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,:))**2 -dn(t,j)))
                            end if
                        end do
                end select
            end do
        end if
        sim(:,i+1,:) = sim2(:,i+1,:)
    end do
    maxiter=maxitermax
end subroutine isamplefilter
####$$$$ KFAS\src/kfilter.f95
    ! Subroutine for Kalman filtering of linear gaussian state space model

subroutine kfilter(yt, ymiss, timevar, zt, ht,tt, rt, qt, a1, p1, p1inf, p,n,m,r,d,j,&
at, pt, vt, ft,kt, pinf, finf, kinf, lik, tol,rankp,theta,thetavar,filtersignal)

    implicit none

    integer, intent(in) :: p, m, r, n,filtersignal
    integer, intent(inout) :: d, j, rankp
    integer :: t, i
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rt
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) :: p1,p1inf
    double precision, intent(in) :: tol
    double precision, intent(inout), dimension(m,n+1) :: at
    double precision, intent(inout), dimension(m,m,n+1) :: pt,pinf
    double precision, intent(inout), dimension(p,n) :: vt,ft,finf
    double precision, intent(inout), dimension(m,p,n) :: kt,kinf
    double precision, intent(inout) :: lik
    double precision, intent(inout), dimension(p,p,n) :: thetavar
    double precision, intent(inout), dimension(n,p) :: theta
    double precision, dimension(m) :: arec
    double precision, dimension(m,m) ::pirec,im,mm,prec
    double precision, dimension(m,r) :: mr
    double precision, dimension(p,m) :: pm
    double precision :: c
    double precision, external :: ddot
    double precision :: meps,finv

    meps = tiny(meps) !was epsilon!

    c = 0.5d0*log(8.0d0*atan(1.0d0))

    lik = 0.0d0

    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do
    j=0
    d=0
    pinf(:,:,1)=p1inf

    ! diffuse initialization

    if(rankp > 0) then

        pt(:,:,1) = p1
        prec = pt(:,:,1)
        pirec = pinf(:,:,1)
        at(:,1) = a1
        arec = a1
        diffuse: do while(d < n .AND. rankp > 0)
            d = d+1
            do j=1, p
                call dsymv('u',m,1.0d0,prec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,j,d),1)
                ft(j,d) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kt(:,j,d),1) + ht(j,j,(d-1)*timevar(2)+1)
                if(ymiss(d,j) .EQ. 0) then
                    call dsymv('u',m,1.0d0,pirec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kinf(:,j,d),1) ! kinf_t,i = pinf_t,i*t(z_t,i)
                    finf(j,d) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kinf(:,j,d),1)

                    vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1)
                    if (finf(j,d) .GT. tol) then
                        finv = 1.0d0/finf(j,d)
                        arec = arec + kinf(:,j,d)*finv*vt(j,d)
                        call dsyr('u',m,ft(j,d)*finv**2,kinf(:,j,d),1,prec,m) !prec = prec + kinf*kinf'*ft/finf^2
                        call dsyr2('u',m,-finv,kt(:,j,d),1,kinf(:,j,d),1,prec,m) !prec = prec -(kt*kinf'+kinf*kt')/finf
                        call dsyr('u',m,-finv,kinf(:,j,d),1,pirec,m) !pirec = pirec -kinf*kinf'/finf

                        lik = lik - 0.5d0*log(finf(j,d))
                        rankp = rankp -1

                        do i = 1, m
                            if(pirec(i,i) < tol) then
                                pirec(i,:) = 0.0d0
                                pirec(:,i) = 0.0d0
                            end if
                        end do
                    else
                        finf(j,d) = 0.0d0
                        if(ft(j,d) > meps) then
                            finv = 1.0d0/ft(j,d)
                            call daxpy(m,vt(j,d)*finv,kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                            call dsyr('u',m,-finv,kt(:,j,d),1,prec,m) !prec = prec -kt*kt'/ft
                            lik = lik - 0.5d0*(log(ft(j,d)) + vt(j,d)**2*finv)

                        end if
                    end if
                    if (ft(j,d) > meps) then
                        lik = lik -c
                    else
                        ft(j,d)=0.0d0
                    end if
                    if(rankp .EQ. 0) then
                        exit diffuse
                    end if
                end if
            end do

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:,d+1),1)
            arec = at(:,d+1)
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt(:,:,d+1),m)

            if(r.GT.1) then
                call dsymm('r','u',m,r,1.0d0,qt(:,:,(d-1)*timevar(5)+1),r,rt(:,:,(d-1)*timevar(4)+1),m,0.0d0,mr,m)
                call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(d-1)*timevar(4)+1),m,1.0d0,pt(:,:,d+1),m)
            else
                call dsyr('u',m,qt(1,1,(d-1)*timevar(5)+1),rt(:,1,(d-1)*timevar(4)+1),1,pt(:,:,d+1),m)
            end if
            prec = pt(:,:,d+1)
            call dsymm('r','u',m,m,1.0d0,pirec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pinf(:,:,d+1),m)
            pirec = pinf(:,:,d+1)

        end do diffuse


        if(rankp .EQ. 0) then
                !non-diffuse filtering begins
            do i = j+1, p
                call dsymv('u',m,1.0d0,prec,m,zt(i,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,i,d),1)
                ft(i,d) = ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,kt(:,i,d),1) + ht(i,i,(d-1)*timevar(2)+1)
                if(ymiss(d,i).EQ.0) then
                    vt(i,d) = yt(d,i) - ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,arec,1) !vt
                    if (ft(i,d) .GT. meps) then
                        arec = arec + kt(:,i,d)*vt(i,d)/ft(i,d)
                        call dsyr('u',m,-1.0d0/ft(i,d),kt(:,i,d),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,t)
                        lik = lik - 0.5d0*(log(ft(i,d)) + vt(i,d)**2/ft(i,d))-c
                    else
                        ft(i,d)=0.0d0
                    end if
                end if
            end do

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:,d+1),1)
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt(:,:,d+1),m)

            if(r.GT.1) then
                call dsymm('r','u',m,r,1.0d0,qt(:,:,(d-1)*timevar(5)+1),r,rt(:,:,(d-1)*timevar(4)+1),m,0.0d0,mr,m)
                call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(d-1)*timevar(4)+1),m,1.0d0,pt(:,:,d+1),m)
            else
                call dsyr('u',m,qt(1,1,(d-1)*timevar(5)+1),rt(:,1,(d-1)*timevar(4)+1),1,pt(:,:,d+1),m)

               ! call dger(m,m,qt(1,1,(d-1)*timevar(5)+1),rt(:,1,(d-1)*timevar(4)+1),1,rt(:,1,(d-1)*timevar(4)+1),1,&
               ! pt(:,:,d+1),m)
            end if

            arec = at(:,d+1)
            prec = pt(:,:,d+1)
        end if
    end if

    !Non-diffuse filtering continues from t=d+1, i=1


    if(d.EQ.0) then
        prec = p1
        arec = a1
        at(:,1) = a1
        pt(:,:,1) = p1
    else
        if(d .EQ. n .AND. j .EQ. p+1) then
            j = p
        end if
    end if
    do t = d+1, n
        do i = 1, p
            call dsymv('u',m,1.0d0,prec,m,zt(i,:,(t-1)*timevar(1)+1),1,0.0d0,kt(:,i,t),1)

            ft(i,t) = ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,kt(:,i,t),1) + ht(i,i,(t-1)*timevar(2)+1)
            if(ymiss(t,i).EQ.0) then
                vt(i,t) = yt(t,i) - ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,arec,1)
                if (ft(i,t) .GT. meps) then
                    arec = arec + kt(:,i,t)/ft(i,t)*vt(i,t)
                    call dsyr('u',m,-1.0d0/ft(i,t),kt(:,i,t),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,i,t)
                    lik = lik - 0.5d0*(log(ft(i,t)) + vt(i,t)**2/ft(i,t))-c
                else
                    ft(i,t)=0.0d0
                end if
            end if
        end do

        call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,at(:,t+1),1)

        call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,mm,m)
        call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,pt(:,:,t+1),m)
        !call dgemm('n','n',m,m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,prec,m,0.0d0,mm,m)
        !call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,pt(:,:,t+1),m)

        if(r.GT.1) then
            call dsymm('r','u',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rt(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
            call dgemm('n','t',m,m,r,1.0d0,mr,m,rt(:,:,(t-1)*timevar(4)+1),m,1.0d0,pt(:,:,t+1),m)
        else
            !   call dger(m,m,qt(1,1,(t-1)*timevar(5)+1),rt(:,1,(t-1)*timevar(4)+1),1,rt(:,1,(t-1)*timevar(4)+1),&
            !   1,pt(:,:,t+1),m)
            call dsyr('u',m,qt(1,1,(t-1)*timevar(5)+1),rt(:,1,(t-1)*timevar(4)+1),1,pt(:,:,t+1),m)
        end if

        arec = at(:,t+1)
        prec = pt(:,:,t+1)
    end do

    if(filtersignal==1) then
        do t = 1, n
            call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,at(:,t),1,0.0d0,theta(t,:),1)
            call dsymm('r','u',p,m,1.0d0,pt(:,:,t),m,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,pm,p)
            call dgemm('n','t',p,p,m,1.0d0,pm,p,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,thetavar(:,:,t),p)
        end do
    end if

    if(m > 1) then
        do t=1, n
            do i=1,m-1
                pt((i+1):m,i,t) =pt(i,(i+1):m,t)
            end do
            ! pt(:,:,t) =(pt(:,:,t)+transpose(pt(:,:,t)))/2.0d0
        end do
        if(d>0) then
            do t=1, d
                do i=1,m-1
                    pinf((i+1):m,i,t) =pinf(i,(i+1):m,t)
                end do
            !pinf(:,:,t) =(pinf(:,:,t)+transpose(pinf(:,:,t)))/2.0d0
            end do
        end if
    end if
end subroutine kfilter
####$$$$ KFAS\src/kfstheta.f95
! signal smoothing algorithm for simulation
subroutine kfstheta(yt, ymiss, timevar, zt, ht,tt, rtv,qt,rqr, a1, p1, p1inf, &
p, n, m, r,tol,rankp,thetahat)

    implicit none

    integer, intent(in) ::  p, m, n,r
    integer, intent(inout) :: rankp
    integer ::  t, i,tv,d, j
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, dimension(m,m,(n-1)*max(timevar(4),timevar(5))+1) :: rqr
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, dimension(p,n) :: ft,finf
    double precision, dimension(m,p,n) :: kt,kinf
    double precision, dimension(p,n) :: vt
    double precision, dimension(m) :: at, arec
    double precision, dimension(m,m) :: prec,pirec,mm,pinf,pt
    double precision, intent(in) :: tol
    double precision, dimension(m) :: rrec,rrec1,rhelp,help
    double precision, dimension(m,m) :: im,linf,l0,lt
    double precision, dimension(r,n) :: etahat
    double precision :: meps
    double precision, external :: ddot
double precision, intent(inout), dimension(n,p) :: thetahat

    meps = tiny(meps)
    tv = max(timevar(4),timevar(5))
    pinf = p1inf
    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do
    j=0
    d=0
    if(maxval(pinf) .GT.  0.0d0) then

        pt = p1
        prec = pt
        pirec = pinf
        at(:) = a1
        arec = a1
        diffuse: do while(d .LT. n)
            d = d+1
            do j=1, p
                if(ymiss(d,j).EQ.0) then

                    vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1) !arec
                    call dsymv('u',m,1.0d0,prec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,j,d),1) ! kt_t,i = pt_t,i*t(z_t,i)
                    ft(j,d) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kt(:,j,d),1)  + ht(j,j,(d-1)*timevar(2)+1)

                    call dsymv('u',m,1.0d0,pirec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kinf(:,j,d),1) ! kinf_t,i = pinf_t,i*t(z_t,i)
                    finf(j,d) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kinf(:,j,d),1)! finf


                    if (finf(j,d) .GT. tol) then
                        call daxpy(m,vt(j,d)/finf(j,d),kinf(:,j,d),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                        call dsyr('u',m,ft(j,d)/(finf(j,d)**2),kinf(:,j,d),1,prec,m) !prec = prec +  kinf*kinf'*ft/finf^2
                        call dsyr2('u',m,-1.0d0/finf(j,d),kt(:,j,d),1,kinf(:,j,d),1,prec,m) !prec = prec -(kt*kinf'+kinf*kt')/finf
                        !call dger(m,m,(-1.0d0/finf(j,d)),kinf(:,j,d),1,kinf(:,j,d),1,pirec,m)
                        call dsyr('u',m,(-1.0d0/finf(j,d)),kinf(:,j,d),1,pirec,m) !pirec = pirec -kinf*kinf'/finf

                        rankp = rankp -1
                        do i = 1, m
                            if(pirec(i,i) .LT. tol) then
                                pirec(i,:) = 0.0d0
                                pirec(:,i) = 0.0d0
                            end if
                        end do
                    else
                        finf(j,d) = 0.0d0
                        if(ft(j,d) .GT.  meps) then
                            call daxpy(m,vt(j,d)/ft(j,d),kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                            call dsyr('u',m,(-1.0d0)/ft(j,d),kt(:,j,d),1,prec,m) !prec = prec -kt*kt'/ft
                        else
                            ft(j,d)=0.0d0
                        end if
                    end if

                    if(rankp .EQ. 0) then
                        exit diffuse
                    end if
                end if
            end do

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)
            call dcopy(m,at(:),1,arec,1) ! a_rec = at(:,t+1)
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)

            pt = pt + rqr(:,:,(d-1)*tv+1)

            prec = pt
            call dsymm('r','u',m,m,1.0d0,pirec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pinf,m)
            pirec = pinf


        end do diffuse

        !non-diffuse filtering begins
        if(rankp .EQ. 0) then
            do i = j+1, p
                if(ymiss(d,i).EQ.0) then
                    vt(i,d) = yt(d,i) - ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,arec,1) !vt
                    call dsymv('u',m,1.0d0,prec,m,zt(i,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,i,d),1) ! p symmetric!
                    ft(i,d) = ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,kt(:,i,d),1)  +  ht(i,i,(d-1)*timevar(2)+1)
                    if (ft(i,d) .GT.  meps) then
                        call daxpy(m,vt(i,d)/ft(i,d),kt(:,i,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                        call dsyr('u',m,-1.0d0/ft(i,d),kt(:,i,d),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,t)
                    else
                        ft(i,d)=0.0d0
                    end if
                end if
            end do

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)

            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)

            pt = pt + rqr(:,:,(d-1)*tv+1)


            call dcopy(m,at(:),1,arec,1) ! a_rec =at(:,t+1)
            prec = pt
        end if
    end if

    !Non-diffuse filtering continues from t=d+1, i=1


    if(d.EQ.0) then
        prec = p1
        arec = a1!   call dcopy(m,a1,1,arec,1)
        at(:) = a1 !call dcopy(m,a1,1,at(:,1),1) !at(:,1) = a1
        pt = p1
    else
        if(d .EQ. n .AND. j .EQ. p+1) then
            j = p
        end if
    end if
    do t = d+1, n
        do i = 1, p
            if(ymiss(t,i).EQ.0) then
                vt(i,t) = yt(t,i) - ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,arec,1)
                call dsymv('u',m,1.0d0,prec,m,zt(i,:,(t-1)*timevar(1)+1),1,0.0d0,kt(:,i,t),1)
                ft(i,t) = ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,kt(:,i,t),1) +  ht(i,i,(t-1)*timevar(2)+1)
                if (ft(i,t) .GT.  meps) then
                    call daxpy(m,vt(i,t)/ft(i,t),kt(:,i,t),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                    call dsyr('u',m,-1.0d0/ft(i,t),kt(:,i,t),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,i,t)
                else
                    ft(i,t)=0.0d0
                end if

            end if
        end do

        call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)
        call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,mm,m)
        call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,pt,m)

        pt = pt + rqr(:,:,(t-1)*tv+1)

        call dcopy(m,at(:),1,arec,1) ! a_rec =at(:,t+1)
        prec = pt
    end do

    !smoothing begins

    rrec = 0.0d0

    do t = n, d+1, -1
        call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
        call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
        call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1) !r_t,p=t_t-1'*r_t+1
        rrec = rhelp
        do i = p, 1 , -1
            if(ymiss(t,i)==0) then
                if(ft(i,t) >  meps) then
                    lt = im
                    call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !l = I -kz
                    call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                    rrec = rhelp + vt(i,t)/ft(i,t)*zt(i,:,(t-1)*timevar(1)+1)
                end if
            end if
        end do
    end do

    if(d.GT.0) then
        t=d
        call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
        call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
        call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
        rrec = rhelp
        do i = p, (j+1) , -1
            if(ymiss(t,i).EQ.0) then
                if(ft(i,t) .GT.  meps) then
                    lt = im
                    call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !l = i -kz
                    call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                    rrec=rhelp
                    call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1)
                end if
            end if
        end do
        rrec1 = 0.0d0
        do i = j, 1, -1
            if(ymiss(t,i).EQ.0) then
                if(finf(i,t).GT. tol) then
                    linf = im
                    call dger(m,m,-1.0d0/finf(i,t),kinf(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,linf,m) !linf
                    rhelp = -kt(:,i,t)
                    call daxpy(m,ft(i,t)/finf(i,t),kinf(:,i,t),1,rhelp,1)
                    l0=0.0d0
                    call dger(m,m,(1.0d0/finf(i,t)),rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0
                    call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                    call dcopy(m,rhelp,1,rrec1,1)
                    call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                    call daxpy(m,(vt(i,t)/finf(i,t)),zt(i,:,(t-1)*timevar(1)+1),1,rrec1,1)
                    call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                    rrec = rhelp
                else
                    if(ft(i,t).GT. meps) then
                        lt= im
                        call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !lt = I -Kt*Z/Ft
                        call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                        rrec = rhelp
                        call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1) !r0 = Z'vt/Ft - Lt'r0
                        call dgemv('t',m,m,1.0d0,lt,m,rrec1,1,0.0d0,rhelp,1)
                        rrec1=rhelp
                    end if
                end if
            end if
        end do

        do t=(d-1), 1, -1
            call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
            call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
            rrec = rhelp
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec1,1,0.0d0,rhelp,1,1)
            rrec1 = rhelp

            do i = p, 1, -1
                if(ymiss(t,i).EQ.0) then
                    if(finf(i,t).GT. tol) then
                        linf = im
                        call dger(m,m,-1.0d0/finf(i,t),kinf(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,linf,m) !linf
                        rhelp = -kt(:,i,t)
                        call daxpy(m,ft(i,t)/finf(i,t),kinf(:,i,t),1,rhelp,1)
                        l0=0.0d0
                        call dger(m,m,(1.0d0/finf(i,t)),rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0
                        call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                        call dcopy(m,rhelp,1,rrec1,1)
                        call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                        call daxpy(m,vt(i,t)/finf(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec1,1)
                        call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                        rrec = rhelp
                    else
                        if(ft(i,t).GT.  meps) then
                            lt= im
                            call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !lt = I -Kt*Z/Ft
                            call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                            rrec = rhelp
                            call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1) !r0 = Z'vt/Ft - Lt'r0
                            call dgemv('t',m,m,1.0d0,lt,m,rrec1,1,0.0d0,rhelp,1)
                            rrec1=rhelp

                        end if

                    end if
                end if
            end do

        end do
    end if


    at = a1

    call dsymv('l',m,1.0d0,p1,m,rrec,1,1.0d0,at,1)
    if(d .GT. 0) then
        call dsymv('l',m,1.0d0,p1inf,m,rrec1,1,1.0d0,at,1)
    end if
    call dgemv('n',p,m,1.0d0,zt(:,:,1),p,at,1,0.0d0,thetahat(1,:),1)

    do t = 2, n

        call dgemv('n',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,at,1,0.0d0,help,1)
        at=help
        call dgemv('n',m,r,1.0d0,rtv(:,:,(t-2)*timevar(4)+1),m,etahat(:,t-1),1,1.0d0,at,1)
        call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,at,1,0.0d0,thetahat(t,:),1)

    end do


end subroutine kfstheta
####$$$$ KFAS\src/ldl.f95
! LDL decomposition
subroutine ldl(a,n,tol,info)
  
    implicit none
  
    integer, intent(in) :: n
    integer, intent(inout) :: info
    integer :: i,j,k
    double precision :: di,tmp
    double precision, intent(inout), dimension(n,n) :: a
    double precision, intent(in) :: tol

    do i = 1, n
        di=a(i,i)
        if(abs(di)<=tol) then
            !a(i,:) = 0.0d0
            a(:,i) = 0.0d0
        else
            do j = i+1, n
                tmp = a(j,i)/di
                a(j,i) = tmp
                a(j,j) = a(j,j) - tmp**2*di
                do k = j+1, n
                    a(k,j) = a(k,j) - tmp*a(k,i)
                end do
            end do
        end if
    end do
    do i = 1,n
        a(i,(i+1):n) = 0.0d0
        if(a(i,i)<0.0d0) then
            info = -1
        end if
    end do

end subroutine ldl
####$$$$ KFAS\src/ldlssm.f95
! Transform multivariate model using LDL decomposition of H
subroutine ldlssm(yt, ydimt, yobs, timevar, zt, p, m, n, ichols,nh,hchol,dim,info,hobs,tol)

    implicit none

    integer, intent(in) ::  p, m, n,nh
    integer, intent(in), dimension(nh) ::  dim
    integer, intent(in), dimension(p,nh) :: hobs
    integer, intent(in), dimension(n) :: ydimt
    integer, intent(in), dimension(p,n) :: yobs
    integer, intent(in), dimension(5) :: timevar
    integer, intent(inout), dimension(n) :: hchol
    integer, intent(inout) :: info
    integer, dimension(nh) :: hdiagtest
    integer ::  t, i, k
    double precision, intent(inout), dimension(p,p,nh) :: ichols
    double precision, intent(inout), dimension(p,n) :: yt
    double precision, intent(inout), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in) :: tol
    double precision, dimension(p,p) :: cholhelp
    double precision, dimension(p) :: yhelp
    double precision, dimension(p,m) :: zhelp

    double precision, external :: ddot

    hdiagtest = 0

    info=0

    if(p.GT.1) then !testing diagonality
        do t= 1, nh
            test: do i = 1, dim(t)
                do k = i+1, dim(t)
                    if(abs(ichols(hobs(k,t),hobs(i,t),t)) .GT. tol) then
                        hdiagtest(t)=1
                        exit test
                    end if
                end do
            end do test
        end do
        if(sum(hdiagtest).NE.0) then
            do i = 1, nh
                if(hdiagtest(i).EQ.1) then
                    cholhelp(1:dim(i),1:dim(i)) = ichols(hobs(1:dim(i),i),hobs(1:dim(i),i),i)
                    call ldl(cholhelp(1:dim(i),1:dim(i)),dim(i),tol,info)
                    if(info .EQ. -1) then
                        info=1
                        return
                    end if
                    call dtrtri('l','u',dim(i),cholhelp(1:dim(i),1:dim(i)),dim(i),info)
                    if(info .NE. 0) then
                        info=2
                        return
                    end if
                    ichols(hobs(1:dim(i),i),hobs(1:dim(i),i),i) = cholhelp(1:dim(i),1:dim(i))
               end if

            end do
      
            do t = 1,(n-1)*max(timevar(1),timevar(2))+1
                if(ydimt(t).GT.0 .AND. hdiagtest(hchol(t)).NE.0) then
                    cholhelp(1:ydimt(t),1:ydimt(t)) = ichols(yobs(1:ydimt(t),t),yobs(1:ydimt(t),t),hchol(t))
                    zhelp(1:ydimt(t),:) = zt(yobs(1:ydimt(t),t),:,(t-1)*timevar(1)+1)
                    call dtrmm('l','l','n','u',ydimt(t),m,1.0d0,cholhelp(1:ydimt(t),1:ydimt(t)),&
                    ydimt(t),zhelp(1:ydimt(t),:),ydimt(t))
                    zt(yobs(1:ydimt(t),t),:,(t-1)*timevar(1)+1) = zhelp(1:ydimt(t),:)
            
                end if
            end do
            do t= 1, n
                if(ydimt(t).GT.0  .AND. hdiagtest(hchol(t)).NE.0) then
                    cholhelp(1:ydimt(t),1:ydimt(t)) = ichols(yobs(1:ydimt(t),t),yobs(1:ydimt(t),t),hchol(t))
                    yhelp(1:ydimt(t)) = yt(yobs(1:ydimt(t),t),t)
                    call dtrmv('l','n','u',ydimt(t),cholhelp(1:ydimt(t),1:ydimt(t)),ydimt(t),yhelp(1:ydimt(t)),1)
                    yt(yobs(1:ydimt(t),t),t) = yhelp(1:ydimt(t))
                end if
            end do
        end if
    end if


end subroutine ldlssm
####$$$$ KFAS\src/Makevars
PKG_LIBS = $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS)####$$$$ KFAS\src/ngfilter.f95
! Filtering of non-gaussian model

subroutine ngfilter(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, theta,&
dist, p,n, m, r, rankp, nnd,nsim,epsplus,etaplus,aplus1,c,tol,info,maxiter,&
convtol,nd,ndl,alphahat,alphavar,thetahat,thetavar,yhat,yvar,smootha,smooths,smoothy)

    implicit none

    integer, intent(in) ::  p,m, r, n,nnd,info,nsim,maxiter,ndl,smootha,smooths,smoothy
    integer, intent(in), dimension(p) :: dist
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(inout) :: rankp
    integer ::  t, j
    double precision, intent(in) :: tol,convtol
    double precision, intent(in), dimension(n,p) :: u,theta
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in),dimension(nsim) :: c
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout), dimension(m,nsim) :: aplus1
    double precision, intent(inout), dimension((m-1)*smootha+1,(n-1)*smootha+1) :: alphahat
    double precision, intent(inout), dimension((m-1)*smootha+1,(m-1)*smootha+1,(n-1)*smootha+1) :: alphavar
    double precision, intent(inout), dimension((p-1)*smoothy+1,(n-1)*smoothy+1) :: yhat
    double precision, intent(inout), dimension((p-1)*smoothy+1,(p-1)*smoothy+1,(n-1)*smoothy+1) :: yvar
    double precision, intent(inout), dimension((p-1)*smooths+1,(n-1)*smooths+1) :: thetahat
    double precision, intent(inout), dimension((p-1)*smooths+1,(p-1)*smooths+1,(n-1)*smooths+1) :: thetavar
    double precision, dimension(smootha*m+(1-smootha)*p,n,4*nsim) :: sim
    double precision, dimension(smootha*p+(1-smootha),n,4*nsim*smootha+(1-smootha)) :: osim
    double precision, dimension(n,4*nsim) :: w
    double precision, dimension(p,m) :: pm
    double precision, external :: ddot

    if(smootha==1) then

        call isamplefilter(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, dist, &
        p, n, m, r, theta, maxiter,rankp,convtol, nnd,nsim,epsplus,etaplus,&
        aplus1,c,tol,info,1,w,sim,nd,ndl,4,m)

        do t=1,n
            w(t,:) = w(t,:)/sum(w(t,:))
            call covmeanwprotect(sim(:,t,:),w(t,:),m,1,4*nsim,alphahat(:,t),alphavar(:,:,t))
        end do

        if(smooths==1) then
            do t = 1, n
                call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,alphahat(:,t),1,0.0d0,thetahat(:,t),1)
                call dsymm('r','u',p,m,1.0d0,alphavar(:,:,t),m,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,pm,p)
                call dgemm('n','t',p,p,m,1.0d0,pm,p,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,thetavar(:,:,t),p)
            end do
        end if

        if(smoothy==1) then
            do t = 1, n
                do j = 1,p
                    call dgemv('t',m,4*nsim,1.0d0,sim(:,t,:),m,zt(j,:,(t-1)*timevar(1)+1),1,0.0d0,osim(j,t,:),1)
                end do
            end do

            do j= 1,p
                select case(dist(j))
                    case(1)

                    case(2)
                        do t=1, n
                            osim(j,t,:) = exp(osim(j,t,:))*u(t,j)
                        end do
                    case(3)
                        osim(j,:,:) = exp(osim(j,:,:))/(1.0d0+exp(osim(j,:,:)))
                    case default
                        osim(j,:,:) = exp(osim(j,:,:))
                end select
            end do
            do t=1,n
                call covmeanw(osim(:,t,:),w(t,:),p,1,4*nsim,yhat(:,t),yvar(:,:,t))
            end do
        end if
    else
        call isamplefilter(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, dist, &
        p, n, m, r, theta, maxiter,rankp,convtol, nnd,nsim,epsplus,etaplus,&
        aplus1,c,tol,info,1,w,sim,nd,ndl,5,p)

        do t=1,n
            w(t,:) = w(t,:)/sum(w(t,:))
        end do

        if(smooths==1) then
            do t=1,n
                call covmeanwprotect(sim(:,t,:),w(t,:),p,1,4*nsim,thetahat(:,t),thetavar(:,:,t))
            end do
        end if

        if(smoothy==1) then
            do j= 1,p
                select case(dist(j))
                    case(1)

                    case(2)
                        do t=1, n
                            sim(j,t,:) = exp(sim(j,t,:))*u(t,j)
                        end do
                    case(3)
                        sim(j,:,:) = exp(sim(j,:,:))/(1.0d0+exp(sim(j,:,:)))
                    case default
                        sim(j,:,:) = exp(sim(j,:,:))
                end select
            end do
            do t=1,n
                call covmeanw(sim(:,t,:),w(t,:),p,1,4*nsim,yhat(:,t),yvar(:,:,t))
            end do
        end if

    end if





end subroutine ngfilter
####$$$$ KFAS\src/ngloglik.f95
! Non-Gaussian log-likelihood computation
subroutine ngloglik(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, p,m,&
r, n, lik, theta, u, dist,maxiter,rankp,convtol, &
nnd,nsim,epsplus,etaplus,aplus1,c,tol,info,antit,sim,nsim2,nd,ndl,diff)

    implicit none

    integer, intent(in) ::  p, m, r, n,nnd,info,antit,nsim,sim,nsim2,ndl
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(p) :: dist
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(in), dimension(5) :: timevar
    integer, intent(inout) :: maxiter,rankp
    integer ::  rankp2, j,t
    double precision, intent(in) :: convtol,tol
    double precision, intent(in), dimension(n,p) :: u
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in), dimension(m,nsim) :: aplus1
    double precision, intent(in),dimension(nsim) :: c
    double precision, dimension(p,p,n) :: ht
    double precision, dimension(n,p) :: ytilde
    double precision, intent(inout), dimension(n,p) :: theta
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout) :: lik
    double precision, dimension(p,n,nsim2) :: tsim
    double precision, dimension(n,p) :: dn
    double precision, dimension(n) :: tmp
    double precision, dimension(nsim2) :: w
    double precision :: con
    double precision, intent(inout) :: diff
    double precision, external :: ddot

    con = 0.5d0*log(8.0d0*atan(1.0d0))

    rankp2 = rankp

    !approximate
    call approx(yt, ymiss, timevar, zt, tt, rtv, ht, qt, a1, p1,p1inf, p,n,m,r,&
    theta, u, ytilde, dist,maxiter,tol,rankp2,convtol,diff)

    if(diff == diff) then

        rankp2 = rankp
        ! gaussian likelihood
        call gloglik(ytilde, ymiss, timevar, zt, ht, tt, rtv, qt, a1, p1, p1inf,&
        p, m, r, n, lik, tol,rankp2)

        where(ymiss .EQ. 0) dn=(ytilde-theta)**2

        do j=1,p
            if(dist(j) > 1) then
                do t=1,n
                    if(ymiss(t,j) .EQ. 0) then
                        lik= lik + con + 0.5d0*log(ht(j,j,t)) + 0.5d0*dn(t,j)/ht(j,j,t)
                    end if
                end do
            end if
        end do

        w=1.0d0

        if(sim .EQ. 1) then

            rankp2 = rankp
                 ! simulate signals
            call simgaussian(ymiss,timevar, ytilde, zt, ht, tt, rtv, qt, a1, p1, &
            p1inf, nnd,nsim, epsplus, etaplus, aplus1, p, n, m, r, info,rankp,&
            tol,nd,ndl,tsim,c,5,p,antit)


            ! Compute weights
            do j=1,p
                select case(dist(j))
                    case(2)    !poisson
                        tmp = exp(theta(:,j))
                        do t=1,n
                            if(ymiss(t,j) .EQ. 0) then
                                !  do i=1,nsim2
                                w = w*exp(yt(t,j)*(tsim(j,t,:)-theta(t,j))-&
                                u(t,j)*(exp(tsim(j,t,:))-tmp(t)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,t,:))**2 - dn(t,j)))
                              !  end do
                            end if
                        end do
                    case(3) !binomial
                        tmp = log(1.0d0+exp(theta(:,j)))
                        do t=1,n
                            if(ymiss(t,j) .EQ. 0) then
                                w = w*exp( yt(t,j)*(tsim(j,t,:)-theta(t,j))-&
                                u(t,j)*(log(1.0d0+exp(tsim(j,t,:)))-tmp(t)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,t,:))**2 -dn(t,j)))
                            end if
                        end do
                    case(4) ! gamma
                        tmp = exp(-theta(:,j))
                        do t=1,n
                            if(ymiss(t,j) .EQ. 0) then
                                w = w*exp( u(t,j)*(yt(t,j)*(tmp(t)-exp(-tsim(j,t,:)))+theta(t,j)-tsim(j,t,:)))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,t,:))**2 -dn(t,j)))
                            end if
                        end do
                    case(5)
                        tmp = exp(theta(:,j))
                        do t=1,n
                            if(ymiss(t,j) .EQ. 0) then
                                w = w*exp(yt(t,j)*(tsim(j,t,:)-theta(t,j)) +&
                                (yt(t,j)+u(t,j))*log((u(t,j)+tmp(t))/(u(t,j)+exp(tsim(j,t,:)))))/&
                                exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,t,:))**2 -dn(t,j)))
                                !w = w*((u(t,j)+exp(tsim(j,t,:)))/(u(t,j)+tmp(t)))**u(t,j)*&
                                !(exp(tsim(j,t,:))/(exp(tsim(j,t,:))+u(t,j)))**yt(t,j)&
                                !*(tmp/(tmp+u(t,j)))**(-yt(t,j))/&
                                !exp(-0.5d0/ht(j,j,t)*( (ytilde(t,j)-tsim(j,t,:))**2 -dn(t,j)))
                            end if
                        end do
                end select
            end do


            lik= lik+log(sum(w)/nsim2)
        end if

    end if

end subroutine ngloglik
####$$$$ KFAS\src/ngsmooth.f95
! Smoothing of non-gaussian model

subroutine ngsmooth(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, theta,&
dist, p,n, m, r, rankp, nnd,nsim,epsplus,etaplus,aplus1,c,tol,info,maxiter,&
convtol,nd,ndl,alphahat,alphavar,thetahat,thetavar,yhat,yvar,smootha,smooths,smoothy)

    implicit none

    integer, intent(in) ::  p,m, r, n,nnd,info,nsim,maxiter,ndl,smootha,smooths,smoothy
    integer, intent(in), dimension(p) :: dist
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(inout) :: rankp
    integer ::  t, j
    double precision, intent(in) :: tol,convtol
    double precision, intent(in), dimension(n,p) :: u,theta
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in),dimension(nsim) :: c
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout), dimension(m,nsim) :: aplus1
    double precision, intent(inout), dimension((m-1)*smootha+1,(n-1)*smootha+1) :: alphahat
    double precision, intent(inout), dimension((m-1)*smootha+1,(m-1)*smootha+1,(n-1)*smootha+1) :: alphavar
    double precision, intent(inout), dimension((p-1)*smoothy+1,(n-1)*smoothy+1) :: yhat
    double precision, intent(inout), dimension((p-1)*smoothy+1,(p-1)*smoothy+1,(n-1)*smoothy+1) :: yvar
    double precision, intent(inout), dimension((p-1)*smooths+1,(n-1)*smooths+1) :: thetahat
    double precision, intent(inout), dimension((p-1)*smooths+1,(p-1)*smooths+1,(n-1)*smooths+1) :: thetavar
    double precision, dimension(smootha*m+(1-smootha)*p,n,4*nsim) :: sim
    double precision, dimension(smootha*p+(1-smootha),n,4*nsim*smootha+(1-smootha)) :: osim
    double precision, dimension(4*nsim) :: w
    double precision, dimension(p,m) :: pm
    double precision, external :: ddot

    if(smootha==1) then

        call isample(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, dist, &
        p, n, m, r, theta, maxiter,rankp,convtol, nnd,nsim,epsplus,etaplus,&
        aplus1,c,tol,info,1,w,sim,nd,ndl,4,m)

        w = w/sum(w)

        call covmeanwprotect(sim,w,m,n,4*nsim,alphahat,alphavar)

        if(smooths==1) then
            do t = 1, n
                call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,alphahat(:,t),1,0.0d0,thetahat(:,t),1)
                call dsymm('r','u',p,m,1.0d0,alphavar(:,:,t),m,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,pm,p)
                call dgemm('n','t',p,p,m,1.0d0,pm,p,zt(:,:,(t-1)*timevar(1)+1),p,0.0d0,thetavar(:,:,t),p)
            end do
        end if

        if(smoothy==1) then
            do t = 1, n
                do j = 1,p
                    call dgemv('t',m,4*nsim,1.0d0,sim(:,t,:),m,zt(j,:,(t-1)*timevar(1)+1),1,0.0d0,osim(j,t,:),1)
                end do
            end do

            do j= 1,p
                select case(dist(j))
                    case(1)
                    case(2)
                        do t=1, n
                            osim(j,t,:) = exp(osim(j,t,:))*u(t,j)
                        end do
                    case(3)
                        osim(j,:,:) = exp(osim(j,:,:))/(1.0d0+exp(osim(j,:,:)))
                    case default
                        osim(j,:,:) = exp(osim(j,:,:))
                end select
            end do
            call covmeanw(osim,w,p,n,4*nsim,yhat,yvar)
        end if
    else
        call isample(yt, ymiss, timevar, zt, tt, rtv, qt, a1, p1,p1inf, u, dist, &
        p, n, m, r, theta, maxiter,rankp,convtol, nnd,nsim,epsplus,etaplus,&
        aplus1,c,tol,info,1,w,sim,nd,ndl,5,p)

        w = w/sum(w)

        if(smooths==1) then
            call covmeanwprotect(sim,w,p,n,4*nsim,thetahat,thetavar)
        end if

        if(smoothy==1) then
            do j= 1,p
                select case(dist(j))
                    case(1)

                    case(2)
                        do t=1, n
                            sim(j,t,:) = exp(sim(j,t,:))*u(t,j)
                        end do
                    case(3)
                        sim(j,:,:) = exp(sim(j,:,:))/(1.0d0+exp(sim(j,:,:)))
                    case default
                        sim(j,:,:) = exp(sim(j,:,:))
                end select
            end do
            call covmeanw(sim,w,p,n,4*nsim,yhat,yvar)
        end if

    end if





end subroutine ngsmooth
####$$$$ KFAS\src/predict.f95
! auxiliary functions for computing Zalpha and ZVZ

subroutine signaltheta(tvz, zt, ahat, vt, p, n, m, theta, thetavar,d,states,m2)

    implicit none

    integer, intent(in) :: p, m, n,tvz,d,m2 !,tvh
    integer, intent(in), dimension(m2) :: states
    integer ::  t
    double precision, intent(in), dimension(p,m,(n-1)*tvz+1) :: zt
    double precision, intent(in), dimension(m,n) :: ahat
    double precision, intent(in), dimension(m,m,n) :: vt
    double precision, intent(inout), dimension(n,p) :: theta
    double precision, intent(inout), dimension(p,p,n) :: thetavar
    double precision, dimension(p,m2) :: pm

    do t = (d+1), n
        call dgemv('n',p,m2,1.0d0,zt(:,states,(t-1)*tvz+1),p,ahat(states,t),1,0.0d0,theta(t,:),1)
        call dsymm('r','u',p,m2,1.0d0,vt(states,states,t),m2,zt(:,states,(t-1)*tvz+1),p,0.0d0,pm,p)
        call dgemm('n','t',p,p,m2,1.0d0,pm,p,zt(:,states,(t-1)*tvz+1),p,0.0d0,thetavar(:,:,t),p)
    end do

end subroutine signaltheta

subroutine zalpha(timevar, zt, alpha,theta,p,m,n,nsim,m2,states)

    implicit none

    integer, intent(in) :: p, m, n, nsim,timevar,m2
    integer, intent(in), dimension(m2) :: states
    integer :: t, i
    double precision, intent(in), dimension(p,m,(n-1)*timevar+1) :: zt
    double precision, intent(in), dimension(n,m,nsim) :: alpha
    double precision, intent(inout), dimension(n,p,nsim) :: theta

   do i=1,nsim
        do t=1,n
            call dgemv('n',p,m2,1.0d0,zt(:,states,(t-1)*timevar+1),p,&
            alpha(t,states,i),1,0.0d0,theta(t,:,i),1)
        end do
    end do

end subroutine zalpha


####$$$$ KFAS\src/simfilter.f95
subroutine simfilter(ymiss,timevar, yt, zt, ht, tt, rtv, qt, a1, p1, &
p1inf, nnd,nsim, epsplus, etaplus, aplus1, p, n, m, r, info,rankp,&
tol,nd,ndl,sim,c,simwhat,simdim,antithetics)

    implicit none

    integer, intent(in) :: p, m, r, n, nsim,nnd,ndl,simdim,simwhat,antithetics
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(inout) :: info,rankp
    integer ::  t, i, d, j,k
    double precision, intent(in) :: tol
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in), dimension(nsim) :: c
    double precision, intent(inout), dimension(simdim,n,3 * nsim * antithetics + nsim) :: sim
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout), dimension(m,nsim) :: aplus1

    double precision, dimension(n,p) :: yplus
    double precision, dimension(m,n+1) :: aplus
    double precision, dimension(p,n) :: ft,finf
    double precision, dimension(m,p,n) :: kt,kinf
    double precision, dimension(r,r,(n-1)*timevar(5)+1) :: cholqt
    double precision, dimension(m,m) :: cholp1
    double precision, dimension(r,r) :: rcholhelp
    double precision, dimension(m,n,4) :: alphatmp

    double precision, dimension(m,n+1) :: at
    double precision, dimension(m,n+1) :: atplus
    double precision, dimension(m,m,n+1) :: pt,pinf
    double precision, dimension(p,n) :: vt
    double precision :: lik
    double precision, dimension(1,p) :: theta
    double precision, dimension(p,p,1) :: thetavar


    double precision, external :: ddot
    external kfilter
    external filtersimfast
   

    ! tv= max(timevar(4),timevar(5))
    !do t=1, (n-1)*tv+1
    !     call dsymm('r','u',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rtv(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
    !     call dgemm('n','t',m,m,r,1.0d0,mr,m,rtv(:,:,(t-1)*timevar(4)+1),m,0.0d0,rqr(:,:,t),m)
    ! end do





    ! call kfseta(yt, ymiss, timevar, zt, ht,tt, rtv,qt,rqr, a1, p1, p1inf, &
    ! d, j, p, m, n, r,tol,rankp,ft,finf,kt,kinf,rt,rti,etahat)
    ! ahat(:,1) = a1
    ! call dsymv('l',m,1.0d0,p1,m,rt,1,1.0d0,ahat(:,1),1)
    ! if(d .GT. 0) then
    !     call dsymv('l',m,1.0d0,p1inf,m,rti,1,1.0d0,ahat(:,1),1)
    ! end if



    !do t = 1,n-1
    !    call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,ahat(:,t),1,0.0d0,ahat(:,t+1),1)
    !    call dgemv('n',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,etahat(:,t),1,1.0d0,ahat(:,t+1),1)
    !end do
     
    at=0.0d0
    !pt=0.0d0
    !vt=0.0d0
    !ft=0.0d0
    !kt=0.0d0
    !pinf=0.0d0
    !finf=0.0d0
    !kinf=0.0d0
    call kfilter(yt, ymiss, timevar, zt, ht,tt, rtv, qt, a1, p1, p1inf, &
    p,n,m,r,d,j,  at, pt, vt, ft,kt, pinf, finf, kinf, lik, tol,rankp,theta,thetavar,0)

    do t = 1, (n-1)*timevar(5)+1
        if(r.EQ.1) then
            cholqt(1,1,t)=sqrt(qt(1,1,t))
        else
            rcholhelp = qt(:,:,t)
            call ldl(rcholhelp,r,tol,info)
            if(info .NE. 0) then
                info=2
                return
            end if
            do i=1,r
                cholqt(i,i,t)=sqrt(rcholhelp(i,i))
            end do
            do i=1,r-1
                cholqt((i+1):r,i,t) = rcholhelp((i+1):r,i)*cholqt(i,i,t)
            end do
        end if
    end do
  
  
    if(nnd.GT.0) then
        if(m.EQ.1) then
            cholp1(1,1)=sqrt(p1(1,1))
        else
            cholp1 = p1
            call ldl(cholp1,m,tol,info)
            if(info .NE. 0) then
                info=3
                return
            end if
            do i=1,m
                cholp1(i,i)=sqrt(cholp1(i,i))
            end do
            do i=1,m-1
                cholp1((i+1):m,i) = cholp1((i+1):m,i)*cholp1(i,i)
            end do
        end if
    end if
  
    do i = 1, nsim
        aplus=0.0d0
        if(ndl.GT.0) then
            aplus(nd,1) = a1(nd)
        end if
        if(nnd.GT.0) then
            call dtrmv('l','n','n',m,cholp1,m,aplus1(:,i),1)
            aplus(:,1) = aplus(:,1)+aplus1(:,i)
        end if

        do t = 1, n
            do k = 1, p
                if(ymiss(t,k).EQ.0) then
                    yplus(t,k) = epsplus(k,t,i)*sqrt(ht(k,k,(t-1)*timevar(2)+1)) + &
                    ddot(m,zt(k,:,(t-1)*timevar(1)+1),1,aplus(:,t),1)
                end if
            end do
            call dtrmv('l','n','n',r,cholqt(:,:,(t-1)*timevar(5)+1),r,etaplus(:,t,i),1)
            call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,aplus(:,t),1,0.0d0,aplus(:,t+1),1)
            call dgemv('n',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,etaplus(:,t,i),1,1.0d0,aplus(:,t+1),1)
        end do


                !call smoothetafast(yplus, ymiss, timevar, zt, tt, rtv,qt,a1, ft,kt,&
                !finf, kinf, d, j, p, m, n,r,tol,rt,rti,etahat)


                !aplushat = a1

                !call dsymv('l',m,1.0d0,p1,m,rt,1,1.0d0,aplushat,1)
                !if(d .GT. 0) then
                !    call dsymv('l',m,1.0d0,p1inf,m,rti,1,1.0d0,aplushat,1)
                !end if

            !pt=0.0d0
            !vt=0.0d0
            !ft=0.0d0
            !kt=0.0d0
            !pinf=0.0d0
            !finf=0.0d0
            !kinf=0.0d0
            !    rankp=rankp2
            !    call kfilter(yplus, ymiss, timevar, zt, ht,tt, rtv, qt, a1, p1, p1inf, p,n,m,r,d,j,&
            !     atplus, pt, vt, ft,kt, pinf, finf, kinf, lik, tol,rankp)
        atplus=0.0d0
        call filtersimfast(yplus, ymiss, timevar, zt,tt, a1, ft,kt,&
        finf, kinf, d, j, p, m, n,tol,atplus)
        if(simwhat==4) then
            do t = 1, n
                sim(:,t,i) = at(:,t) - atplus(:,t) + aplus(:,t)
                if(antithetics == 1) then
                    sim(:,t,i+nsim) = at(:,t) + atplus(:,t) - aplus(:,t)
                    sim(:,t,i+2*nsim) = at(:,t)+ c(i)*(sim(:,t,i)-at(:,t))
                    sim(:,t,i+3*nsim) = at(:,t)+ c(i)*(sim(:,t,i+nsim)-at(:,t))
                end if
            end do
        else
            do t = 1, n
                alphatmp(:,t,1) = at(:,t) - atplus(:,t) + aplus(:,t)
                call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,&
                alphatmp(:,t,1),1,0.0d0,sim(:,t,i),1)
                if(antithetics == 1) then
                    alphatmp(:,t,2) = at(:,t) + atplus(:,t) - aplus(:,t)
                    alphatmp(:,t,3) = at(:,t)+ c(i)*(alphatmp(:,t,1)-at(:,t))
                    alphatmp(:,t,4) = at(:,t)+ c(i)*(alphatmp(:,t,2)-at(:,t))
                    call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,&
                    alphatmp(:,t,2),1,0.0d0,sim(:,t,i+nsim),1)
                    call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,&
                    alphatmp(:,t,3),1,0.0d0,sim(:,t,i+2*nsim),1)
                    call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,&
                    alphatmp(:,t,4),1,0.0d0,sim(:,t,i+3*nsim),1)
                end if
            end do
        end if
    end do
end subroutine simfilter

####$$$$ KFAS\src/simgaussian.f95
subroutine simgaussian(ymiss,timevar, yt, zt, ht, tt, rtv, qt, a1, p1, &
p1inf, nnd,nsim, epsplus, etaplus, aplus1, p, n, m, r, info,rankp,&
tol,nd,ndl,sim,c,simwhat,simdim,antithetics)

    implicit none
    !!! transpoosi simille!!!
    integer, intent(in) :: p, m, r, n, nsim,nnd,ndl,simdim,simwhat,antithetics
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    integer, intent(in), dimension(ndl) :: nd
    integer, intent(inout) :: info,rankp
    integer ::  t, i, d, j,k,tv,l
    double precision, intent(in) :: tol
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(in),dimension(nsim) :: c
    double precision, intent(inout), dimension(simdim,n,3 * nsim * antithetics + nsim) :: sim
    double precision, intent(inout), dimension(r,n,nsim) :: etaplus
    double precision, intent(inout), dimension(p,n,nsim) :: epsplus
    double precision, intent(inout), dimension(m,nsim) :: aplus1

    double precision, dimension(n,p) :: yplus
    double precision, dimension(m,n+1) :: aplus
    double precision, dimension(m) :: ahat
    double precision, dimension(m) :: aplushat
    double precision, dimension(p,n) :: ft,finf
    double precision, dimension(m,p,n) :: kt,kinf
    double precision, dimension(r,r,(n-1)*timevar(5)+1) :: cholqt
    double precision, dimension(m,m) :: cholp1
    double precision, dimension(r,r) :: rcholtmp
    double precision, dimension(m) :: rt0,rt1
    double precision, dimension(m,r) :: mr
    double precision, dimension(m,m,(n-1)*max(timevar(4),timevar(5))+1) :: rqr
    double precision, dimension(r,n) :: etahat
    double precision, dimension(p,n) :: epshat
    double precision, dimension(r,n) :: etaplushat
    double precision, dimension(p,n) :: epsplushat
    double precision, dimension(r,n-1,4) :: etatmp
    double precision, dimension(m,n,4) :: alphatmp
    double precision, external :: ddot
    logical needeps

    needeps = simwhat==1 .or. simwhat==3
    !compute rqr
    tv= max(timevar(4),timevar(5))
    do t=1, (n-1)*tv+1
        call dsymm('r','u',m,r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,rtv(:,:,(t-1)*timevar(4)+1),m,0.0d0,mr,m)
        call dgemm('n','t',m,m,r,1.0d0,mr,m,rtv(:,:,(t-1)*timevar(4)+1),m,0.0d0,rqr(:,:,t),m)
    end do

    aplus=0.0d0


    call smoothsim(yt, ymiss, timevar, zt, ht,tt, rtv,qt,rqr, a1, p1, p1inf, &
    d, j, p, m, n, r,tol,rankp,ft,finf,kt,kinf,epshat,etahat,rt0,rt1,needeps)
        !simwhat = 1: epsilon, 2: eta, 3: both, 4: state, 5: signal, 6: observations
    if(simwhat > 3) then
        ahat = a1
        call dsymv('l',m,1.0d0,p1,m,rt0,1,1.0d0,ahat,1)
        if(d > 0) then
            call dsymv('l',m,1.0d0,p1inf,m,rt1,1,1.0d0,ahat,1)
        end if
    end if



    do t = 1, (n-1)*timevar(5)+1
        if(r.EQ.1) then
            cholqt(1,1,t)=sqrt(qt(1,1,t))
        else
            rcholtmp = qt(:,:,t)
            !call dgesdd('o',r,r,rcholtmp,r,sigma,u,r,ut,r,work,lwork,iwork,info)
            call ldl(rcholtmp,r,tol,info)
            if(info .NE. 0) then
                info=2
                return
            end if
            do i=1,r
                cholqt(i,i,t)=sqrt(rcholtmp(i,i))
            end do
            do i=1,r-1
                cholqt((i+1):r,i,t) = rcholtmp((i+1):r,i)*cholqt(i,i,t)
            end do
        end if
    end do
  
  
    if(nnd.GT.0) then
        if(m.EQ.1) then
            cholp1(1,1)=sqrt(p1(1,1))
        else
            cholp1 = p1
            call ldl(cholp1,m,tol,info)
            if(info .NE. 0) then
                info=3
                return
            end if
            do i=1,m
                cholp1(i,i)=sqrt(cholp1(i,i))
            end do
            do i=1,m-1
                cholp1((i+1):m,i) = cholp1((i+1):m,i)*cholp1(i,i)
            end do
        end if
    end if
  
    do i = 1, nsim

        if(ndl.GT.0) then
            aplus(nd,1) = a1(nd)
        end if
        if(nnd.GT.0) then
            call dtrmv('l','n','n',m,cholp1,m,aplus1(:,i),1)
            aplus(:,1) = aplus(:,1)+aplus1(:,i)
        end if

        do t = 1, n
            do k = 1, p
                if(ymiss(t,k).EQ.0) then
                    yplus(t,k) = epsplus(k,t,i)*sqrt(ht(k,k,(t-1)*timevar(2)+1)) + &
                    ddot(m,zt(k,:,(t-1)*timevar(1)+1),1,aplus(:,t),1)
                end if
            end do
            call dtrmv('l','n','n',r,cholqt(:,:,(t-1)*timevar(5)+1),r,etaplus(:,t,i),1)
            call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,aplus(:,t),1,0.0d0,aplus(:,t+1),1)
            call dgemv('n',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,etaplus(:,t,i),1,1.0d0,aplus(:,t+1),1)
        end do
    
           call smoothsimfast(yplus, ymiss, timevar, zt, ht,tt, rtv,qt,a1, ft,kt,&
        finf, kinf, d, j, p, m, n,r,tol,epsplushat,etaplushat,rt0,rt1,needeps)

        !simwhat = 1: epsilon, 2: eta, 3: both, 4: state, 5: signal, 6: observations
        select case(simwhat)
            case(1)
                sim(:,:,i) = epshat - epsplushat + epsplus(:,:,i)
                if(antithetics == 1) then
                    sim(:,:,i+nsim) = epshat + epsplushat - epsplus(:,:,i)
                    sim(:,:,i+2*nsim) = epshat + c(i)*(sim(:,:,i)-epshat)
                    sim(:,:,i+3*nsim) = epshat + c(i)*(sim(:,:,i+nsim)-epshat)
                end if
            case(2)
                sim(:,:,i) = etahat - etaplushat + etaplus(:,:,i)
                if(antithetics == 1) then
                    sim(:,:,i+nsim) = etahat + etaplushat - etaplus(:,:,i)
                    sim(:,:,i+2*nsim) = etahat + c(i)*(sim(:,:,i)-etahat)
                    sim(:,:,i+3*nsim) = etahat + c(i)*(sim(:,:,i+nsim)-etahat)
                end if
            case(3)
                sim(1:p,:,i) = epshat - epsplushat + epsplus(:,:,i)
                sim((p+1):,:,i) = etahat - etaplushat + etaplus(:,:,i)
                if(antithetics == 1) then
                    sim(1:p,:,i+nsim) = epshat + epsplushat - epsplus(:,:,i)
                    sim(1:p,:,i+2*nsim) = epshat + c(i)*(sim(1:p,:,i)-epshat)
                    sim(1:p,:,i+3*nsim) = epshat + c(i)*(sim(1:p,:,i+nsim)-epshat)
                    sim((p+1):,:,i+nsim) = etahat + etaplushat - etaplus(:,:,i)
                    sim((p+1):,:,i+2*nsim) = etahat + c(i)*(sim((p+1):,:,i)-etahat)
                    sim((p+1):,:,i+3*nsim) = etahat + c(i)*(sim((p+1):,:,i+nsim)-etahat)
                end if
            case(4)
                aplushat = a1

                call dsymv('l',m,1.0d0,p1,m,rt0,1,1.0d0,aplushat,1)
                if(d .GT. 0) then
                    call dsymv('l',m,1.0d0,p1inf,m,rt1,1,1.0d0,aplushat,1)
                end if

                sim(:,1,i) = ahat - aplushat + aplus(:,1)
                etatmp(:,:,1) = etahat(:,1:(n-1)) - etaplushat(:,1:(n-1)) + etaplus(:,1:(n-1),i)
                if(antithetics == 1) then
                    sim(:,1,i+nsim) = ahat + aplushat - aplus(:,1)
                    sim(:,1,i+2*nsim) = ahat+ c(i)*(sim(:,1,i)-ahat)
                    sim(:,1,i+3*nsim) = ahat+ c(i)*(sim(:,1,i+nsim)-ahat)

                    etatmp(:,:,2) = etahat(:,1:(n-1)) + etaplushat(:,1:(n-1)) - etaplus(:,1:(n-1),i)
                    etatmp(:,:,3) = etahat(:,1:(n-1)) + c(i)*(etatmp(:,:,1)-etahat(:,1:(n-1)))
                    etatmp(:,:,4) = etahat(:,1:(n-1)) + c(i)*(etatmp(:,:,2)-etahat(:,1:(n-1)))
                end if
                do k = 1, 3*antithetics+1
                    do t = 2, n
                        call dgemv('n',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,sim(:,t-1,i+(k-1)*nsim),&
                        1,0.0d0,sim(:,t,i+(k-1)*nsim),1)
                        call dgemv('n',m,r,1.0d0,rtv(:,:,(t-2)*timevar(4)+1),m,etatmp(:,t-1,k),1,&
                        1.0d0,sim(:,t,i+(k-1)*nsim),1)
                    end do
                end do
            case(5)
                aplushat = a1

                call dsymv('l',m,1.0d0,p1,m,rt0,1,1.0d0,aplushat,1)
                if(d .GT. 0) then
                    call dsymv('l',m,1.0d0,p1inf,m,rt1,1,1.0d0,aplushat,1)
                end if

                alphatmp(:,1,1) = ahat - aplushat + aplus(:,1)
                etatmp(:,:,1) = etahat(:,1:(n-1)) - etaplushat(:,1:(n-1)) + etaplus(:,1:(n-1),i)
                call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,1),1,0.0d0,sim(:,1,i),1)

                if(antithetics == 1) then
                    alphatmp(:,1,2) = ahat + aplushat - aplus(:,1)
                    alphatmp(:,1,3) = ahat + c(i)*(alphatmp(:,1,1)-ahat)
                    alphatmp(:,1,4) = ahat + c(i)*(alphatmp(:,1,2)-ahat)
                    call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,2),1,0.0d0,sim(:,1,i+nsim),1)
                    call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,3),1,0.0d0,sim(:,1,i+2*nsim),1)
                    call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,4),1,0.0d0,sim(:,1,i+3*nsim),1)

                    etatmp(:,:,2) = etahat(:,1:(n-1)) + etaplushat(:,1:(n-1)) - etaplus(:,1:(n-1),i)
                    etatmp(:,:,3) = etahat(:,1:(n-1)) + c(i)*(etatmp(:,:,1)-etahat(:,1:(n-1)))
                    etatmp(:,:,4) = etahat(:,1:(n-1)) + c(i)*(etatmp(:,:,2)-etahat(:,1:(n-1)))

                end if
                do k = 1, 3*antithetics+1
                    do t = 2, n
                        call dgemv('n',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,alphatmp(:,t-1,k),&
                        1,0.0d0,alphatmp(:,t,k),1)
                        call dgemv('n',m,r,1.0d0,rtv(:,:,(t-2)*timevar(4)+1),m,etatmp(:,t-1,k),1,&
                        1.0d0,alphatmp(:,t,k),1)
                        call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,&
                        alphatmp(:,t,k),1,0.0d0,sim(:,t,i+(k-1)*nsim),1)
                    end do
                end do
            case(6)
                aplushat = a1

                call dsymv('l',m,1.0d0,p1,m,rt0,1,1.0d0,aplushat,1)
                if(d .GT. 0) then
                    call dsymv('l',m,1.0d0,p1inf,m,rt1,1,1.0d0,aplushat,1)
                end if

                alphatmp(:,1,1) = ahat - aplushat + aplus(:,1)
                etatmp(:,:,1) = etahat(:,1:(n-1)) - etaplushat(:,1:(n-1)) + etaplus(:,1:(n-1),i)
                !call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,1),1,0.0d0,sim(:,1,i),1)

                if(antithetics == 1) then
                    alphatmp(:,1,2) = ahat + aplushat - aplus(:,1)
                    alphatmp(:,1,3) = ahat+ c(i)*(alphatmp(:,1,1)-ahat)
                    alphatmp(:,1,4) = ahat+ c(i)*(alphatmp(:,1,2)-ahat)
                    !call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,2),1,0.0d0,sim(:,1,i+nsim),1)
                    !call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,3),1,0.0d0,sim(:,1,i+2*nsim),1)
                    !call dgemv('n',p,m,1.0d0,zt(:,:,1),p,alphatmp(:,1,4),1,0.0d0,sim(:,1,i+3*nsim),1)

                    etatmp(:,:,2) = etahat(:,1:(n-1)) + etaplushat(:,1:(n-1)) - etaplus(:,1:(n-1),i)
                    etatmp(:,:,3) = etahat(:,1:(n-1)) + c(i)*(etatmp(:,:,1)-etahat(:,1:(n-1)))
                    etatmp(:,:,4) = etahat(:,1:(n-1)) + c(i)*(etatmp(:,:,2)-etahat(:,1:(n-1)))

                end if
                do k = 1, 3*antithetics+1
                    do l = 1, p
                        if(ymiss(1,l).GT.0) then
                            sim(l,1,i+(k-1)*nsim) = ddot(m,zt(l,:,1),1,alphatmp(:,1,k),1)
                        !else
                        !    sim(l,t,i+(k-1)*nsim) = yt(t,l)
                        end if
                    end do
                    do t = 2, n
                        call dgemv('n',m,m,1.0d0,tt(:,:,(t-2)*timevar(3)+1),m,alphatmp(:,t-1,k),&
                        1,0.0d0,alphatmp(:,t,k),1)
                        call dgemv('n',m,r,1.0d0,rtv(:,:,(t-2)*timevar(4)+1),m,etatmp(:,t-1,k),1,&
                        1.0d0,alphatmp(:,t,k),1)
                        do l = 1, p
                            if(ymiss(t,l).GT.0) then
                                sim(l,t,i+(k-1)*nsim) = ddot(m,zt(l,:,(t-1)*timevar(1)+1),1,alphatmp(:,t,k),1)
                            !else
                            !    sim(l,t,i+(k-1)*nsim) = yt(t,l)
                            end if
                        end do

                        !call dgemv('n',p,m,1.0d0,zt(:,:,(t-1)*timevar(1)+1),p,alphatmp(t,:,k),1,0.0d0,sim(t,:,i+(k-1)*nsim),1)
                    end do
                end do
        end select
    end do

end subroutine simgaussian

####$$$$ KFAS\src/smoothsim.f95
! disturbance smoothing algorithm for simulation

subroutine smoothsim(yt, ymiss, timevar, zt, ht,tt, rtv,qt,rqr, a1, p1, p1inf, &
d, j, p, m, n, r,tol,rankp,ft,finf,kt,kinf,epshat,etahat,rt0,rt1,needeps)

    implicit none

    logical, intent(in) :: needeps
    integer, intent(in) ::  p, m, n,r
    integer, intent(inout) :: d, j,rankp
    integer ::  t, i,tv
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, dimension(m,m,(n-1)*max(timevar(4),timevar(5))+1) :: rqr
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(m,m) ::  p1,p1inf
    double precision, intent(inout), dimension(p,n) :: ft,finf
    double precision, intent(inout), dimension(m,p,n) :: kt,kinf
    double precision, dimension(p,n) :: vt
    double precision, dimension(m) :: at, arec
    double precision, dimension(m,m) :: prec,pirec,mm,pinf,pt
    double precision, intent(in) :: tol
    double precision, dimension(m) :: rrec,rrec1,rhelp,help
    double precision, dimension(m,m) :: im,linf,l0,lt
    double precision, intent(inout), dimension(r,n) :: etahat
    double precision, intent(inout), dimension(p,n) :: epshat
    double precision, intent(inout), dimension(m) :: rt0,rt1
    double precision :: meps
    double precision, external :: ddot

    meps = tiny(meps)
    tv = max(timevar(4),timevar(5))
    pinf = p1inf
    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do
    j=0
    d=0
    if(maxval(pinf) .GT.  0.0d0) then

        pt = p1
        prec = pt
        pirec = pinf
        at(:) = a1
        arec = a1
        diffuse: do while(d .LT. n)
            d = d+1
            do j=1, p
                if(ymiss(d,j).EQ.0) then

                    vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1) !arec
                    call dsymv('u',m,1.0d0,prec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,j,d),1) ! kt_t,i = pt_t,i*t(z_t,i)
                    ft(j,d) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kt(:,j,d),1)  + ht(j,j,(d-1)*timevar(2)+1)

                    call dsymv('u',m,1.0d0,pirec,m,zt(j,:,(d-1)*timevar(1)+1),1,0.0d0,kinf(:,j,d),1) ! kinf_t,i = pinf_t,i*t(z_t,i)
                    finf(j,d) = ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,kinf(:,j,d),1)! finf


                    if (finf(j,d) .GT. tol) then
                        call daxpy(m,vt(j,d)/finf(j,d),kinf(:,j,d),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                        call dsyr('u',m,ft(j,d)/(finf(j,d)**2),kinf(:,j,d),1,prec,m) !prec = prec +  kinf*kinf'*ft/finf^2
                        call dsyr2('u',m,-1.0d0/finf(j,d),kt(:,j,d),1,kinf(:,j,d),1,prec,m) !prec = prec -(kt*kinf'+kinf*kt')/finf
                        !call dger(m,m,(-1.0d0/finf(j,d)),kinf(:,j,d),1,kinf(:,j,d),1,pirec,m)
                        call dsyr('u',m,(-1.0d0/finf(j,d)),kinf(:,j,d),1,pirec,m) !pirec = pirec -kinf*kinf'/finf

                        rankp = rankp -1
                        do i = 1, m
                            if(pirec(i,i) .LT. tol) then
                                pirec(i,:) = 0.0d0
                                pirec(:,i) = 0.0d0
                            end if
                        end do
                    else
                        finf(j,d) = 0.0d0
                        if(ft(j,d) .GT.  meps) then
                            call daxpy(m,vt(j,d)/ft(j,d),kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                            call dsyr('u',m,(-1.0d0)/ft(j,d),kt(:,j,d),1,prec,m) !prec = prec -kt*kt'/ft
                        else
                            ft(j,d)=0.0d0
                        end if
                    end if

                    if(rankp .EQ. 0) then
                        exit diffuse
                    end if
                end if
            end do

            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)
            call dcopy(m,at(:),1,arec,1) ! a_rec = at(:,t+1)
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)

            pt = pt + rqr(:,:,(d-1)*tv+1)

            prec = pt
            call dsymm('r','u',m,m,1.0d0,pirec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pinf,m)
            pirec = pinf


        end do diffuse

        !non-diffuse filtering begins
        if(rankp .EQ. 0) then
            do i = j+1, p
                if(ymiss(d,i).EQ.0) then
                    vt(i,d) = yt(d,i) - ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,arec,1) !vt
                    call dsymv('u',m,1.0d0,prec,m,zt(i,:,(d-1)*timevar(1)+1),1,0.0d0,kt(:,i,d),1) ! p symmetric!
                    ft(i,d) = ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,kt(:,i,d),1)  +  ht(i,i,(d-1)*timevar(2)+1)
                    if (ft(i,d) .GT.  meps) then
                        call daxpy(m,vt(i,d)/ft(i,d),kt(:,i,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                        call dsyr('u',m,-1.0d0/ft(i,d),kt(:,i,d),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,t)
                    else
                        ft(i,d)=0.0d0
                    end if
                end if
            end do
   
            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)
  
            call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,mm,m)
            call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(d-1)*timevar(3)+1),m,0.0d0,pt,m)
 
            pt = pt + rqr(:,:,(d-1)*tv+1)

   
            call dcopy(m,at(:),1,arec,1) ! a_rec =at(:,t+1)
            prec = pt
        end if
    end if

    !Non-diffuse filtering continues from t=d+1, i=1


    if(d.EQ.0) then
        prec = p1
        arec = a1!   call dcopy(m,a1,1,arec,1)
        at(:) = a1 !call dcopy(m,a1,1,at(:,1),1) !at(:,1) = a1
        pt = p1
    else
        if(d .EQ. n .AND. j .EQ. p+1) then
            j = p
        end if
    end if
    do t = d+1, n
        do i = 1, p
            if(ymiss(t,i).EQ.0) then
                vt(i,t) = yt(t,i) - ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,arec,1)
                call dsymv('u',m,1.0d0,prec,m,zt(i,:,(t-1)*timevar(1)+1),1,0.0d0,kt(:,i,t),1)
                ft(i,t) = ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,kt(:,i,t),1) +  ht(i,i,(t-1)*timevar(2)+1)
                if (ft(i,t) .GT.  meps) then
                    call daxpy(m,vt(i,t)/ft(i,t),kt(:,i,t),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                    call dsyr('u',m,-1.0d0/ft(i,t),kt(:,i,t),1,prec,m) !p_rec = p_rec - kt*kt'*ft(i,i,t)
                else
                    ft(i,t)=0.0d0
                end if

            end if
        end do
           
        call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,at(:),1)  !at(:,t+1) = matmul(tt,a_rec)
        call dsymm('r','u',m,m,1.0d0,prec,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,mm,m)
        call dgemm('n','t',m,m,m,1.0d0,mm,m,tt(:,:,(t-1)*timevar(3)+1),m,0.0d0,pt,m)
  
        pt = pt + rqr(:,:,(t-1)*tv+1)

        call dcopy(m,at(:),1,arec,1) ! a_rec =at(:,t+1)
        prec = pt
    end do

    !smoothing begins

    rrec = 0.0d0

    do t = n, d+1, -1
        call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
        call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
        call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1) !r_t,p=t_t-1'*r_t+1
        rrec = rhelp
        do i = p, 1 , -1
            if(ymiss(t,i)==0) then
                if(ft(i,t) >  meps) then
                    if(needeps) then
                        epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))/ft(i,t)
                    end if
                    lt = im
                    call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !l = I -kz
                    call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                    rrec = rhelp + vt(i,t)/ft(i,t)*zt(i,:,(t-1)*timevar(1)+1)
                end if
            end if
        end do
    end do

    if(d.GT.0) then
        t=d
        call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
        call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
        call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
        rrec = rhelp
        do i = p, (j+1) , -1
            if(ymiss(t,i).EQ.0) then
                if(ft(i,t) .GT.  meps) then
                    if(needeps) then
                        epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)/ft(i,t)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))
                    end if
                    lt = im
                    call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !l = i -kz
                    call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                    rrec=rhelp
                    call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1)
                end if
            end if
        end do
        rrec1 = 0.0d0
        do i = j, 1, -1
            if(ymiss(t,i).EQ.0) then
                if(finf(i,t).GT. tol) then
                    if(needeps) then
                        epshat(i,t) = -ht(i,i,(t-1)*timevar(2)+1)*ddot(m,kinf(:,i,t),1,rrec,1)/finf(i,t)
                    end if
                    linf = im
                    call dger(m,m,-1.0d0/finf(i,t),kinf(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,linf,m) !linf
                    rhelp = -kt(:,i,t)
                    call daxpy(m,ft(i,t)/finf(i,t),kinf(:,i,t),1,rhelp,1)
                    l0=0.0d0
                    call dger(m,m,(1.0d0/finf(i,t)),rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0
                    call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                    call dcopy(m,rhelp,1,rrec1,1)
                    call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                    call daxpy(m,(vt(i,t)/finf(i,t)),zt(i,:,(t-1)*timevar(1)+1),1,rrec1,1)
                    call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                    rrec = rhelp
                else
                    if(ft(i,t).GT. meps) then
                        if(needeps) then
                            epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))/ft(i,t)
                        end if
                        lt= im
                        call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !lt = I -Kt*Z/Ft
                        call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                        rrec = rhelp
                        call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1) !r0 = Z'vt/Ft - Lt'r0
                        call dgemv('t',m,m,1.0d0,lt,m,rrec1,1,0.0d0,rhelp,1)
                        rrec1=rhelp
                    end if
                end if
            end if
        end do

        do t=(d-1), 1, -1
            call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
            call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
            rrec = rhelp
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec1,1,0.0d0,rhelp,1,1)
            rrec1 = rhelp

            do i = p, 1, -1
                if(ymiss(t,i).EQ.0) then
                    if(finf(i,t).GT. tol) then
                        if(needeps) then
                            epshat(i,t) = -ht(i,i,(t-1)*timevar(2)+1)*ddot(m,kinf(:,i,t),1,rrec,1)/finf(i,t)
                        end if
                        linf = im
                        call dger(m,m,-1.0d0/finf(i,t),kinf(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,linf,m) !linf
                        rhelp = -kt(:,i,t)
                        call daxpy(m,ft(i,t)/finf(i,t),kinf(:,i,t),1,rhelp,1)
                        l0=0.0d0
                        call dger(m,m,(1.0d0/finf(i,t)),rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0
                        call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                        call dcopy(m,rhelp,1,rrec1,1)
                        call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                        call daxpy(m,vt(i,t)/finf(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec1,1)
                        call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                        rrec = rhelp
                    else
                        if(ft(i,t).GT.  meps) then
                            if(needeps) then
                                epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))/ft(i,t)
                            end if
                            lt= im
                            call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !lt = I -Kt*Z/Ft
                            call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                            rrec = rhelp
                            call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1) !r0 = Z'vt/Ft - Lt'r0
                            call dgemv('t',m,m,1.0d0,lt,m,rrec1,1,0.0d0,rhelp,1)
                            rrec1=rhelp

                        end if

                    end if
                end if
            end do

        end do
    end if

    rt0=rrec
    rt1=rrec1

end subroutine smoothsim

####$$$$ KFAS\src/smoothsimfast.f95
subroutine smoothsimfast(yt, ymiss, timevar, zt, ht,tt, rtv,qt,a1, ft,kt,&
finf, kinf, dt, jt, p, m, n,r,tol,epshat,etahat,rt0,rt1,needeps)

    implicit none

    logical, intent(in) :: needeps
    integer, intent(in) ::  p, m, r,n,dt,jt
    integer ::  t, i,d,j
    integer, intent(in), dimension(n,p) :: ymiss
    integer, intent(in), dimension(5) :: timevar
    double precision, intent(in), dimension(n,p) :: yt
    double precision, intent(in), dimension(p,m,(n-1)*timevar(1)+1) :: zt
    double precision, intent(in), dimension(p,p,(n-1)*timevar(2)+1) :: ht
    double precision, intent(in), dimension(m,m,(n-1)*timevar(3)+1) :: tt
    double precision, intent(in), dimension(m,r,(n-1)*timevar(4)+1) :: rtv
    double precision, intent(in), dimension(r,r,(n-1)*timevar(5)+1) :: qt
    double precision, intent(in), dimension(m) :: a1
    double precision, intent(in), dimension(p,n) :: ft,finf
    double precision, intent(in), dimension(m,p,n) :: kt,kinf
    double precision, intent(in) :: tol
    double precision, intent(inout), dimension(p,n) :: epshat
    double precision, intent(inout), dimension(r,n) :: etahat
    double precision, dimension(p,n) :: vt
    double precision, dimension(m) :: arec,rrec,rrec1,rhelp,help
    double precision, dimension(m,m) :: im,linf,l0,lt
    double precision, intent(inout), dimension(m) :: rt0,rt1
    double precision :: meps
    double precision, external :: ddot

 meps = tiny(meps)

    j=0
    d=0
    if(dt.GT.0) then
        arec = a1
        diffuse: do while(d .LT. (dt-1))
            d = d+1
            do j=1, p
                if(ymiss(d,j).EQ.0) then
                    vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1) !arec
                    if (finf(j,d) .GT. tol) then
                        call daxpy(m,vt(j,d)/finf(j,d),kinf(:,j,d),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                    else
                        if(ft(j,d) .GT. meps) then
                            call daxpy(m,vt(j,d)/ft(j,d),kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                        end if
                    end if
                end if
            end do
           
            call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,help,1)  !at(:,t+1) = matmul(tt,a_rec)
            arec = help
        end do diffuse

        d = dt
        do j=1, jt
            if(ymiss(d,j).EQ.0) then
                vt(j,d) = yt(d,j) - ddot(m,zt(j,:,(d-1)*timevar(1)+1),1,arec,1) !arec
      
                if (finf(j,d) .GT. tol) then
                    call daxpy(m,vt(j,d)/finf(j,d),kinf(:,j,d),1,arec,1) !a_rec = a_rec + kinf(:,i,t)*vt(:,t)/finf(j,d)
                else
                    if(ft(j,d) .GT. meps ) then
                        call daxpy(m,vt(j,d)/ft(j,d),kt(:,j,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)/ft(i,t)
                    end if
                end if
            end if
        end do
   
  
        !non-diffuse filtering begins
 
        do i = jt+1, p
            if(ymiss(d,i).EQ.0) then
                vt(i,d) = yt(d,i) - ddot(m,zt(i,:,(d-1)*timevar(1)+1),1,arec,1) !vt
                if (ft(i,d) .GT.  meps) then !ft.NE.0
                    call daxpy(m,vt(i,d)/ft(i,d),kt(:,i,d),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                end if
            end if
        end do
   
        call dgemv('n',m,m,1.0d0,tt(:,:,(d-1)*timevar(3)+1),m,arec,1,0.0d0,help,1)  !at(:,t+1) = matmul(tt,a_rec)
  
   
        arec =help
   
    end if

    if(dt.LT.n) then

        !Non-diffuse filtering continues from t=d+1, i=1
        if(dt.EQ.0) then
            arec = a1
        end if
        do t = dt+1, n
            do i = 1, p
                if(ymiss(t,i).EQ.0) then
                    vt(i,t) = yt(t,i) - ddot(m,zt(i,:,(t-1)*timevar(1)+1),1,arec,1) !variate vt
                    if (ft(i,t) .GT.  meps) then !ft.NE.0
                        call daxpy(m,vt(i,t)/ft(i,t),kt(:,i,t),1,arec,1) !a_rec = a_rec + kt(:,i,t)*vt(:,t)
                    end if
                end if
            end do
   
            call dgemv('n',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,arec,1,0.0d0,help,1)  !at(:,t+1) = matmul(tt,a_rec)           
   
            arec =help

        end do

    end if


    !smoothing begins

    im = 0.0d0
    do i = 1, m
        im(i,i) = 1.0d0
    end do

    rrec = 0.0d0

    !rt(:,n+1) = 0.0d0

    do t = n, dt+1, -1 !do until diffuse tts
        call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
        call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
        call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1) !r_t,p=t_t-1'*r_t+1
        rrec = rhelp
        do i = p, 1 , -1
            if(ymiss(t,i).EQ.0) then
                if(ft(i,t) .GT. meps) then
                    if(needeps) then
                        epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))/ft(i,t)
                    end if
                    lt = im
                    call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !l = I -kz
                    call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                    rrec = rhelp + vt(i,t)/ft(i,t)*zt(i,:,(t-1)*timevar(1)+1)
                end if
            end if
        end do
    end do

    if(dt.GT.0) then
        t=dt
        call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
        call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
   
        call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1) !tarkiSta tOimivUUS!
        rrec = rhelp       
  
        do i = p, (jt+1) , -1

            if(ymiss(t,i).EQ.0) then
                if(ft(i,t) .GT. meps) then
                    if(needeps) then
                        epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)/ft(i,t)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))
                    end if
                    lt = im
                    call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !l = i -kz
                    call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                    rrec=rhelp
                    call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1)
                end if
            end if
        end do

        rrec1 = 0.0d0
        do i = jt, 1, -1
            if(ymiss(t,i).EQ.0) then
                if(finf(i,t).GT.tol) then
                    if(needeps) then
                        epshat(i,t) = -ht(i,i,(t-1)*timevar(2)+1)*ddot(m,kinf(:,i,t),1,rrec,1)/finf(i,t)
                    end if
                    linf = im
                    call dger(m,m,-1.0d0/finf(i,t),kinf(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,linf,m) !linf
                    rhelp = -kt(:,i,t)
                    call daxpy(m,ft(i,t)/finf(i,t),kinf(:,i,t),1,rhelp,1)
                    l0=0.0d0
                    call dger(m,m,(1.0d0/finf(i,t)),rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0
                    call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                    call dcopy(m,rhelp,1,rrec1,1)
                    call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                    call daxpy(m,(vt(i,t)/finf(i,t)),zt(i,:,(t-1)*timevar(1)+1),1,rrec1,1)
                    call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                    rrec = rhelp


                else

                    if(ft(i,t).GT.meps) then
                        if(needeps) then
                            epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))/ft(i,t)
                        end if
                        lt= im
                        call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !lt = I -Kt*Z/Ft
                        call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1)
                        rrec = rhelp
                        call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1) !r0 = Z'vt/Ft - Lt'r0
                        call dgemv('t',m,m,1.0d0,lt,m,rrec1,1,0.0d0,rhelp,1)
                        rrec1=rhelp
                    end if
                end if
            end if
        end do

        do t=(dt-1), 1, -1
            call dgemv('t',m,r,1.0d0,rtv(:,:,(t-1)*timevar(4)+1),m,rrec,1,0.0d0,help,1)
            call dsymv('l',r,1.0d0,qt(:,:,(t-1)*timevar(5)+1),r,help,1,0.0d0,etahat(:,t),1)
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec,1,0.0d0,rhelp,1,1)
            rrec = rhelp
            call dgemv('t',m,m,1.0d0,tt(:,:,(t-1)*timevar(3)+1),m,rrec1,1,0.0d0,rhelp,1,1)
            rrec1 = rhelp

            do i = p, 1, -1
                if(ymiss(t,i).EQ.0) then
                    if(finf(i,t).GT. tol) then
                        if(needeps) then
                            epshat(i,t) = -ht(i,i,(t-1)*timevar(2)+1)*ddot(m,kinf(:,i,t),1,rrec,1)/finf(i,t)
                        end if
                        linf = im
                        call dger(m,m,-1.0d0/finf(i,t),kinf(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,linf,m) !linf
                        rhelp = -kt(:,i,t)
                        call daxpy(m,ft(i,t)/finf(i,t),kinf(:,i,t),1,rhelp,1)
                        l0=0.0d0
                        call dger(m,m,(1.0d0/finf(i,t)),rhelp,1,zt(i,:,(t-1)*timevar(1)+1),1,l0,m) !l0

                        call dgemv('t',m,m,1.0d0,linf,m,rrec1,1,0.0d0,rhelp,1) !rt1
                        call dcopy(m,rhelp,1,rrec1,1)
                        call dgemv('t',m,m,1.0d0,l0,m,rrec,1,1.0d0,rrec1,1)
                        call daxpy(m,vt(i,t)/finf(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec1,1)
                        call dgemv('t',m,m,1.0d0,linf,m,rrec,1,0.0d0,rhelp,1) !rt0
                        rrec = rhelp

                    else
                        if(ft(i,t).GT. meps) then
                            if(needeps) then
                                epshat(i,t) = ht(i,i,(t-1)*timevar(2)+1)*(vt(i,t)-ddot(m,kt(:,i,t),1,rrec,1))/ft(i,t)
                            end if
                            lt= im
                            call dger(m,m,-1.0d0/ft(i,t),kt(:,i,t),1,zt(i,:,(t-1)*timevar(1)+1),1,lt,m) !lt = I -Kt*Z/Ft
                            call dgemv('t',m,m,1.0d0,lt,m,rrec,1,0.0d0,rhelp,1) !oli beta 1.0d0!!!!... JA miinusmerkki
                            rrec = rhelp
                            call daxpy(m,vt(i,t)/ft(i,t),zt(i,:,(t-1)*timevar(1)+1),1,rrec,1) !r0 = Z'vt/Ft - Lt'r0
                            call dgemv('t',m,m,1.0d0,lt,m,rrec1,1,0.0d0,rhelp,1)
                            rrec1=rhelp

                        end if

                    end if
                end if
            end do


        end do
    end if
    rt0=rrec
    rt1=rrec1

end subroutine smoothsimfast
####$$$$ KFAS\tests/test-all.R
library(testthat)
test_check("KFAS")
####$$$$ KFAS\tests\testthat/testBasics.R
test_that("SSModel works properly",{
  tol<-1e-3
  set.seed(123)
  d<-data.frame(x=rnorm(100))
  t12<-ts(cbind(t1=rnorm(100)+d$x,t2=rnorm(100)))
  t12[sample(size=50,1:200)]<-NA
  expect_that( 
    model<-SSModel(t12~SSMcycle(period=10, type='common',Q=2)
                   +SSMcycle(period=10, type='distinct',P1=diag(c(1,1,2,2)),Q=diag(1:2))
                   +SSMtrend(2,type="common",Q=diag(c(1,0.5)))
                   +SSMtrend(2,type="distinct",Q=list(diag(0.1,2),diag(0.01,2)),P1=diag(c(0.1,0.01,0.1,0.01)))
                   +SSMseasonal(period=4,type="common")
                   +SSMseasonal(period=4,type="distinct",Q=diag(c(2,3)),P1=diag(c(2,2,2,3,3,3)))
                   +SSMseasonal(period=5,type="common",sea.type="trig")
                   +SSMseasonal(period=5,type="distinct",sea.type="trig",Q=diag(c(0.1,0.2)),
                                P1=diag(rep(c(0.1,0.2),each=4)))
                   +SSMarima(ar=0.9,ma=0.2)+SSMregression(~-1+x,index=1,Q=1,data=d)
    ),not(gives_warning()))
  expect_that(print(model),not(gives_warning()))
  expect_that(logLik(model),not(gives_warning()))
  expect_equal(logLik(model),-443.011122738032,tolerance=tol,check.attributes=FALSE)
  expect_that(out<-KFS(model,filtering=c("state","mean"),smoothing=c("state","mean","disturbance")),
              not(gives_warning()))
  expect_equal(out$d,11)
  expect_equal(out$j,1)
})####$$$$ KFAS\tests\testthat/testGLM.R
context("KFAS and glm comparison")

tol<-1e-3
require(MASS)
# Test for Gaussian
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
glm.gaussian <- glm(weight ~ group)
model.gaussian <- SSModel(weight~group)
tmp<-KFS(model.gaussian,filtering="state",smoothing="none")
model.gaussian <- SSModel(weight~group,H=mean(c(tmp$v[1:tmp$d][tmp$Finf==0]^2/tmp$F[1:tmp$d][tmp$Finf==0],
                                                tmp$v[-(1:tmp$d)]^2/tmp$F[-(1:tmp$d)])))
kfas.gaussian <-KFS(model.gaussian,smoothing=c('state','signal','mean'))

# Test for Poisson GLM
# Same example as in ?glm
d <- data.frame(treatment= gl(3,3), outcome = gl(3,1,9), counts = c(18,17,15,20,10,20,25,13,12))
glm.poisson <- glm(counts ~ outcome + treatment, data=d, family = poisson(),control=list(epsilon=1e-15))
model.poisson<-SSModel(counts ~ outcome + treatment, data=d, distribution = 'poisson')
kfas.poisson<-KFS(model.poisson,smoothing=c('state','signal','mean'))

## Test for Binomial GLM
## example from Venables and Ripley (2002, pp. 190-2.)
ldose <- rep(0:5, 2)
numdead <- c(1, 4, 9, 13, 18, 20, 0, 2, 6, 10, 12, 16)
sex <- factor(rep(c("M", "F"), c(6, 6)))
SF <- cbind(numdead, numalive = 20-numdead)
glm.binomial <- glm(SF ~ sex*ldose, family = binomial,control=list(epsilon=1e-15))
model.binomial<-SSModel(numdead ~ sex*ldose, u=20,distribution = 'binomial')
kfas.binomial<-KFS(model.binomial,smoothing=c('state','signal','mean'))

## Test for Gamma GLM
# A Gamma example from McCullagh & Nelder (1989, pp. 300-2)
clotting <- data.frame(
  u = c(5,10,15,20,30,40,60,80,100),
  lot1 = c(118,58,42,35,27,25,21,19,18),
  lot2 = c(69,35,26,21,18,16,13,12,12))
glm.gamma<-glm(lot1 ~ log(u), data = clotting, family = Gamma("log"),control=list(epsilon=1e-15))
#dispersion=1
model.gamma1<-SSModel(lot1 ~ log(u), data = clotting, distribution = 'gamma')
kfas.gamma1<-KFS(model.gamma1,smoothing=c('state','signal','mean'))
#dispersion from gamma.glm
model.gamma2<-SSModel(lot1 ~ log(u), u = 1/summary(glm.gamma)$dispersion, data = clotting, distribution = 'gamma')
kfas.gamma2<-KFS(model.gamma2,smoothing=c('state','signal','mean'))  

## Test for NB GLM
## From MASS library, ?glm.nb
glm.NB <- glm.nb(Days ~ Sex/(Age + Eth*Lrn), data = quine,control=glm.control(epsilon=1e-12))

# estimate theta
theta0<-1
model.NB<-SSModel(Days ~ Sex/(Age + Eth*Lrn), u=theta0, data = quine, distribution = 'negative binomial')
kfas.NB<-KFS(model.NB,smoothing='mean')
theta<-theta.ml(y=quine$Days,mu=c(fitted(kfas.NB)))
maxit<-10
i<-0
while(abs(theta-theta0)/theta0>1e-7 && i<maxit){
  model.NB$u[]<-theta0<-theta
  kfas.NB<-KFS(model.NB,smoothing='mean')
  theta<-theta.ml(y=quine$Days,mu=c(fitted(kfas.NB)))
  i<-i+1
}
model.NB$u[]<-theta
kfas.NB<-KFS(model.NB,smoothing=c('state','signal','mean'),convtol=1e-15)

test_that("Gaussian GLM fitting works properly",{
  for(i in 1:length(model.gaussian$y))
    expect_equal(coef(kfas.gaussian,start=i,end=i),coef(glm.gaussian),
                 tolerance=tol, check.attributes=FALSE, info=paste("Error in time step",i))
  for(i in 1:length(model.gaussian$y))
    expect_equal(kfas.gaussian$V[,,i],summary(glm.gaussian)$cov.s,tolerance=tol, check.attributes=FALSE,
                 info=paste("Error in time step",i))
  expect_equal(c(fitted(kfas.gaussian)),fitted(glm.gaussian),tolerance=tol, check.attributes=FALSE)
  expect_equal(c(kfas.gaussian$V_mu),predict(glm.gaussian,type='response',se.fit=TRUE)$se.fit^2
               ,tolerance=tol, check.attributes=FALSE)
  expect_equal(deviance(kfas.gaussian),deviance(glm.gaussian),tolerance=tol, check.attributes=FALSE)
})

test_that("Poisson GLM fitting works properly",{
  for(i in 1:length(model.poisson$y))
    expect_equal(coef(kfas.poisson,start=i,end=i),coef(glm.poisson),info=paste("Error in time step",i)
                 ,tolerance=tol, check.attributes=FALSE)
  for(i in 1:length(model.poisson$y))
    expect_equal(kfas.poisson$V[,,i],summary(glm.poisson)$cov.s,info=paste("Error in time step",i)
                 ,tolerance=tol, check.attributes=FALSE)
  ## linear
  expect_equal(c(kfas.poisson$thetahat),glm.poisson$linear.predictor,tolerance=tol, check.attributes=FALSE)
  ## predictions on response scale
  expect_equal(c(fitted(kfas.poisson)),fitted(glm.poisson),tolerance=tol, check.attributes=FALSE)
  # prediction variances on link scale
  expect_equal(c(kfas.poisson$V_theta),predict(glm.poisson,type='link',se.fit=TRUE)$se.fit^2
               ,tolerance=tol, check.attributes=FALSE)
  # prediction variances on response scale
  expect_equal(c(kfas.poisson$V_mu),predict(glm.poisson,type='response',se.fit=TRUE)$se.fit^2
               ,tolerance=tol, check.attributes=FALSE)
  expect_equal(deviance(kfas.poisson),deviance(glm.poisson),tolerance=tol, check.attributes=FALSE)
})


test_that("binomial GLM fitting works properly",{
  for(i in 1:length(model.binomial$y))
    expect_equal(coef(kfas.binomial,start=i,end=i),coef(glm.binomial),
                 info=paste("Error in time step",i),tolerance=tol, check.attributes=FALSE)
  for(i in 1:length(model.binomial$y))
    expect_equal(kfas.binomial$V[,,i],summary(glm.binomial)$cov.s,
                 info=paste("Error in time step",i),tolerance=tol, check.attributes=FALSE)
  ## linear
  expect_equal(c(kfas.binomial$thetahat),glm.binomial$linear.predictor,tolerance=tol, check.attributes=FALSE)
  ## predictions on response scale
  expect_equal(c(fitted(kfas.binomial)),fitted(glm.binomial),tolerance=tol, check.attributes=FALSE)
  # prediction variances on link scale
  expect_equal(c(kfas.binomial$V_theta),
               predict(glm.binomial,type='link',se.fit=TRUE)$se.fit^2,tolerance=tol, check.attributes=FALSE)
  # prediction variances on response scale
  expect_equal(c(kfas.binomial$V_mu),
               predict(glm.binomial,type='response',se.fit=TRUE)$se.fit^2,tolerance=tol, check.attributes=FALSE)
  expect_equal(deviance(kfas.binomial),deviance(glm.binomial),tolerance=tol, check.attributes=FALSE)
})


test_that("gamma GLM fitting works properly",{
  for(i in 1:length(model.gamma1$y))
    expect_equal(coef(kfas.gamma1,start=i,end=i),coef(glm.gamma),
                 info=paste("Error in time step",i, ", dispersion=1"),tolerance=tol, check.attributes=FALSE)
  for(i in 1:length(model.gamma1$y))
    expect_equal(kfas.gamma1$V[,,i],summary(glm.gamma,dispersion=1)$cov.s,
                      info=paste("Error in time step",i, ", dispersion=1"),tolerance=tol, check.attributes=FALSE)  
  expect_equal(c(kfas.gamma1$thetahat),glm.gamma$linear.predictor,
                    info=paste("dispersion=1"),tolerance=tol, check.attributes=FALSE)
  ## predictions on response scale
  expect_equal(c(fitted(kfas.gamma1)),fitted(glm.gamma),info=paste("dispersion=1"),tolerance=tol, check.attributes=FALSE)
  # prediction variances on link scale
  expect_equal(c(kfas.gamma1$V_theta),
                    predict(glm.gamma,type='link',se.fit=TRUE,dispersion=1)$se.fit^2,
                    info=paste("dispersion=1"),tolerance=tol, check.attributes=FALSE)
  # prediction variances on response scale
  expect_equal(c(kfas.gamma1$V_mu),predict(glm.gamma,type='response',se.fit=TRUE,dispersion=1)$se.fit^2,
                    info=paste("dispersion=1"),tolerance=tol, check.attributes=FALSE)
  for(i in 1:length(model.gamma2$y))
    expect_equal(coef(kfas.gamma2,start=i,end=i),coef(glm.gamma),
                 info=paste("Error in time step",i),tolerance=tol, check.attributes=FALSE)
  for(i in 1:length(model.gamma2$y))
    expect_equal(kfas.gamma2$V[,,i],summary(glm.gamma)$cov.s,
                 info=paste("Error in time step",i),tolerance=tol, check.attributes=FALSE)
  ## linear
  expect_equal(c(kfas.gamma2$theta),glm.gamma$linear.predictor,tolerance=tol, check.attributes=FALSE)
  ## predictions on response scale
  expect_equal(c(fitted(kfas.gamma2)),fitted(glm.gamma),tolerance=tol, check.attributes=FALSE)
  # prediction variances on link scale
  expect_equal(c(kfas.gamma2$V_theta),
               predict(glm.gamma,type='link',se.fit=TRUE)$se.fit^2,tolerance=tol, check.attributes=FALSE)
  # prediction variances on response scale
  expect_equal(c(kfas.gamma2$V_mu),
               predict(glm.gamma,type='response',se.fit=TRUE)$se.fit^2,tolerance=tol, check.attributes=FALSE)
  expect_equal(deviance(kfas.gamma2),deviance(glm.gamma),tolerance=tol, check.attributes=FALSE)
})

test_that("negative binomial GLM fitting works properly",{
  
  for(i in 1:length(model.NB$y))
    expect_equal(coef(kfas.NB,start=i,end=i),coef(glm.NB),info=paste("Error in time step",i),tolerance=tol, check.attributes=FALSE)
  for(i in 1:length(model.NB$y))
    expect_equal(kfas.NB$V[,,i],summary(glm.NB)$cov.s,
                      info=paste("Error in time step",i),tolerance=tol, check.attributes=FALSE)
  
  expect_equal(c(kfas.NB$thetahat),glm.NB$linear.predictor,tolerance=tol, check.attributes=FALSE)
  ## predictions on response scale
  expect_equal(c(fitted(kfas.NB)),fitted(glm.NB),tolerance=tol, check.attributes=FALSE)
  # prediction variances on link scale
  expect_equal(c(kfas.NB$V_theta),
                    predict(glm.NB,type='link',se.fit=TRUE,dispersion=1)$se.fit^2,tolerance=tol, check.attributes=FALSE)
  # prediction variances on response scale
  expect_equal(c(kfas.NB$V_mu),predict(glm.NB,type='response',se.fit=TRUE,)$se.fit^2,tolerance=tol, check.attributes=FALSE)
  
  expect_equal(model.NB$u[1],glm.NB$theta,tolerance=tol, check.attributes=FALSE)
  
  likfn<-function(pars,model,estimate=TRUE){ 
    model$u[]<-exp(pars[1])
    model$P1inf[]<-0
    model$a1[]<-pars[2:15]
    if(estimate)
      return(-logLik(model,check=TRUE,nsim=0))
    model
  }
  
  fit<-optim(f=likfn,p=c(log(glm.NB$theta),glm.NB$coef),model=model.NB)
  expect_equal(c(exp(fit$p[1]),fit$p[-1]),c(glm.NB$theta,glm.NB$coef),tolerance=tol, check.attributes=FALSE)
  expect_equal(deviance(kfas.NB),deviance(glm.NB),tolerance=tol, check.attributes=FALSE)
})


test_that("Residuals for Gaussian GLM works properly",{
  expect_equal(as.numeric(residuals(kfas.gaussian,type="deviance")),
                    residuals(glm.gaussian,type="deviance"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.gaussian,type="pearson")),
                    residuals(glm.gaussian,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.gaussian,type="response")),
                    residuals(glm.gaussian,type="response"),tolerance=tol, check.attributes=FALSE)
  
  expect_equal(as.numeric(rstandard(kfas.gaussian,type="pearson")),
                    rstandard(glm.gaussian,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(rstandard(kfas.gaussian,type="deviance")),
                    rstandard(glm.gaussian,type="deviance"),tolerance=tol, check.attributes=FALSE)
})


test_that("Residuals for Poisson GLM works properly",{
  expect_equal(as.numeric(residuals(kfas.poisson,type="deviance")),
                    residuals(glm.poisson,type="deviance"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.poisson,type="pearson")),
                    residuals(glm.poisson,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.poisson,type="response")),
                    residuals(glm.poisson,type="response"),tolerance=tol, check.attributes=FALSE)
  
  expect_equal(as.numeric(rstandard(kfas.poisson,type="pearson")),
                    rstandard(glm.poisson,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(rstandard(kfas.poisson,type="deviance")),
                    rstandard(glm.poisson,type="deviance"),tolerance=tol, check.attributes=FALSE)
})


test_that("Residuals for Binomial GLM works properly",{
  expect_equal(as.numeric(residuals(kfas.binomial,type="deviance")),
                    residuals(glm.binomial,type="deviance"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.binomial,type="pearson")),
                    residuals(glm.binomial,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.binomial,type="response")),
                    residuals(glm.binomial,type="response"),tolerance=tol, check.attributes=FALSE)
  
  expect_equal(as.numeric(rstandard(kfas.binomial,type="pearson")),
                    rstandard(glm.binomial,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(rstandard(kfas.binomial,type="deviance")),
                    rstandard(glm.binomial,type="deviance"),tolerance=tol, check.attributes=FALSE)
})


test_that("Residuals for Gamma GLM works properly",{
  expect_equal(as.numeric(residuals(kfas.gamma2,type="deviance")),
                    residuals(glm.gamma,type="deviance"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.gamma2,type="pearson")),
                    residuals(glm.gamma,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.gamma2,type="response")),
                    residuals(glm.gamma,type="response"),tolerance=tol, check.attributes=FALSE)
  
  expect_equal(as.numeric(rstandard(kfas.gamma2,type="pearson")),
                    rstandard(glm.gamma,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(rstandard(kfas.gamma2,type="deviance")),
                    rstandard(glm.gamma,type="deviance"),tolerance=tol, check.attributes=FALSE)
})


test_that("Residuals for negative binomial GLM works properly",{
  expect_equal(as.numeric(residuals(kfas.NB,type="deviance")),
                    residuals(glm.NB,type="deviance"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.NB,type="pearson")),
                    residuals(glm.NB,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(residuals(kfas.NB,type="response")),
                    residuals(glm.NB,type="response"),tolerance=tol, check.attributes=FALSE)
  
  expect_equal(as.numeric(rstandard(kfas.NB,type="pearson")),
                    rstandard(glm.NB,type="pearson"),tolerance=tol, check.attributes=FALSE)
  expect_equal(as.numeric(rstandard(kfas.NB,type="deviance")),
                    rstandard(glm.NB,type="deviance"),tolerance=tol, check.attributes=FALSE)
})


test_that("Predictions for GLM works properly",{
  pred.glm.gaussian.link<-predict(glm.gaussian,type="link",se.fit=TRUE)
  pred.kfas.gaussian.link<-predict(model.gaussian,type="link",se.fit=TRUE,interval="confidence")
  pred.glm.gaussian.response<-predict(glm.gaussian,type="response",se.fit=TRUE)
  pred.kfas.gaussian.response<-predict(model.gaussian,type="response",se.fit=TRUE,interval="confidence")  
  expect_equal(c(pred.kfas.gaussian.link[,"fit"]),pred.glm.gaussian.link$fit,tolerance=tol, check.attributes=FALSE)
  expect_equal(c(pred.kfas.gaussian.link[,"se.fit"]),pred.glm.gaussian.link$se.fit,tolerance=tol, check.attributes=FALSE)
  expect_equal(c(pred.kfas.gaussian.response[,"fit"]),pred.glm.gaussian.response$fit,tolerance=tol, check.attributes=FALSE)
  expect_equal(c(pred.kfas.gaussian.response[,"se.fit"]),pred.glm.gaussian.response$se.fit,tolerance=tol, check.attributes=FALSE)
  
  
  pred.glm.poisson.link<-predict(glm.poisson,type="link",se.fit=TRUE)
  pred.kfas.poisson.link<-predict(model.poisson,type="link",se.fit=TRUE,interval="confidence")
  pred.glm.poisson.response<-predict(glm.poisson,type="response",se.fit=TRUE)
  pred.kfas.poisson.response<-predict(model.poisson,type="response",se.fit=TRUE,interval="confidence")  
  expect_equal(pred.glm.poisson.link$fit,obj=c(pred.kfas.poisson.link[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.poisson.link$se.fit,obj=c(pred.kfas.poisson.link[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.poisson.response$fit,obj=c(pred.kfas.poisson.response[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.poisson.response$se.fit,obj=c(pred.kfas.poisson.response[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  
  
  pred.glm.binomial.link<-predict(glm.binomial,type="link",se.fit=TRUE)
  pred.kfas.binomial.link<-predict(model.binomial,type="link",se.fit=TRUE,interval="confidence")
  pred.glm.binomial.response<-predict(glm.binomial,type="response",se.fit=TRUE)
  pred.kfas.binomial.response<-predict(model.binomial,type="response",se.fit=TRUE,interval="confidence")  
  expect_equal(pred.glm.binomial.link$fit,obj=c(pred.kfas.binomial.link[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.binomial.link$se.fit,obj=c(pred.kfas.binomial.link[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.binomial.response$fit,obj=c(pred.kfas.binomial.response[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.binomial.response$se.fit,obj=c(pred.kfas.binomial.response[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  
  
  pred.glm.gamma.link<-predict(glm.gamma,type="link",se.fit=TRUE)
  pred.kfas.gamma.link<-predict(model.gamma2,type="link",se.fit=TRUE,interval="confidence")
  pred.glm.gamma.response<-predict(glm.gamma,type="response",se.fit=TRUE)
  pred.kfas.gamma.response<-predict(model.gamma2,type="response",se.fit=TRUE,interval="confidence")  
  expect_equal(pred.glm.gamma.link$fit,obj=c(pred.kfas.gamma.link[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.gamma.link$se.fit,obj=c(pred.kfas.gamma.link[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.gamma.response$fit,obj=c(pred.kfas.gamma.response[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.gamma.response$se.fit,obj=c(pred.kfas.gamma.response[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  
  
  pred.glm.NB.link<-predict(glm.NB,type="link",se.fit=TRUE)
  pred.kfas.NB.link<-predict(model.NB,type="link",se.fit=TRUE,interval="confidence")
  pred.glm.NB.response<-predict(glm.NB,type="response",se.fit=TRUE)
  pred.kfas.NB.response<-predict(model.NB,type="response",se.fit=TRUE,interval="confidence")  
  expect_equal(pred.glm.NB.link$fit,obj=c(pred.kfas.NB.link[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.NB.link$se.fit,obj=c(pred.kfas.NB.link[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.NB.response$fit,obj=c(pred.kfas.NB.response[,"fit"]),tolerance=tol, check.attributes=FALSE)
  expect_equal(pred.glm.NB.response$se.fit,obj=c(pred.kfas.NB.response[,"se.fit"]),tolerance=tol, check.attributes=FALSE)
  
  #confidence intervals
  glm.gaussian.CI<-pred.glm.gaussian.link$fit +qnorm(0.025)*pred.glm.gaussian.link$se.fit%o%c(1,-1)
  expect_equal(unclass(pred.kfas.gaussian.link[,c("lwr","upr")]),glm.gaussian.CI,tolerance=tol, check.attributes=FALSE)
  expect_equal(unclass(pred.kfas.gaussian.response[,c("lwr","upr")]),gaussian()$linkinv(glm.gaussian.CI),tolerance=tol, check.attributes=FALSE)
  
  glm.poisson.CI<-pred.glm.poisson.link$fit +qnorm(0.025)*pred.glm.poisson.link$se.fit%o%c(1,-1)
  expect_equal(unclass(pred.kfas.poisson.link[,c("lwr","upr")]),glm.poisson.CI,tolerance=tol, check.attributes=FALSE)
  expect_equal(unclass(pred.kfas.poisson.response[,c("lwr","upr")]),poisson()$linkinv(glm.poisson.CI),tolerance=tol, check.attributes=FALSE)
  
  glm.binomial.CI<-pred.glm.binomial.link$fit +qnorm(0.025)*pred.glm.binomial.link$se.fit%o%c(1,-1)
  expect_equal(unclass(pred.kfas.binomial.link[,c("lwr","upr")]),glm.binomial.CI,tolerance=tol, check.attributes=FALSE)
  expect_equal(unclass(pred.kfas.binomial.response[,c("lwr","upr")]),binomial()$linkinv(glm.binomial.CI),tolerance=tol, check.attributes=FALSE)
  
  glm.gamma.CI<-pred.glm.gamma.link$fit +qnorm(0.025)*pred.glm.gamma.link$se.fit%o%c(1,-1)
  expect_equal(unclass(pred.kfas.gamma.link[,c("lwr","upr")]),glm.gamma.CI,tolerance=tol, check.attributes=FALSE)
  expect_equal(unclass(pred.kfas.gamma.response[,c("lwr","upr")]),Gamma(link="log")$linkinv(glm.gamma.CI),tolerance=tol, check.attributes=FALSE)
  
  glm.NB.CI<-pred.glm.NB.link$fit +qnorm(0.025)*pred.glm.NB.link$se.fit%o%c(1,-1)
  expect_equal(unclass(pred.kfas.NB.link[,c("lwr","upr")]),glm.NB.CI,tolerance=tol, check.attributes=FALSE)
  expect_equal(unclass(pred.kfas.NB.response[,c("lwr","upr")]),glm.NB$family$linkinv(glm.NB.CI),tolerance=tol, check.attributes=FALSE)
})
##

# #Estimate dispersion:
# 
# x<-rnorm(10000)
# beta<-2
# dispersion<-1
# y<-rgamma(n=length(x),shape=1/dispersion,scale=exp(beta*x)*dispersion)
# 
# glmfit<-glm(y~x,family=Gamma("log"),control=list(epsilon=1e-15,maxit=10000))
# 
# model<-SSModel(y~x,distribution="gamma")
# likfn_u<-function(pars,model,estimate=TRUE){ 
#   model$u[]<-exp(pars)
#   if(estimate)
#     return(-logLik(model,check=TRUE))
#   model
# }
# fit_u<-nlm(f=likfn_u,p=log(dispersion),model=model)
# sort(abs(c(glm=summary(glmfit)$disp,MASS=1/gamma.shape(glmfit,it.lim=1000,eps=1e-15)$alpha,
#            KFAS=exp(fit_u$e))-dispersion))

#imp<-importanceSSM(model.gamma2,nsim=10000,antit=T,type="signal")
##imp$s<-exp(imp$s)
#weighted.hist(imp$s[1,1,],imp$w)

# imp<-importanceSSM(model.binomial,nsim=10000,antit=TRUE,type="signal")
# imp$s<-exp(imp$s)/(1 + exp(imp$s))
# weighted.hist(imp$s[10,1,],imp$w)
####$$$$ KFAS\tests\testthat/testSSMarima.R
test_that("arimaSSM works properly",{
tol<-1e-3
s <- 12
phis <- 0.99
phi1 <- 0.0001
phi <- c(phi1,rep(0,s-2),phis,-phi1*phis)
theta <-0.7
out <- makeARIMA(phi,theta,NULL,SSinit="Ross")
min(eigen(out$Pn)$value)
out2<-SSMarima(phi,theta)
expect_equal(out$Pn,out2$P1,tolerance=tol,check.attributes=FALSE)
expect_equal(out$T,out2$T,tolerance=tol,check.attributes=FALSE)
expect_equal(out$Z,c(out2$Z),tolerance=tol,check.attributes=FALSE)
})####$$$$ KFAS\tests\testthat/testStruct.R
context("Structural time series tests")

tol<-1e-3

test_that("StructTS and KFS give equivalent results",{
require(graphics)
trees <- window(treering, start = 0)
fit <- StructTS(trees, type = "level")
# Construct model per StructTS:
model<-SSModel(trees~SSMtrend(degree=1,Q=fit$coef[1],P1=fit$model0$P,a1=fit$model0$a),H=fit$coef[2])
out<-KFS(model)
expect_equal(c(fitted(fit)),coef(out,filtered=TRUE)[-1],tolerance=tol, check.attributes=FALSE)
expect_equal(fit$loglik,logLik(model),tolerance=tol, check.attributes=FALSE)

fit2 <- StructTS(trees, type = "level",fixed=c(NA,1e-15))
model<-SSModel(trees~SSMtrend(degree=1,Q=fit2$coef[1],P1=fit2$model0$P,a1=fit2$model0$a),H=fit2$coef[2])
expect_less_than(abs(fit2$loglik-logLik(model)),1e-4)
fit2 <- StructTS(trees, type = "level",fixed=c(1e-15,NA))
model<-SSModel(trees~SSMtrend(degree=1,Q=fit2$coef[1],P1=fit2$model0$P,a1=fit2$model0$a),H=fit2$coef[2])
expect_less_than(abs(fit2$loglik-logLik(model)),1e-11)

model<-SSModel(trees~SSMtrend(degree=1,Q=NA),H=NA)
fit2<-fitSSM(model,inits=c(0,0),method="BFGS")
expect_equal(c(fit2$model$H),fit$coef[2],tolerance=tol, check.attributes=FALSE)
expect_less_than(abs(c(fit2$model$Q)-fit$coef[1]),1e-9)
})