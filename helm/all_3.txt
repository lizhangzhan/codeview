####$$$$ activeH5-master/DESCRIPTION
Package: activeH5
Type: Package
Title: Easy to use API to read and write very large matrices and data frames to
    disk and in memory in chunks
Version: 0.0.2
Date: 2014-08-28
Author: Chibisi Chima-Okereke
Maintainer: Chibisi Chima-Okereke <chibisi@activeanalytics.co.uk>
Description: This package is written in C/C++ and uses R's reference classes to
    provide an API to read and write large matrices and data frames to disk and
    memory using chunking algorithms. The file format is based on HDF5 but uses
    meta data to store the data frame structure. Any character columns are
    converted to factors. On disk, the data itself is stored as numeric
    matrices and on read-into R it is converted back to data frame.
License: MIT
Depends:
    Rcpp (>= 0.11.2),R (>= 3.1.1), methods
LinkingTo: Rcpp
Collate:
    'RcppExports.R'
    'h5Classes.r'
    'h5DF.r'
    'h5MAT.r'
    'h5MEMDF.r'
    'h5MEMMAT.r'
    'activeH5.r'
####$$$$ activeH5-master/LICENSE
The MIT License (MIT)

Copyright (c) 2014 Chibisi Chima-Okereke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
####$$$$ activeH5-master/NAMESPACE
useDynLib(activeH5)
exportPattern("^[[:alpha:]]+")
####$$$$ activeH5-master/README.md
# activeH5 is a package for writing/reading large data frames and matrices in chunks

## Introduction

activeH5 provides a set of tools to allow large data frames and matrices to be written to file and to memory and are stored in chunks. On file the data is stored in H5 format and in memory pointers are used to access chunks of data. The data objects are written as reference classes and are h5DF, h5MAT, h5MEMDF, and h5MEMMAT.

With the release of this package open source, it is our intention to more actively maintain and update this. Our first priority is to make the read/write even faster and provide option for compressing the data as well as more user friendly features.

You can visit our website on <http://www.active-analytics.com>.

## Installation

**Pre-requisite:** HDF5 serial version.

**OS:** Linux (Ubuntu), not tested on Windows.

The package can be installed directly from GitHub using the devtools <https://github.com/hadley/devtools> package:

```
require(devtools)
install_github("ActiveAnalytics/activeH5")
require(activeH5)
```

# Quick Intro

Just a quick intro to the basic functions in this package:

```
> ir1 <- newH5DF(iris[1:50,], "iris.h5", 5)
Initializing ...
Creating meta data on file ... 
Converting character to factors 
Registering any factor columns 
Creating the matrix for writing ... 
Writing data to file ... 


> ir1 <- newH5DF(iris[1:100,], "iris.h5", 10)
Initializing ...
Creating meta data on file ... 
Converting character to factors 
Registering any factor columns 
Creating the matrix for writing ... 
Writing data to file ... 


> ir1$append(iris[101:150, ])
Updating meta data on file ... 
Appending data to file ... 

# The names of the chunks
> ir1$chunkNames
[1] "ch1"  "ch2"  "ch3"  "ch4"  "ch5"  "ch6"  "ch7"  "ch8"  "ch9"  "ch10" "ch11" "ch12" "ch13" "ch14" "ch15"

# Size of the chunks
> ir1$chunkSize
[1] 10

# Names of the columns
> ir1$colNames
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"

# Reading a chunk
> ir1$readChunk("ch1")
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa

> ir1$readTable()
Reading the data from H5 file ... 
H5 data read, now formatting the data ... 
    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
1            5.1         3.5          1.4         0.2     setosa
2            4.9         3.0          1.4         0.2     setosa
3            4.7         3.2          1.3         0.2     setosa
4            4.6         3.1          1.5         0.2     setosa
5            5.0         3.6          1.4         0.2     setosa
6            5.4         3.9          1.7         0.4     setosa
7            4.6         3.4          1.4         0.3     setosa
8            5.0         3.4          1.5         0.2     setosa
9            4.4         2.9          1.4         0.2     setosa
10           4.9         3.1          1.5         0.1     setosa
...

# The meta data
> ir1
Reference class object of class "h5DF"
Field "nChunks":
[1] 15
Field "chunkNames":
 [1] "ch1"  "ch2"  "ch3"  "ch4"  "ch5"  "ch6"  "ch7"  "ch8"  "ch9"  "ch10" "ch11" "ch12" "ch13" "ch14" "ch15"
Field "colNames":
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"     
Field "colClasses":
Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
   "numeric"    "numeric"    "numeric"    "numeric"     "factor" 
Field "nrows":
[1] 150
Field "ncols":
[1] 5
Field "filePath":
[1] "iris.h5"
Field "nfactors":
[1] 1
Field "factors":
$Species
[1] "setosa"     "versicolor" "virginica" 

Field "chunkSize":
[1] 10
Field "MAT":
     [,1]
[1,]    0
Field "oldNChunks":
[1] 0
```

For more information:

```
?activeH5
?newH5DF
?openH5DF
?openH5MAT
?newH5MAT
?newH5MEMDF
?newH5MEMMAT
```

All the functions in the package namespace can be viewed using:

```
objects("package:activeH5")
```
... and they all have associated `?help` documentation.

# Details

The h5DF object is used to store very large data frames on disk. The data itself is stores as purely numerical data. Character columns are converted to factors and factors to numeric data, then each chunk is stores as a matrix. This means that the I/O speed is fast. Meta data associated with factors are stored in the file and the h5DF object and are recombined with the daat as it is read back into R.

The h5MAT object is used to store very large matrices on disk in chunks. The data is assumed to be numeric data so I/O speed is fast even faster than h5DF.

The h5MEMDF object is used to store very large data frames in memory as chunks with pointers to each chunk. Data can only be stored where there is sufficient memory to accomodate the object(s). Storing data like this makes it easier move, manipulate and work with very large datasets without the constant replication that occurs when using them in normal R functions. Since the data is stored in memory access time is faster than when the data is stored on disk.

The h5MEMMAT object is used to store very large matrices in memory as chunks. Again there are pointers to each chunk of data and there has to be sufficient memory to accomodate the object(s). Storing data like this makes it easier move, manipulate and work with very large datasets without the constant replication that occurs when using them in normal R functions. Since the data is stored in memory access time is faster than when stored on disk.

The HDF5 files generated by h5DF, h5MAT are not designed to be used with other software that use HDF5 objects. Any data that is created using the activeH5 module may not read back as expected with other HDF5 APIs.


## Contact

For help on the package please contact Chibisi Chima-Okereke: chibisi@active-analytics.com
####$$$$ activeH5-master/TODO.md
# TODO List

1.  A head() operation.
2. Chunking in the HDF5 API
3. Use of compression in the HDF5 API
4. In the column selection, instead of reading the whole chunk, read only the columns you require?
5.  Show methods on the functions, some basic meta (not everything) and maybe the head of the data set.
6.  Include read option for RDS files, if class(DF) == "character" check whether it is an RDS file, else read from CSV.
####$$$$ activeH5-master\inst\include/activeH5.h
// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#ifndef __activeH5_h__
#define __activeH5_h__

#include "activeH5_RcppExports.h"

#endif // __activeH5_h__
####$$$$ activeH5-master\inst\include/activeH5_RcppExports.h
// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#ifndef __activeH5_RcppExports_h__
#define __activeH5_RcppExports_h__

#include <Rcpp.h>

namespace activeH5 {

    using namespace Rcpp;

    namespace {
        void validateSignature(const char* sig) {
            Rcpp::Function require = Rcpp::Environment::base_env()["require"];
            require("activeH5", Rcpp::Named("quietly") = true);
            typedef int(*Ptr_validate)(const char*);
            static Ptr_validate p_validate = (Ptr_validate)
                R_GetCCallable("activeH5", "activeH5_RcppExport_validate");
            if (!p_validate(sig)) {
                throw Rcpp::function_not_exported(
                    "C++ function with signature '" + std::string(sig) + "' not found in activeH5");
            }
        }
    }

    inline SEXP createFactor(NumericVector x, CharacterVector levels) {
        typedef SEXP(*Ptr_createFactor)(SEXP,SEXP);
        static Ptr_createFactor p_createFactor = NULL;
        if (p_createFactor == NULL) {
            validateSignature("SEXP(*createFactor)(NumericVector,CharacterVector)");
            p_createFactor = (Ptr_createFactor)R_GetCCallable("activeH5", "activeH5_createFactor");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_createFactor(Rcpp::wrap(x), Rcpp::wrap(levels));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline int h5CreateFile(std::string filePath, int overwrite) {
        typedef SEXP(*Ptr_h5CreateFile)(SEXP,SEXP);
        static Ptr_h5CreateFile p_h5CreateFile = NULL;
        if (p_h5CreateFile == NULL) {
            validateSignature("int(*h5CreateFile)(std::string,int)");
            p_h5CreateFile = (Ptr_h5CreateFile)R_GetCCallable("activeH5", "activeH5_h5CreateFile");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5CreateFile(Rcpp::wrap(filePath), Rcpp::wrap(overwrite));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5CreateMetaData(std::string filePath) {
        typedef SEXP(*Ptr_h5CreateMetaData)(SEXP);
        static Ptr_h5CreateMetaData p_h5CreateMetaData = NULL;
        if (p_h5CreateMetaData == NULL) {
            validateSignature("int(*h5CreateMetaData)(std::string)");
            p_h5CreateMetaData = (Ptr_h5CreateMetaData)R_GetCCallable("activeH5", "activeH5_h5CreateMetaData");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5CreateMetaData(Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5WriteCharVector(std::string charName, SEXP charVec, std::string filePath, int update) {
        typedef SEXP(*Ptr_h5WriteCharVector)(SEXP,SEXP,SEXP,SEXP);
        static Ptr_h5WriteCharVector p_h5WriteCharVector = NULL;
        if (p_h5WriteCharVector == NULL) {
            validateSignature("int(*h5WriteCharVector)(std::string,SEXP,std::string,int)");
            p_h5WriteCharVector = (Ptr_h5WriteCharVector)R_GetCCallable("activeH5", "activeH5_h5WriteCharVector");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5WriteCharVector(Rcpp::wrap(charName), Rcpp::wrap(charVec), Rcpp::wrap(filePath), Rcpp::wrap(update));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5WriteInt(std::string intName, int integer, std::string filePath, int update) {
        typedef SEXP(*Ptr_h5WriteInt)(SEXP,SEXP,SEXP,SEXP);
        static Ptr_h5WriteInt p_h5WriteInt = NULL;
        if (p_h5WriteInt == NULL) {
            validateSignature("int(*h5WriteInt)(std::string,int,std::string,int)");
            p_h5WriteInt = (Ptr_h5WriteInt)R_GetCCallable("activeH5", "activeH5_h5WriteInt");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5WriteInt(Rcpp::wrap(intName), Rcpp::wrap(integer), Rcpp::wrap(filePath), Rcpp::wrap(update));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5WriteFactor(std::string charName, SEXP charVec, std::string filePath, int update) {
        typedef SEXP(*Ptr_h5WriteFactor)(SEXP,SEXP,SEXP,SEXP);
        static Ptr_h5WriteFactor p_h5WriteFactor = NULL;
        if (p_h5WriteFactor == NULL) {
            validateSignature("int(*h5WriteFactor)(std::string,SEXP,std::string,int)");
            p_h5WriteFactor = (Ptr_h5WriteFactor)R_GetCCallable("activeH5", "activeH5_h5WriteFactor");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5WriteFactor(Rcpp::wrap(charName), Rcpp::wrap(charVec), Rcpp::wrap(filePath), Rcpp::wrap(update));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5WriteDoubleMat(std::string dset, SEXP chunk, NumericVector dim, std::string filePath) {
        typedef SEXP(*Ptr_h5WriteDoubleMat)(SEXP,SEXP,SEXP,SEXP);
        static Ptr_h5WriteDoubleMat p_h5WriteDoubleMat = NULL;
        if (p_h5WriteDoubleMat == NULL) {
            validateSignature("int(*h5WriteDoubleMat)(std::string,SEXP,NumericVector,std::string)");
            p_h5WriteDoubleMat = (Ptr_h5WriteDoubleMat)R_GetCCallable("activeH5", "activeH5_h5WriteDoubleMat");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5WriteDoubleMat(Rcpp::wrap(dset), Rcpp::wrap(chunk), Rcpp::wrap(dim), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5FlushFile(std::string filePath) {
        typedef SEXP(*Ptr_h5FlushFile)(SEXP);
        static Ptr_h5FlushFile p_h5FlushFile = NULL;
        if (p_h5FlushFile == NULL) {
            validateSignature("int(*h5FlushFile)(std::string)");
            p_h5FlushFile = (Ptr_h5FlushFile)R_GetCCallable("activeH5", "activeH5_h5FlushFile");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5FlushFile(Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline int h5CloseFile(std::string filePath) {
        typedef SEXP(*Ptr_h5CloseFile)(SEXP);
        static Ptr_h5CloseFile p_h5CloseFile = NULL;
        if (p_h5CloseFile == NULL) {
            validateSignature("int(*h5CloseFile)(std::string)");
            p_h5CloseFile = (Ptr_h5CloseFile)R_GetCCallable("activeH5", "activeH5_h5CloseFile");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5CloseFile(Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline SEXP h5ReadCharVector(std::string charName, std::string filePath) {
        typedef SEXP(*Ptr_h5ReadCharVector)(SEXP,SEXP);
        static Ptr_h5ReadCharVector p_h5ReadCharVector = NULL;
        if (p_h5ReadCharVector == NULL) {
            validateSignature("SEXP(*h5ReadCharVector)(std::string,std::string)");
            p_h5ReadCharVector = (Ptr_h5ReadCharVector)R_GetCCallable("activeH5", "activeH5_h5ReadCharVector");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadCharVector(Rcpp::wrap(charName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5ReadFactor(std::string charName, std::string filePath) {
        typedef SEXP(*Ptr_h5ReadFactor)(SEXP,SEXP);
        static Ptr_h5ReadFactor p_h5ReadFactor = NULL;
        if (p_h5ReadFactor == NULL) {
            validateSignature("SEXP(*h5ReadFactor)(std::string,std::string)");
            p_h5ReadFactor = (Ptr_h5ReadFactor)R_GetCCallable("activeH5", "activeH5_h5ReadFactor");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadFactor(Rcpp::wrap(charName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline int h5ReadInt(std::string intName, std::string filePath) {
        typedef SEXP(*Ptr_h5ReadInt)(SEXP,SEXP);
        static Ptr_h5ReadInt p_h5ReadInt = NULL;
        if (p_h5ReadInt == NULL) {
            validateSignature("int(*h5ReadInt)(std::string,std::string)");
            p_h5ReadInt = (Ptr_h5ReadInt)R_GetCCallable("activeH5", "activeH5_h5ReadInt");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadInt(Rcpp::wrap(intName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline SEXP h5ReadDoubleMat(std::string chunkName, std::string filePath) {
        typedef SEXP(*Ptr_h5ReadDoubleMat)(SEXP,SEXP);
        static Ptr_h5ReadDoubleMat p_h5ReadDoubleMat = NULL;
        if (p_h5ReadDoubleMat == NULL) {
            validateSignature("SEXP(*h5ReadDoubleMat)(std::string,std::string)");
            p_h5ReadDoubleMat = (Ptr_h5ReadDoubleMat)R_GetCCallable("activeH5", "activeH5_h5ReadDoubleMat");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadDoubleMat(Rcpp::wrap(chunkName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline int h5DummyRead(std::string chunkName, std::string filePath) {
        typedef SEXP(*Ptr_h5DummyRead)(SEXP,SEXP);
        static Ptr_h5DummyRead p_h5DummyRead = NULL;
        if (p_h5DummyRead == NULL) {
            validateSignature("int(*h5DummyRead)(std::string,std::string)");
            p_h5DummyRead = (Ptr_h5DummyRead)R_GetCCallable("activeH5", "activeH5_h5DummyRead");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5DummyRead(Rcpp::wrap(chunkName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<int >(__result);
    }

    inline SEXP h5ModelFrame(std::string chunkName, SEXP selCols_, std::string filePath) {
        typedef SEXP(*Ptr_h5ModelFrame)(SEXP,SEXP,SEXP);
        static Ptr_h5ModelFrame p_h5ModelFrame = NULL;
        if (p_h5ModelFrame == NULL) {
            validateSignature("SEXP(*h5ModelFrame)(std::string,SEXP,std::string)");
            p_h5ModelFrame = (Ptr_h5ModelFrame)R_GetCCallable("activeH5", "activeH5_h5ModelFrame");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ModelFrame(Rcpp::wrap(chunkName), Rcpp::wrap(selCols_), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5ChunkList(std::string chunkName, std::string filePath) {
        typedef SEXP(*Ptr_h5ChunkList)(SEXP,SEXP);
        static Ptr_h5ChunkList p_h5ChunkList = NULL;
        if (p_h5ChunkList == NULL) {
            validateSignature("SEXP(*h5ChunkList)(std::string,std::string)");
            p_h5ChunkList = (Ptr_h5ChunkList)R_GetCCallable("activeH5", "activeH5_h5ChunkList");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ChunkList(Rcpp::wrap(chunkName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5ChunkSel(std::string chunkName, SEXP selCols, std::string filePath) {
        typedef SEXP(*Ptr_h5ChunkSel)(SEXP,SEXP,SEXP);
        static Ptr_h5ChunkSel p_h5ChunkSel = NULL;
        if (p_h5ChunkSel == NULL) {
            validateSignature("SEXP(*h5ChunkSel)(std::string,SEXP,std::string)");
            p_h5ChunkSel = (Ptr_h5ChunkSel)R_GetCCallable("activeH5", "activeH5_h5ChunkSel");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ChunkSel(Rcpp::wrap(chunkName), Rcpp::wrap(selCols), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5ReadDoubleMat2(std::string chunkName, std::string filePath) {
        typedef SEXP(*Ptr_h5ReadDoubleMat2)(SEXP,SEXP);
        static Ptr_h5ReadDoubleMat2 p_h5ReadDoubleMat2 = NULL;
        if (p_h5ReadDoubleMat2 == NULL) {
            validateSignature("SEXP(*h5ReadDoubleMat2)(std::string,std::string)");
            p_h5ReadDoubleMat2 = (Ptr_h5ReadDoubleMat2)R_GetCCallable("activeH5", "activeH5_h5ReadDoubleMat2");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadDoubleMat2(Rcpp::wrap(chunkName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5ReadDoubleMat3(std::string chunkName, std::string filePath) {
        typedef SEXP(*Ptr_h5ReadDoubleMat3)(SEXP,SEXP);
        static Ptr_h5ReadDoubleMat3 p_h5ReadDoubleMat3 = NULL;
        if (p_h5ReadDoubleMat3 == NULL) {
            validateSignature("SEXP(*h5ReadDoubleMat3)(std::string,std::string)");
            p_h5ReadDoubleMat3 = (Ptr_h5ReadDoubleMat3)R_GetCCallable("activeH5", "activeH5_h5ReadDoubleMat3");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadDoubleMat3(Rcpp::wrap(chunkName), Rcpp::wrap(filePath));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5WriteMemMAT(NumericMatrix obj) {
        typedef SEXP(*Ptr_h5WriteMemMAT)(SEXP);
        static Ptr_h5WriteMemMAT p_h5WriteMemMAT = NULL;
        if (p_h5WriteMemMAT == NULL) {
            validateSignature("SEXP(*h5WriteMemMAT)(NumericMatrix)");
            p_h5WriteMemMAT = (Ptr_h5WriteMemMAT)R_GetCCallable("activeH5", "activeH5_h5WriteMemMAT");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5WriteMemMAT(Rcpp::wrap(obj));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline SEXP h5WriteMemDF(DataFrame obj) {
        typedef SEXP(*Ptr_h5WriteMemDF)(SEXP);
        static Ptr_h5WriteMemDF p_h5WriteMemDF = NULL;
        if (p_h5WriteMemDF == NULL) {
            validateSignature("SEXP(*h5WriteMemDF)(DataFrame)");
            p_h5WriteMemDF = (Ptr_h5WriteMemDF)R_GetCCallable("activeH5", "activeH5_h5WriteMemDF");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5WriteMemDF(Rcpp::wrap(obj));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<SEXP >(__result);
    }

    inline NumericMatrix h5ReadMemMAT(SEXP ptr) {
        typedef SEXP(*Ptr_h5ReadMemMAT)(SEXP);
        static Ptr_h5ReadMemMAT p_h5ReadMemMAT = NULL;
        if (p_h5ReadMemMAT == NULL) {
            validateSignature("NumericMatrix(*h5ReadMemMAT)(SEXP)");
            p_h5ReadMemMAT = (Ptr_h5ReadMemMAT)R_GetCCallable("activeH5", "activeH5_h5ReadMemMAT");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadMemMAT(Rcpp::wrap(ptr));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<NumericMatrix >(__result);
    }

    inline DataFrame h5ReadMemDF(SEXP ptr) {
        typedef SEXP(*Ptr_h5ReadMemDF)(SEXP);
        static Ptr_h5ReadMemDF p_h5ReadMemDF = NULL;
        if (p_h5ReadMemDF == NULL) {
            validateSignature("DataFrame(*h5ReadMemDF)(SEXP)");
            p_h5ReadMemDF = (Ptr_h5ReadMemDF)R_GetCCallable("activeH5", "activeH5_h5ReadMemDF");
        }
        RObject __result;
        {
            RNGScope __rngScope;
            __result = p_h5ReadMemDF(Rcpp::wrap(ptr));
        }
        if (__result.inherits("interrupted-error"))
            throw Rcpp::internal::InterruptedException();
        if (__result.inherits("try-error"))
            throw Rcpp::exception(as<std::string>(__result).c_str());
        return Rcpp::as<DataFrame >(__result);
    }

}

#endif // __activeH5_RcppExports_h__
####$$$$ activeH5-master\inst\tests/test-h5DF.r
# Tests for h5DF objects

context("h5DF Tests")

test_that("Check creating file and meta data of h5DF object", {
  testH5 <- "iris.h5"
  ir1 <- newH5DF(iris[1:100,], testH5, 10)
  expect_true(class(ir1) == "h5DF", info = "Check that the class is h5DF")
  expect_true(file.exists(testH5), info = "Test that H5 file was created")
  expect_true(ir1$nrows == 100, "Check that the correct number of rows were written")
  expect_true(ir1$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(ir1$colClasses == sapply(iris, class)), info = "Check correct column classes written")
  expect_true(ir1$nfactors == 1, "Check the number of factors written")
  expect_true(all(dim(ir1$readChunk("ch2")) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(all(dim(ir1$readChunks(c("ch2", "ch3"))) == c(20, 5)), "Read chunks returns the right dimension object")
  expect_true(all(ir1$factors$Species == levels(iris$Species)), "Factor levels check")
  expect_true(identical(ir1$readTable(), iris[1:100,]), info = "Check that correct data is read back")
})

test_that("Check readback of h5 file", {
  testH5 <- "iris.h5"
  ir1 <- openH5DF(testH5)
  expect_true(class(ir1) == "h5DF", info = "Check that the class is h5DF")
  expect_true(ir1$nrows == 100, "Check that the correct number of rows were written")
  expect_true(ir1$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(ir1$colClasses == sapply(iris, class)), info = "Check correct column classes written")
  expect_true(ir1$nfactors == 1, "Check the number of factors written")
  expect_true(all(dim(ir1$readChunk("ch2")) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(all(ir1$factors$Species == levels(iris$Species)), "Factor levels check")
  expect_true(identical(ir1$readTable(), iris[1:100,]), info = "Check that correct data is read back")
})

test_that("Check that data is correctly appended to h5 file", {
  testH5 <- "iris.h5"
  ir1 <- openH5DF(testH5)
  ir1$append(iris[101:150, ])
  ir2 <- ir1$memorize()
  expect_true(class(ir1) == "h5DF", info = "Check that class of created object is h5DF")
  expect_true(class(ir2) == "h5MEMDF", info = "Check that class of memorized object is h5MEMDF")
  expect_true(ir1$nrows == 150, "Check that the number of rows have been updated")
  expect_true(identical(ir1$readTable(), iris), info = "Check that correct data is read back")
  ir3 <- do.call(rbind, lapply(1:length(ir2$ptrs), ir2$readChunk))
  expect_true(identical(ir3, iris), "Check that data was correctly memorized")
  unlink(testH5) # file cleanup
})


####$$$$ activeH5-master\inst\tests/test-h5MAT.r
# Tests for h5MAT objects

context("h5MAT Tests")

test_that("Check creating file and meta data of h5MAT object", {
  testH5 <- "mat.h5"
  set.seed(0)
  mat <- matrix(runif(100*5), nc = 5)
  mt1 <- newH5MAT(mat, testH5, 10)
  expect_true(class(mt1) == "h5MAT", info = "Check that the class is h5MAT")
  expect_true(file.exists(testH5), info = "Test that H5 file was created")
  expect_true(mt1$nrows == 100, "Check that the correct number of rows were written")
  expect_true(mt1$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(dim(mt1$readChunk("ch2")) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(all(dim(mt1$readChunks(c("ch2", "ch3"))) == c(20, 5)), "Read chunks returns the right dimension object")
  expect_true(identical(mt1$readTable(), mat), info = "Check that correct data is read back")
})

test_that("Check readback of h5 file", {
  testH5 <- "mat.h5"
  mt1 <- openH5MAT(testH5)
  set.seed(0)
  mat <- matrix(runif(100*5), nc = 5)
  expect_true(class(mt1) == "h5MAT", info = "Check that the class is h5MAT")
  expect_true(mt1$nrows == 100, "Check that the correct number of rows were written")
  expect_true(mt1$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(dim(mt1$readChunk("ch2")) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(identical(mt1$readTable(), mat), info = "Check that correct data is read back")
})

test_that("Check that data is correctly appended to h5 file", {
  testH5 <- "mat.h5"
  mt1 <- openH5MAT(testH5)
  set.seed(0)
  mat1 <- matrix(runif(100*5), nc = 5)
  set.seed(1)
  mat2 <- matrix(runif(50*5), nc = 5)
  mat <- rbind(mat1, mat2)
  mt1$append(mat2)
  mt2 <- mt1$memorize()
  expect_true(class(mt1) == "h5MAT", info = "Check that class of created object is h5MAT")
  expect_true(class(mt2) == "h5MEMMAT", info = "Check that class of memorized object is h5MEMMAT")
  expect_true(mt1$nrows == 150, "Check that the number of rows have been updated")
  expect_true(identical(mt1$readTable(), mat), info = "Check that correct data is read back")
  expect_true(identical(mt1$readTable(), mat), "Check that data was correctly memorized")
  unlink(testH5) # file cleanup
})

####$$$$ activeH5-master\inst\tests/test-h5MEMDF.r
# Tests for h5MEMDF objects

context("h5MEMDF Tests")

test_that("Check h5MEMDF object is correctly created", {
  ir1 <- newH5MEMDF(iris[1:100,], 10)
  expect_true(class(ir1) == "h5MEMDF", info = "Check that the class is h5MEMDF")
  expect_true(ir1$nrows == 100, "Check that the correct number of rows were written")
  expect_true(ir1$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(ir1$colClasses == sapply(iris, class)), info = "Check correct column classes written")
  expect_true(ir1$nfactors == 1, "Check the number of factors written")
  expect_true(all(dim(ir1$readChunk(2)) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(all(ir1$factors$Species == levels(iris$Species)), "Factor levels check")
  ir1$append(iris[101:150, ])
  expect_true(ir1$nrows == 150, "Check that the number of rows have been updated")
  testH5 <- "iris.h5"
  ir2 <- ir1$createH5DF(testH5)
  expect_true(class(ir2) == "h5DF", info = "Class check of written h5DF object")
  expect_true(file.exists(testH5), info = "Test that H5 file was created")
  expect_true(ir2$nrows == 150, "Check that the correct number of rows were written")
  expect_true(ir2$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(ir2$colClasses == sapply(iris, class)), info = "Check correct column classes written")
  expect_true(ir2$nfactors == 1, "Check the number of factors written")
  expect_true(all(dim(ir2$readChunk("ch2")) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(all(dim(ir2$readChunks(c("ch2", "ch3"))) == c(20, 5)), "Read chunks returns the right dimension object")
  expect_true(all(ir2$factors$Species == levels(iris$Species)), "Factor levels check")
  expect_true(identical(ir2$readTable(), iris), info = "Check that correct data is read back")
  unlink(testH5) # cleanup
})
####$$$$ activeH5-master\inst\tests/test-h5MEMMAT.r
# Tests for h5MEMMAT objects

context("h5MEMMAT Tests")

test_that("Check h5MEMMAT object is correctly created", {
  mat <- matrix(runif(150*5), nc = 5)
  mt1 <- newH5MEMMAT(mat[1:100,], 10)
  expect_true(class(mt1) == "h5MEMMAT", info = "Check that the class is h5MEMMAT")
  expect_true(mt1$nrows == 100, "Check that the correct number of rows were written")
  expect_true(mt1$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(dim(mt1$readChunk(2)) == c(10, 5)), "readChunk returns the right dimension object")
  expect_true(all(dim(mt1$readChunks(2:3)) == c(20, 5)), "readChunks returns the right dimension object")
  expect_true(all(dim(mt1$readTable()) == c(100, 5)), "readTable returns the right dimension object")
  mt1$append(mat[101:150, ])
  expect_true(mt1$nrows == 150, "Check that the number of rows have been updated")
  testH5 <- "mat.h5"
  mt2 <- mt1$createH5MAT(testH5)
  expect_true(class(mt2) == "h5MAT", info = "Class check of written h5MAT object")
  expect_true(file.exists(testH5), info = "Test that H5 file was created")
  expect_true(mt2$nrows == 150, "Check that the correct number of rows were written")
  expect_true(mt2$ncols == 5, info = "Check the correct number of cols were written")
  expect_true(all(dim(mt2$readChunk("ch2")) == c(10, 5)), "Read chunk returns the right dimension object")
  expect_true(all(dim(mt2$readChunks(c("ch2", "ch3"))) == c(20, 5)), "Read chunks returns the right dimension object")
  expect_true(identical(mt2$readTable(), mat), info = "Check that correct data is read back")
  unlink(testH5) # cleanup
})
####$$$$ activeH5-master\man/activeH5.Rd
\docType{package}
\name{activeH5}
\alias{activeH5}
\alias{activeH5-package}
\title{activeH5 is a tool for big data objects in R on disk and in memory created by Active Analytics Ltd.}
\description{
  activeH5 provides a set of tools to allow large data
  frames and matrices to be written to file and to memory
  and are stored in chunks. On file the data is stored in
  H5 format and in memory pointers are used to access
  chunks of data. The data objects are written as reference
  classes and are h5DF, h5MAT, h5MEMDF, and h5MEMMAT.
}
\details{
  The h5DF object is used to store very large data frames
  on disk. The data itself is stores as purely numerical
  data. Character columns are converted to factors and
  factors to numeric data, then each chunk is stores as a
  matrix. This means that the I/O speed is fast. Meta data
  associated with factors are stored in the file and the
  h5DF object and are recombined with the daat as it is
  read back into R.

  The h5MAT object is used to store very large matrices on
  disk in chunks. The data is assumed to be numeric data so
  I/O speed is fast even faster than h5DF.

  The h5MEMDF object is used to store very large data
  frames in memory as chunks with pointers to each chunk.
  Data can only be stored where there is sufficient memory
  to accomodate the object(s). Storing data like this makes
  it easier move, manipulate and work with very large
  datasets without the constant replication that occurs
  when using them in normal R functions. Since the data is
  stored in memory access time is faster than when the data
  is stored on disk.

  The h5MEMMAT object is used to store very large matrices
  in memory as chunks. Again there are pointers to each
  chunk of data and there has to be sufficient memory to
  accomodate the object(s). Storing data like this makes it
  easier move, manipulate and work with very large datasets
  without the constant replication that occurs when using
  them in normal R functions. Since the data is stored in
  memory access time is faster than when stored on disk.

  The HDF5 files generated by h5DF, h5MAT are not designed
  to be used with other software that use HDF5 objects. Any
  data that is created using the activeH5 module may not
  read back as expected with other HDF5 APIs.
}

####$$$$ activeH5-master\man/createFactor.Rd
\name{createFactor}
\alias{createFactor}
\title{Function to create a factor}
\usage{
  createFactor(x, levels)
}
\arguments{
  \item{x}{a numeric vector that denotes the indexes of the
  factor}

  \item{levels}{character vector for the unique levels of
  the factor}
}
\value{
  a factor
}
\description{
  Function creates a factor when supplied with a numeric
  vector and character vector for levels
}
\examples{
createFactor(sample(1:3, 10, TRUE), LETTERS[1:3])
}

####$$$$ activeH5-master\man/h5ChunkList.Rd
\name{h5ChunkList}
\alias{h5ChunkList}
\title{Function returns a data frame chunk as a list object to R where the final cbind will take place}
\usage{
  h5ChunkList(chunkName, filePath)
}
\arguments{
  \item{chunkName}{the name of the chunk to be read}

  \item{filePath}{the path to the h5 file}
}
\value{
  List representing chunk data frame
}
\description{
  Function returns a data frame chunk as a list object to R
  where the final cbind will take place
}

####$$$$ activeH5-master\man/h5ChunkSel.Rd
\name{h5ChunkSel}
\alias{h5ChunkSel}
\title{Function returns a column subset of data frame chunk as a list}
\usage{
  h5ChunkSel(chunkName, selCols, filePath)
}
\arguments{
  \item{chunkName}{the name of the chunk to be read}

  \item{selCols}{the columns that will be selected}

  \item{filePath}{the path to the h5 file}
}
\value{
  List representing chunk data frame
}
\description{
  Function returns a column subset of data frame chunk as a
  list
}

####$$$$ activeH5-master\man/h5CloseFile.Rd
\name{h5CloseFile}
\alias{h5CloseFile}
\title{Function to close the h5 file}
\usage{
  h5CloseFile(filePath)
}
\arguments{
  \item{filePath}{character path to the file which will be
  flushed}
}
\value{
  int 0
}
\description{
  Closes the h5 file
}

####$$$$ activeH5-master\man/h5CreateFile.Rd
\name{h5CreateFile}
\alias{h5CreateFile}
\title{Function to create file a h5 file}
\usage{
  h5CreateFile(filePath, overwrite)
}
\arguments{
  \item{filePath}{a character denoting the path to the
  location where the h5 file will be written}

  \item{overwrite}{integer 1 for overwrite and 0 for not
  overwrite. Will fail if overwrite is 0}
}
\value{
  int 0
}
\description{
  Function to create a h5 file. It is intended for internal
  use only
}

####$$$$ activeH5-master\man/h5CreateMetaData.Rd
\name{h5CreateMetaData}
\alias{h5CreateMetaData}
\title{Function creates the groups for the meta data to be written to the h5 file}
\usage{
  h5CreateMetaData(filePath)
}
\arguments{
  \item{filePath}{character path to the location where the
  h5 file will be written}
}
\value{
  int 0
}
\description{
  Function to create the groups in the h5 file before it is
  populated. This function is intended for internal use
  only
}

####$$$$ activeH5-master\man/h5DF.Rd
\name{h5DF}
\alias{h5DF}
\title{Specification of h5DF reference class}
\usage{
  h5DF(...)
}
\description{
  The h5DF object is an interface to a special type of HDF5
  file that holds the data for large data frames in chunks.
  Data frames are converted to numeric matrices, characters
  are converted to factors and factors to numeric data. It
  is designed to allow fast access to chunks of data from
  the HDF5 file.
}
\section{Methods in the h5DF object}{
  \itemize{ \item h5DF$new() creates a new h5DF object.
  Users should use the functions ?newH5DF() and
  ?openH5DF().  \item h5DF$createH5DF(DF, filePath,
  chunkSize, ...) populates a h5DF object with data from a
  data frame or csv file containing a data frame DF. It
  writes the meta data to the h5DF object and the dataset
  to a h5 file. Users should use the functions ?newH5DF()
  and ?openH5DF(). \itemize{ \item DF a data frame or path
  to a csv file containing a data frame \item filePath path
  to a file where the h5 object will be written \item
  chunkSize the number of rows that will be written per
  chunk \item ... arguments that will be passed to the
  read.csv() function } \item h5DF$append(DF, ...) appends
  a data frame to the current h5 file and updates the meta
  data in the file and on the object \itemize{ \item DF a
  data frame or path to a csv file containing a data frame
  \item h5DF$readChunk(chunkName) reads chunkName from the
  h5DF object returning a data frame chunk.  \item
  chunkName character name of the chunk to be returned }
  \item h5DF$readChunks(chunks) reads the chunkNames from
  the h5DF object returning a data frame containing all the
  chunks that have been read. \itemize{ \item chunks
  character vector name of the chunks to be binded together
  and returned as a data frame } \item h5DF$readTable()
  reads the whole table back into R. This is a convenience
  function and the user must know whether their system has
  sufficient memory to accomodate the data frame. \item
  h5DF$memorize() this function converts the h5DF object to
  a h5MEMDF object. It reads each chunk to memory and
  supplies pointers in R to access each chunk. Very useful
  when you have lots of memory in your system and need an
  efficient way to access chunks of data. }
}

\section{Fields in the h5DF object}{
  These are the fields in the h5DF object, they are not to
  be directly modified by the user but can be accessed by
  h5DF$fieldName.

  \itemize{ \item nChunks: The number of chunks in the h5DF
  object \item chunkNames: The names of the chunks in the
  h5DF object \item colNames: The column names in the
  submitted data frame \item colClasses: The classes of the
  submitted data frame \item nrows: The number of rows in
  the data frame \item ncols: The number of columns in the
  data frame \item filePath: A character denoting the path
  to the h5 file \item nfactors: The number of factor
  columns in the h5DF object \item factors: A list
  containing the factor levels for each factor in the data
  frame \item chunkSize: The number of rows each chunk will
  contain \item MAT: For internal use when manipulating the
  data frame \item oldNChunks: For internal use. }
}

####$$$$ activeH5-master\man/h5DummyRead.Rd
\name{h5DummyRead}
\alias{h5DummyRead}
\title{Function for dummy read}
\usage{
  h5DummyRead(chunkName, filePath)
}
\arguments{
  \item{chunkName}{the name of the chunk to be read back}

  \item{filePath}{the path to the h5 file}
}
\value{
  int 0
}
\description{
  Function for dummy read
}

####$$$$ activeH5-master\man/h5FlushFile.Rd
\name{h5FlushFile}
\alias{h5FlushFile}
\title{Function to finalize h5 file contents allowing them to be read by another user}
\usage{
  h5FlushFile(filePath)
}
\arguments{
  \item{filePath}{character path to the file which will be
  flushed}
}
\value{
  int 0
}
\description{
  The same as the h5CloseFile() function
}

####$$$$ activeH5-master\man/h5MAT.Rd
\name{h5MAT}
\alias{h5MAT}
\title{Specification of the h5MAT reference class}
\usage{
  h5MAT(...)
}
\description{
  The h5MAT object is an interface to a special type of
  HDF5 file that holds data for large matrices in chunks.
  It is designed to allow fast access to chunks of data
  from the HDF5 file.
}
\section{Methods in the h5MAT object}{
  \itemize{ \item h5MAT$new() creates a new h5MAT object,
  users should use ?newH5MAT() or ?openH5MAT(). \item
  h5MAT$createH5MAT(MAT, filePath, chunkSize, ...)
  populates a h5MAT object with data from MAT. Users should
  use ?newH5MAT() or ?openH5MAT(). \itemize{ \item MAT a
  matrix or a path to a csv file containing a matrix to be
  converted to a h5MAT object \item filePath a character
  denoting a path to a location where the h5MAT object wll
  be written \item chunkSize number of rows denoting the
  size of each matrix chunk \item ... parameters to be
  passed to the read.csv() function } \item
  h5MAT$append(MAT, ...) appends matrix MAT to the current
  h5MAT object \itemize{ \item MAT a matrix or a path to a
  csv file containing a matrix to be converted to a h5MAT
  object \item ... parameters to be passed to the
  read.csv() function } \item h5MAT$readChunk(chunkName)
  reads the chunk denotes by chunkName into R as a matrix
  \itemize{ \item chunkName a character denoting the name
  of the chunk to be returned as a matrix } \item
  h5MAT$readChunks(chunks) read the chunks denotes by
  chunks into R as a matrix \itemize{ \item chunks a
  character vector denoting the chunks to be read into R as
  a single matrix } \item h5MAT$readTable() reads the whole
  matrix in the h5MAT into R as a matrix \item
  h5DF$memorize() this function converts the h5MAT object
  to a h5MEMMAT object. It reads each chunk to memory and
  supplies pointers in R to access each chunk. Very useful
  when you have lots of memory in your system and need an
  efficient way to access chunks of data. }
}

\section{Fields in the h5MAT object}{
  These are the fields in the h5MAT object, they are not to
  be directly modified by the user but can be accessed by
  h5MAT$fieldName.

  \itemize{ \item nChunks: The number of chunks in the
  h5MAT object \item chunkNames: The names of the chunks in
  the h5MAT object \item nrows: The number of rows in the
  data frame \item ncols: The number of columns in the data
  frame \item filePath: A character denoting the path to
  the h5 file \item chunkSize: The number of rows each
  chunk will contain \item MAT: For internal use when
  manipulating the data frame \item oldNChunks: For
  internal use. }
}

####$$$$ activeH5-master\man/h5MEMDF.Rd
\name{h5MEMDF}
\alias{h5MEMDF}
\title{Specification of the h5MEMDF reference class}
\usage{
  h5MEMDF(...)
}
\description{
  The h5MEMDF class allows the user to create a h5DF object
  in memory rather than on file. The data frame chunks are
  stored in memory and these are accessed by pointers in
  the h5MEMDF object.
}
\section{Methods in the h5MEMDF object}{
  \itemize{ \item h5MEMDF$new() creates a new h5MEMDF
  object. Users should use the functions ?newH5MEMDF().
  \item h5MEMDF$createH5DF(df, chunkSize, ...) populates a
  h5MEMDF object with data from a data frame or csv file
  containing a data frame df. It writes the meta data to
  the h5MEMDF object and the dataset to a h5 file. Users
  should use the functions ?newH5MEMDF(). \itemize{ \item
  df a data frame or path to a csv file containing a data
  frame \item chunkSize the number of rows that will be
  written per chunk \item ... arguments that will be passed
  to the read.csv() function } \item h5MEMDF$append(df,
  ...) appends a data frame to the current h5 file and
  updates the meta data in the file and on the object
  \itemize{ \item df a data frame or path to a csv file
  containing a data frame \item ... arguments that will be
  passed to the read.csv() function } \item
  h5MEMDF$readChunk(chunkNum) reads chunkNum from the
  h5MEMDF object returning a data frame chunk. \itemize{
  \item chunkNum numeric number of the chunk to be returned
  } \item h5MEMDF$createH5DF(filePath) creates a h5DF
  object from the h5MEMDF object writing the data to file
  provided by filePath. \itemize{ \item filePath character
  denoting location for where the h5 file should be
  written. } }
}

\section{Fields in the h5MEMDF object}{
  These are the fields in the h5MEMDF object, they are not
  to be directly modified by the user but can be accessed
  by h5MEMDF$fieldName.

  \itemize{ \item nChunks: The number of chunks in the
  h5MEMDF object \item ptrs: A list of pointers to each of
  the chunks in the data frame \item colNames: The column
  names in the submitted data frame \item colClasses: The
  classes of the submitted data frame \item nrows: The
  number of rows in the data frame \item ncols: The number
  of columns in the data frame \item nfactors: The number
  of factor columns in the h5MEMDF object \item factors: A
  list containing the factor levels for each factor in the
  data frame \item chunkSize: The number of rows each chunk
  will contain \item DF: For internal use when manipulating
  the data frame \item oldNChunks: For internal use. }
}

####$$$$ activeH5-master\man/h5MEMMAT.Rd
\name{h5MEMMAT}
\alias{h5MEMMAT}
\title{Specification of the h5MEMMAT reference class}
\usage{
  h5MEMMAT(...)
}
\description{
  The h5MEMMAT class allows the user to create a h5MAT
  object in memory rather than on file. The matrix chunks
  are stored in memory and these are accessed by pointers
  in the h5MEMMAT object.
}
\section{Methods in the h5MEMMAT object}{
  \itemize{ \item h5MEMMAT$new() creates a new h5MEMMAT
  object, users should use ?newH5MAT() or ?openH5MAT().
  \item h5MEMMAT$createH5MAT(MAT, filePath, chunkSize, ...)
  populates a h5MEMMAT object with data from MAT. Users
  should use ?newH5MAT() or ?openH5MAT(). \itemize{ \item
  MAT a matrix or a path to a csv file containing a matrix
  to be converted to a h5MEMMAT object \item filePath a
  character denoting a path to a location where the
  h5MEMMAT object wll be written \item chunkSize number of
  rows denoting the size of each matrix chunk \item ...
  parameters to be passed to the read.csv() function }
  \item h5MEMMAT$append(MAT, ...) appends matrix MAT to the
  current h5MEMMAT object \itemize{ \item MAT a matrix or a
  path to a csv file containing a matrix to be converted to
  a h5MEMMAT object \item ... parameters to be passed to
  the read.csv() function } \item
  h5MEMMAT$readChunk(chunkName) reads the chunk denotes by
  chunkName into R as a matrix \itemize{ \item chunkName a
  character denoting the name of the chunk to be returned
  as a matrix } \item h5MEMMAT$readChunks(chunks) read the
  chunks denotes by chunks into R as a matrix \itemize{
  \item chunks a character vector denoting the chunks to be
  read into R as a single matrix } \item
  h5MEMMAT$readTable() reads the whole matrix in the
  h5MEMMAT into R as a matrix \item
  h5MEMMAT$createH5MAT(filePath) this function converts the
  h5MEMMAT object to a h5MAT object. It writes the data in
  the h5MEMMAT object to filePath and returns a h5MAT
  object. }
}

\section{Fields in the h5MEMMAT object}{
  These are the fields in the h5MEMMAT object, they are not
  to be directly modified by the user but can be accessed
  by h5MEMMAT$fieldName.

  \itemize{ \item nChunks: The number of chunks in the
  h5MEMMAT object \item ptrs: A list of pointers to each of
  the chunks in the matrix \item nrows: The number of rows
  in the data frame \item ncols: The number of columns in
  the data frame \item chunkSize: The number of rows each
  chunk will contain \item MAT: For internal use when
  manipulating the data frame \item oldNChunks: For
  internal use. }
}

####$$$$ activeH5-master\man/h5ModelFrame.Rd
\name{h5ModelFrame}
\alias{h5ModelFrame}
\title{Fast model frame for activeReg}
\usage{
  h5ModelFrame(chunkName, selCols_, filePath)
}
\arguments{
  \item{chunkName}{character name of the chunk to be read}

  \item{selCols}{character vector of columns to select}

  \item{filePath}{character path to file where chunk is to
  be read from}
}
\value{
  list representing a data frame with no NA values.
}
\description{
  Function returns a scaled down model frame essentially
  returning list with no NA values. Each item in the list
  represents a column in the data frame.
}

####$$$$ activeH5-master\man/h5ReadCharVector.Rd
\name{h5ReadCharVector}
\alias{h5ReadCharVector}
\title{Function to read a character vector from meta data}
\usage{
  h5ReadCharVector(charName, filePath)
}
\arguments{
  \item{charName}{character the name of the meta data item
  to be read back from file}

  \item{filePath}{character for the path to the file where
  the item will be read}
}
\value{
  character containing the character vector that has been
  read from meta data
}
\description{
  Function to read a character vector from meta data
}

####$$$$ activeH5-master\man/h5ReadDoubleMat.Rd
\name{h5ReadDoubleMat}
\alias{h5ReadDoubleMat}
\title{Function to read a matrix chunk from a h5 file}
\usage{
  h5ReadDoubleMat(chunkName, filePath)
}
\arguments{
  \item{chunkName}{the name of the chunk to be read back}

  \item{filePath}{the path to the h5 file}
}
\value{
  matrix chunk defined by chunkName
}
\description{
  Function to read a matrix chunk from a h5 file
}

####$$$$ activeH5-master\man/h5ReadDoubleMat2.Rd
\name{h5ReadDoubleMat2}
\alias{h5ReadDoubleMat2}
\title{Legacy function to return a data frame chunk as a list}
\usage{
  h5ReadDoubleMat2(chunkName, filePath)
}
\arguments{
  \item{chunkName}{the name of the chunk to be read}

  \item{filePath}{the path to the h5 file}
}
\value{
  List of the data frame chunk
}
\description{
  Experimental function not intended for use at all
}

####$$$$ activeH5-master\man/h5ReadDoubleMat3.Rd
\name{h5ReadDoubleMat3}
\alias{h5ReadDoubleMat3}
\title{Legacy function to return a data frame chunk as a list}
\usage{
  h5ReadDoubleMat3(chunkName, filePath)
}
\arguments{
  \item{chunkName}{the name of the chunk to be read}

  \item{filePath}{the path to the h5 file}
}
\value{
  List of the data frame chunk
}
\description{
  Experimental function not intended for use at all
}

####$$$$ activeH5-master\man/h5ReadFactor.Rd
\name{h5ReadFactor}
\alias{h5ReadFactor}
\title{Function to read factor levels from meta data for a pgiven factor}
\usage{
  h5ReadFactor(charName, filePath)
}
\arguments{
  \item{charName}{character denoting the factor from the
  meta data factor}

  \item{filePath}{character denoting the path to the h5
  file}
}
\value{
  character of factor levels
}
\description{
  Function to read factor levels from meta data for a
  pgiven factor
}

####$$$$ activeH5-master\man/h5ReadInt.Rd
\name{h5ReadInt}
\alias{h5ReadInt}
\title{Function to read an integer item from meta data}
\usage{
  h5ReadInt(intName, filePath)
}
\arguments{
  \item{intName}{character for the name of the item to be
  read back}

  \item{filePath}{character for the path to the h5 file}
}
\value{
  int iteger item defined by intName in the meta data
}
\description{
  Function to read an integer item from meta data
}

####$$$$ activeH5-master\man/h5ReadMemDF.Rd
\name{h5ReadMemDF}
\alias{h5ReadMemDF}
\title{Function to read a data frame that has been stored in memory when given the external pointer}
\usage{
  h5ReadMemDF(ptr)
}
\arguments{
  \item{ptr}{externalptr to data frame stored in memory}
}
\value{
  the data frame that is helpd at the externalptr
}
\description{
  Function to read a data frame that has been stored in
  memory when given the external pointer
}

####$$$$ activeH5-master\man/h5ReadMemMAT.Rd
\name{h5ReadMemMAT}
\alias{h5ReadMemMAT}
\title{Function to read a matrix from memory when given the external pointer}
\usage{
  h5ReadMemMAT(ptr)
}
\arguments{
  \item{ptr}{an externalptr to the matrix object to be
  retrieved}
}
\value{
  matrix that is held at the externalptr
}
\description{
  Intended for internal use only
}

####$$$$ activeH5-master\man/h5WriteCharVector.Rd
\name{h5WriteCharVector}
\alias{h5WriteCharVector}
\title{This function writes a character vector to the meta data}
\usage{
  h5WriteCharVector(charName, charVec, filePath, update)
}
\arguments{
  \item{charName}{the name that will be given to the meta
  data character vector}

  \item{charVec}{the character vector to be written as meta
  data}

  \item{filePath}{the path to the h5 file where the data
  will be written}

  \item{update}{integer denoting whether the data item is
  new or whether it is an update (which will overwrite any
  previous item)}
}
\value{
  int 0
}
\description{
  This function writes a character vector to the meta data
  and is intended for internal use.
}

####$$$$ activeH5-master\man/h5WriteDoubleMat.Rd
\name{h5WriteDoubleMat}
\alias{h5WriteDoubleMat}
\title{Function to write a matrix chunk to file}
\usage{
  h5WriteDoubleMat(dset, chunk, dim, filePath)
}
\arguments{
  \item{dset}{character denoting the meta data name of the
  data set}

  \item{chunk}{matrix that will be written to h5file}

  \item{dim}{numeric containing the dimension of the matrix
  that will be written to file}

  \item{filePath}{character denoting the location of the h5
  file}
}
\value{
  int 0
}
\description{
  Function is intended for internal use
}

####$$$$ activeH5-master\man/h5WriteFactor.Rd
\name{h5WriteFactor}
\alias{h5WriteFactor}
\title{Function to write the levels of a factor variable to meta data}
\usage{
  h5WriteFactor(charName, charVec, filePath, update)
}
\arguments{
  \item{charName}{character denoting the meta data name of
  the factor to be written}

  \item{charVec}{characer denoting the factor levels to be
  written}

  \item{filePath}{character denoting the location of the h5
  file}

  \item{update}{int flag for whether item is new (0) or
  whether it will overwrite a previous item (1)}
}
\value{
  int 0
}
\description{
  Function is intended for internal use
}

####$$$$ activeH5-master\man/h5WriteInt.Rd
\name{h5WriteInt}
\alias{h5WriteInt}
\title{This function writes an iteger meta data to file}
\usage{
  h5WriteInt(intName, integer, filePath, update)
}
\arguments{
  \item{intName}{the name of the meta data item to be
  written}

  \item{integer}{int that will be written to the meta data
  described by intName}

  \item{filePath}{character path to the h5 file where data
  will be written}

  \item{update}{int flag for whether item is new (0) or
  whether it will overwrite a previous item (1)}
}
\value{
  int 0
}
\description{
  This function is inteded for internal use
}

####$$$$ activeH5-master\man/h5WriteMemDF.Rd
\name{h5WriteMemDF}
\alias{h5WriteMemDF}
\title{Function to write a data frame object to memory and return a pointer}
\usage{
  h5WriteMemDF(obj)
}
\arguments{
  \item{obj}{data frame to be written to memory}
}
\value{
  externalptr
}
\description{
  Intended for internal use only
}

####$$$$ activeH5-master\man/h5WriteMemMAT.Rd
\name{h5WriteMemMAT}
\alias{h5WriteMemMAT}
\title{Function to write a matrix to memory and return a pointer}
\usage{
  h5WriteMemMAT(obj)
}
\arguments{
  \item{obj}{matrix to be written to memory}
}
\value{
  externalptr
}
\description{
  Intended for internal use only
}

####$$$$ activeH5-master\man/newH5DF.Rd
\name{newH5DF}
\alias{newH5DF}
\title{Function to create a new h5DF object}
\usage{
  newH5DF(DF, filePath, chunkSize = 50000, ...)
}
\arguments{
  \item{DF}{data frame or file path to csv file containing
  data frame to be written to h5DF object}

  \item{filePath}{path to file that will contain the h5DF
  data object}

  \item{chunkSize}{the number of rows that each chunk will
  take}

  \item{...}{parameters passed to read.csv() function}
}
\value{
  a h5DF object
}
\description{
  Function to create a new h5DF object
}
\examples{
# Create a new h5DF object from the iris dataset
ir1 <- newH5DF(iris, "iris.h5", 10)
ir1 # The details of the object
chNames <- ir1$chunkNames # The names of the chunks
ir1$readChunk(chNames[3]) # read chunk number 3
ir1$readChunks(chNames[1:5]) # read the first 5 chunks
ir1$readTable() # reads back the whole table
ir2 <- openH5DF("iris.h5") # create H5 df from file
# Create a h5MEMDF object from a h5DF object by memorize (i.e. brings the h5DF object into memory)
irMDF <- ir2$memorize()
irMDF # this is a h5MEMDF object, chunked DF object in memory with pointers
irMDF$ptrs
}

####$$$$ activeH5-master\man/newH5MAT.Rd
\name{newH5MAT}
\alias{newH5MAT}
\title{Function to create a new h5MAT object}
\usage{
  newH5MAT(MAT, filePath, chunkSize, ...)
}
\arguments{
  \item{MAT}{matrix or csv file containing a matrix to be
  converted into a h5MAT object}

  \item{filePath}{character path to the file to be written}

  \item{chunkSize}{the number of rows for each chunk}

  \item{...}{arguments sent to \code{read.csv()} function}
}
\value{
  returns a h5MAT object
}
\description{
  Function to create a new h5MAT object
}
\examples{
n <- 1e3
mat <- matrix(runif(n^2), nc = n)
hmat <- newH5MAT(mat, "mat.h5", 1E2) # a h5MAT object
hmat$append(mat, "mat.h5", 1E2) # append the matrix
ch <- hmat$readChunk("ch2") # reading a chunk into the matrix
ch[1:10, 1:10]
# Reading several chunks
hmat$readChunks(paste("ch", 1:5, sep = ""))
# Reading the table
tab <- hmat$readTable()
# Create a h5MEMMAT object
memtab <- hmat$memorize()
}

####$$$$ activeH5-master\man/newH5MEMDF.Rd
\name{newH5MEMDF}
\alias{newH5MEMDF}
\title{Function to create a new h5MEMDF object}
\usage{
  newH5MEMDF(df, chunkSize, ...)
}
\arguments{
  \item{df}{data frame or file path to csv file containing
  data frame to be written to h5DF object}

  \item{chunkSize}{the number of rows that each chunk will
  take.}

  \item{...}{parameters passed to read.csv() function}
}
\value{
  a h5MEMDF object
}
\description{
  Function to create a new h5MEMDF object
}
\examples{
# Create a new h5MEMDF object from the iris dataset
ir1 <- newH5MEMDF(iris[1:100,], 10)
ir1 # The details of the object
ir1$readChunk(1) # read chunk number 3
ir1$append(iris[101:150,]) # appending data
}

####$$$$ activeH5-master\man/newH5MEMMAT.Rd
\name{newH5MEMMAT}
\alias{newH5MEMMAT}
\title{Function for instantiating a h5MEMMAT object}
\usage{
  newH5MEMMAT(MAT, chunkSize, ...)
}
\arguments{
  \item{MAT}{the matrix or path to a csv file containing a
  matrix to be written to a h5MEMMAT object}

  \item{chunkSize}{the number of rows in each chunk}

  \item{...}{arguments passed to read.csv() file}
}
\value{
  a h5MEMMAT object
}
\description{
  Function for instantiating a h5MEMMAT object
}
\examples{
cat(getwd(), "\\n")
n <- 1e3
mat <- matrix(runif(n^2), nc = n)
hmat <- newH5MEMMAT(mat, 10) # creating the h5MEMMAT object
hmat$append(mat, 10) # appending to the h5MEMMAT object
hmat$readChunk(2)[,1:6] # reading the second chunk
# Writing a h5MAT object to file
hmat2 <- newH5MAT(mat, "mat.h5", 10)
hmat2 # this is a h5MAT object
# Reading the matrix to memory
hmat3 <- hmat2$memorize()
}

####$$$$ activeH5-master\man/openH5DF.Rd
\name{openH5DF}
\alias{openH5DF}
\title{Function to create a new h5DF object from h5 file}
\usage{
  openH5DF(filePath)
}
\arguments{
  \item{filePath}{path to file that contain the h5DF data
  object}
}
\value{
  a h5DF object
}
\description{
  Function to create a new h5DF object from h5 file
}
\examples{
# Create a new h5DF object from the iris dataset
ir1 <- newH5DF(iris, "iris.h5", 10)
ir1 # The details of the object
chNames <- ir1$chunkNames # The names of the chunks
ir1$readChunk(chNames[3]) # read chunk number 3
ir1$readChunks(chNames[1:5]) # read the first 5 chunks
ir1$readTable() # reads back the whole table
ir2 <- openH5DF("iris.h5") # create H5 df from file
# Create a h5MEMDF object from a h5DF object by memorize (i.e. brings the h5DF object into memory)
irMDF <- ir2$memorize()
irMDF # this is a h5MEMDF object, chunked DF object in memory with pointers
irMDF$ptrs
}

####$$$$ activeH5-master\man/openH5MAT.Rd
\name{openH5MAT}
\alias{openH5MAT}
\title{Function to create a h5MAT object from a saved h5 file}
\usage{
  openH5MAT(filePath)
}
\arguments{
  \item{filePath}{path to file containing h5MAT object}
}
\value{
  returns a h5MAT object
}
\description{
  Function to create a h5MAT object from a saved h5 file
}
\examples{
n <- 1e3
mat <- matrix(runif(n^2), nc = n)
hmat <- newH5MAT(mat, "mat.h5", 1E2) # a h5MAT object
hmat2 <- openH5MAT("mat.h5")
}

####$$$$ activeH5-master\R/activeH5.r
#' activeH5 is a tool for big data objects in R on disk and in memory created by Active Analytics Ltd.
#' 
#' activeH5 provides a set of tools to allow large data frames and matrices to be written
#' to file and to memory and are stored in chunks. On file the data is stored in H5 format
#' and in memory pointers are used to access chunks of data. The data objects are written
#' as reference classes and are h5DF, h5MAT, h5MEMDF, and h5MEMMAT.
#' 
#' The h5DF object is used to store very large data frames on disk. The data itself is 
#' stores as purely numerical data. Character columns are converted to factors and 
#' factors to numeric data, then each chunk is stores as a matrix. This means that the
#' I/O speed is fast. Meta data associated with factors are stored in the file and the h5DF
#' object and are recombined with the daat as it is read back into R.
#' 
#' The h5MAT object is used to store very large matrices on disk in chunks. The data is assumed to
#' be numeric data so I/O speed is fast even faster than h5DF.
#' 
#' The h5MEMDF object is used to store very large data frames in memory as chunks with pointers to 
#' each chunk. Data can only be stored where there is sufficient memory to accomodate the object(s). 
#' Storing data like this makes it easier move, manipulate and work with very large datasets without 
#' the constant replication that occurs when using them in normal R functions. Since the data is stored
#' in memory access time is faster than when the data is stored on disk.
#' 
#' The h5MEMMAT object is used to store very large matrices in memory as chunks. Again there are 
#' pointers to each chunk of data and there has to be sufficient memory to accomodate the object(s).
#' Storing data like this makes it easier move, manipulate and work with very large datasets without 
#' the constant replication that occurs when using them in normal R functions. Since the data is stored
#' in memory access time is faster than when stored on disk.
#' 
#' The HDF5 files generated by h5DF, h5MAT are not designed to be used with other software that use HDF5
#' objects. Any data that is created using the activeH5 module may not read back as expected with other
#' HDF5 APIs.
#' 
#' Some of the basic functions:
#' 
#' ?newH5DF
#' ?openH5DF
#' ?openH5MAT
#' ?newH5MAT
#' ?newH5MEMDF
#' ?newH5MEMMAT
#' 
#' For a full list of functions in the name space (all have ?help docs)
#' objects("package:activeH5")
#' 
#' @docType package
#' @name activeH5
NULL####$$$$ activeH5-master\R/h5Classes.r
# This file contains the class descriptions for all the h5-based objects

#------------------------------------------------------------------------------------------------
# h5DF class specification
#------------------------------------------------------------------------------------------------

#' @title Specification of h5DF reference class
#' 
#' @description The h5DF object is an interface to a special type of HDF5 file that holds the data
#' for large data frames in chunks. Data frames are converted to numeric matrices, characters are
#' converted to factors and factors to numeric data. It is designed to allow fast access to 
#' chunks of data from the HDF5 file.
#' @section Methods in the h5DF object:
#' \itemize{
#'  \item h5DF$new() creates a new h5DF object. Users should use the functions ?newH5DF() and ?openH5DF().
#'  \item h5DF$createH5DF(DF, filePath, chunkSize, ...) populates a h5DF object with data from
#' a data frame or csv file containing a data frame DF. It writes the meta data to the h5DF object
#' and the dataset to a h5 file. Users should use the functions ?newH5DF() and ?openH5DF().
#' \itemize{
#'          \item DF a data frame or path to a csv file containing a data frame
#'          \item filePath path to a file where the h5 object will be written
#'          \item chunkSize the number of rows that will be written per chunk
#'          \item ... arguments that will be passed to the read.csv() function
#' }
#' \item h5DF$append(DF, ...) appends a data frame to the current h5 file and updates the meta data
#' in the file and on the object
#' \itemize{
#'          \item DF a data frame or path to a csv file containing a data frame
#'          \item h5DF$readChunk(chunkName) reads chunkName from the h5DF object returning a data frame chunk.
#'          \item chunkName character name of the chunk to be returned
#' }
#' \item h5DF$readChunks(chunks) reads the chunkNames from the h5DF object returning a
#' data frame containing all the chunks that have been read.
#' \itemize{
#'          \item chunks character vector name of the chunks to be binded together and returned as a data frame
#' }
#' \item h5DF$readTable() reads the whole table back into R. This is a convenience function and the
#' user must know whether their system has sufficient memory to accomodate the data frame.
#' \item h5DF$memorize() this function converts the h5DF object to a h5MEMDF object. It reads each chunk
#' to memory and supplies pointers in R to access each chunk. Very useful when you have lots of memory
#' in your system and need an efficient way to access chunks of data.
#' }
#'@section Fields in the h5DF object:
#'
#' These are the fields in the h5DF object, they are not to be directly modified by the user but can 
#' be accessed by h5DF$fieldName.
#'
#'\itemize{
#'\item nChunks: The number of chunks in the h5DF object
#'\item chunkNames: The names of the chunks in the h5DF object
#'\item colNames: The column names in the submitted data frame
#'\item colClasses: The classes of the submitted data frame
#'\item nrows: The number of rows in the data frame
#'\item ncols: The number of columns in the data frame
#'\item filePath: A character denoting the path to the h5 file
#'\item nfactors: The number of factor columns in the h5DF object
#'\item factors: A list containing the factor levels for each factor in the data frame
#'\item chunkSize: The number of rows each chunk will contain
#'\item MAT: For internal use when manipulating the data frame
#'\item oldNChunks: For internal use.
#'}
h5DF <- setRefClass(
  'h5DF',
  fields = c(nChunks = 'numeric', chunkNames = 'character', 
             colNames = 'character', colClasses = 'character',
             nrows = 'numeric', ncols = 'numeric', filePath = 'character', 
             nfactors = 'numeric',
             factors = 'list', chunkSize = 'numeric', MAT = 'matrix',
             oldNChunks = "numeric")
)

#------------------------------------------------------------------------------------------------
# h5MAT class specification
#------------------------------------------------------------------------------------------------

#' @title Specification of the h5MAT reference class
#' 
#' @description The h5MAT object is an interface to a special type of HDF5 file that holds data
#' for large matrices in chunks. It is designed to allow fast access to chunks of data from the HDF5 file.
#' 
#' @section Methods in the h5MAT object:
#' \itemize{
#' \item h5MAT$new() creates a new h5MAT object, users should use ?newH5MAT() or ?openH5MAT().
#' \item h5MAT$createH5MAT(MAT, filePath, chunkSize, ...) populates a h5MAT object with data from MAT.
#' Users should use ?newH5MAT() or ?openH5MAT().
#' \itemize{
#'    \item MAT a matrix or a path to a csv file containing a matrix to be converted to a h5MAT object
#'    \item filePath a character denoting a path to a location where the h5MAT object wll be written
#'    \item chunkSize number of rows denoting the size of each matrix chunk
#'    \item ... parameters to be passed to the read.csv() function
#' }
#' \item h5MAT$append(MAT, ...) appends matrix MAT to the current h5MAT object
#' \itemize{
#'    \item MAT a matrix or a path to a csv file containing a matrix to be converted to a h5MAT object
#'    \item ... parameters to be passed to the read.csv() function
#' }
#' \item h5MAT$readChunk(chunkName) reads the chunk denotes by chunkName into R as a matrix
#' \itemize{
#'    \item chunkName a character denoting the name of the chunk to be returned as a matrix 
#' }
#' \item h5MAT$readChunks(chunks) read the chunks denotes by chunks into R as a matrix
#' \itemize{
#'    \item chunks a character vector denoting the chunks to be read into R as a single matrix
#' }
#' \item h5MAT$readTable() reads the whole matrix in the h5MAT into R as a matrix
#' \item h5DF$memorize() this function converts the h5MAT object to a h5MEMMAT object. It reads each chunk
#' to memory and supplies pointers in R to access each chunk. Very useful when you have lots of memory
#' in your system and need an efficient way to access chunks of data.
#' }
#' @section Fields in the h5MAT object:
#' These are the fields in the h5MAT object, they are not to be directly modified by the user but can 
#' be accessed by h5MAT$fieldName.
#'
#'\itemize{
#'\item nChunks: The number of chunks in the h5MAT object
#'\item chunkNames: The names of the chunks in the h5MAT object
#'\item nrows: The number of rows in the data frame
#'\item ncols: The number of columns in the data frame
#'\item filePath: A character denoting the path to the h5 file
#'\item chunkSize: The number of rows each chunk will contain
#'\item MAT: For internal use when manipulating the data frame
#'\item oldNChunks: For internal use.
#'}
h5MAT <- setRefClass(
  'h5MAT',
  fields = c(nChunks = 'numeric', chunkNames = 'character',
             nrows = 'numeric', ncols = 'numeric', filePath = 'character', 
             chunkSize = 'numeric', MAT = 'matrix',
             oldNChunks = "numeric")
)

#------------------------------------------------------------------------------------------------
# h5MEMDF class specification
#------------------------------------------------------------------------------------------------

#' @title Specification of the h5MEMDF reference class
#' 
#' @description The h5MEMDF class allows the user to create a h5DF object in memory rather than on file.
#' The data frame chunks are stored in memory and these are accessed by pointers in the h5MEMDF object.
#' 
#' @section Methods in the h5MEMDF object:
#' \itemize{
#'  \item h5MEMDF$new() creates a new h5MEMDF object. Users should use the functions ?newH5MEMDF().
#'  \item h5MEMDF$createH5DF(df, chunkSize, ...) populates a h5MEMDF object with data from
#' a data frame or csv file containing a data frame df. It writes the meta data to the h5MEMDF object
#' and the dataset to a h5 file. Users should use the functions ?newH5MEMDF().
#' \itemize{
#'          \item df a data frame or path to a csv file containing a data frame
#'          \item chunkSize the number of rows that will be written per chunk
#'          \item ... arguments that will be passed to the read.csv() function
#' }
#' \item h5MEMDF$append(df, ...) appends a data frame to the current h5 file and updates the meta data
#' in the file and on the object
#' \itemize{
#'          \item df a data frame or path to a csv file containing a data frame
#'          \item ... arguments that will be passed to the read.csv() function
#' }
#' \item h5MEMDF$readChunk(chunkNum) reads chunkNum from the h5MEMDF object returning a data frame chunk.
#' \itemize{
#'          \item chunkNum numeric number of the chunk to be returned
#' }
#' \item h5MEMDF$createH5DF(filePath) creates a h5DF object from the h5MEMDF object writing the data to file
#' provided by filePath.
#' \itemize{
#'          \item filePath character denoting location for where the h5 file should be written.
#' }
#' }
#' 
#' @section Fields in the h5MEMDF object:
#' These are the fields in the h5MEMDF object, they are not to be directly modified by the user but can 
#' be accessed by h5MEMDF$fieldName.
#'
#'\itemize{
#'\item nChunks: The number of chunks in the h5MEMDF object
#'\item ptrs: A list of pointers to each of the chunks in the data frame
#'\item colNames: The column names in the submitted data frame
#'\item colClasses: The classes of the submitted data frame
#'\item nrows: The number of rows in the data frame
#'\item ncols: The number of columns in the data frame
#'\item nfactors: The number of factor columns in the h5MEMDF object
#'\item factors: A list containing the factor levels for each factor in the data frame
#'\item chunkSize: The number of rows each chunk will contain
#'\item DF: For internal use when manipulating the data frame
#'\item oldNChunks: For internal use.
#' }
h5MEMDF <- setRefClass(
  'h5MEMDF',
  fields = c(nChunks = 'numeric', colNames = 'character', colClasses = 'character',
             nrows = 'numeric', ncols = 'numeric',
             nfactors = 'numeric', ptrs = "list",
             factors = 'list', chunkSize = 'numeric', DF = 'data.frame',
             oldNChunks = "numeric")
)

#------------------------------------------------------------------------------------------------
# h5MEMMAT class specification
#------------------------------------------------------------------------------------------------

#' @title Specification of the h5MEMMAT reference class
#' 
#' @description The h5MEMMAT class allows the user to create a h5MAT object in memory rather than on file.
#' The matrix chunks are stored in memory and these are accessed by pointers in the h5MEMMAT object.
#' 
#' @section Methods in the h5MEMMAT object:
#' \itemize{
#' \item h5MEMMAT$new() creates a new h5MEMMAT object, users should use ?newH5MAT() or ?openH5MAT().
#' \item h5MEMMAT$createH5MAT(MAT, filePath, chunkSize, ...) populates a h5MEMMAT object with data from MAT.
#' Users should use ?newH5MAT() or ?openH5MAT().
#' \itemize{
#'    \item MAT a matrix or a path to a csv file containing a matrix to be converted to a h5MEMMAT object
#'    \item filePath a character denoting a path to a location where the h5MEMMAT object wll be written
#'    \item chunkSize number of rows denoting the size of each matrix chunk
#'    \item ... parameters to be passed to the read.csv() function
#' }
#' \item h5MEMMAT$append(MAT, ...) appends matrix MAT to the current h5MEMMAT object
#' \itemize{
#'    \item MAT a matrix or a path to a csv file containing a matrix to be converted to a h5MEMMAT object
#'    \item ... parameters to be passed to the read.csv() function
#' }
#' \item h5MEMMAT$readChunk(chunkName) reads the chunk denotes by chunkName into R as a matrix
#' \itemize{
#'    \item chunkName a character denoting the name of the chunk to be returned as a matrix 
#' }
#' \item h5MEMMAT$readChunks(chunks) read the chunks denotes by chunks into R as a matrix
#' \itemize{
#'    \item chunks a character vector denoting the chunks to be read into R as a single matrix
#' }
#' \item h5MEMMAT$readTable() reads the whole matrix in the h5MEMMAT into R as a matrix
#' \item h5MEMMAT$createH5MAT(filePath) this function converts the h5MEMMAT object to a h5MAT object. 
#' It writes the data in the h5MEMMAT object to filePath and returns a h5MAT object.
#' }
#' @section Fields in the h5MEMMAT object:
#' These are the fields in the h5MEMMAT object, they are not to be directly modified by the user but can 
#' be accessed by h5MEMMAT$fieldName.
#'
#'\itemize{
#'\item nChunks: The number of chunks in the h5MEMMAT object
#'\item ptrs: A list of pointers to each of the chunks in the matrix
#'\item nrows: The number of rows in the data frame
#'\item ncols: The number of columns in the data frame
#'\item chunkSize: The number of rows each chunk will contain
#'\item MAT: For internal use when manipulating the data frame
#'\item oldNChunks: For internal use.
#'}
h5MEMMAT <- setRefClass(
  'h5MEMMAT',
  fields = c(nChunks = 'numeric', nrows = 'numeric', ncols = 'numeric', ptrs = "list", 
             chunkSize = 'numeric', MAT = 'matrix', oldNChunks = "numeric")
)
#------------------------------------------------------------------------------------------------
####$$$$ activeH5-master\R/h5DF.r
# h5DF Methods
#------------------------------------------------------------------------------------------------
# Helper Methods
#------------------------------------------------------------------------------------------------

# Method: close()
h5DF$methods(close = function(){
  'The close() method closes the h5 file
    Usage:
    $close()
  '
  h5CloseFile(filePath)
})

# Method: flush()
h5DF$methods(flush = function(){
  ' The flush() method does the same thing as the close method
    Usage:
    $flush()
  '
  h5FlushFile(filePath)
})


#------------------------------------------------------------------------------------------------

# Method: createIndicies()
h5DF$methods(createIndicies = function(){
  ' The createIndicies() methods creates the indices that will be used to chunk the data
    Usage:
    $createIndicies()
  '
  nRows <- nrow(MAT)
  stubSize <- nRows %% chunkSize
  # Creating the indicies
  if(stubSize != 0)
  {
    #nChunks <- nRows %/% chunkSize + 1
    index <- c(1, seq(stubSize, nRows, by = chunkSize) + 1)
    indicies <- list()
    for(i in 2:length(index)){
      indicies[[i-1]] <- c(index[i - 1], index[i] - 1)
    }
  }else{
    #nChunks <- nRows / chunkSize
    index <- seq(chunkSize, nRows, chunkSize)
    indicies <- list()
    for(i in 1:length(index))
    {
      indicies[[i]] <- c(index[i] - chunkSize + 1, index[i])
    }
  }
  return(indicies)
})

#------------------------------------------------------------------------------------------------
# Write Methods
#------------------------------------------------------------------------------------------------

# Method: createMetaData()
h5DF$methods(createMetaData = function(DF){
  ' The createMetaData() method is not intended for the user. It is used to create the
    meta data for a new object on file and in the h5DF object.
    @param DF data frame to be used to create the meta data
    Usage:
    $createMetaData((data.frame) DF)
  '
  
  nrows <<- nrow(DF)
  ncols <<- ncol(DF)
  
  stub  <- nrows %% chunkSize
  if(stub == 0){
    nChunks <<- nrows %/% chunkSize
  }else{
    nChunks <<- nrows %/% chunkSize + 1
  }
  chunkNames <<- paste("ch", 1:nChunks, sep = "")
  
  DF <- as.list(DF)
  colNames <<- names(DF)
  colClasses <<- unlist(lapply(DF, function(x)class(x)[1]))
  
  cat("Converting character to factors", "\n")
  colClasses[colClasses == "character"] <<- "factor"
  cat("Registering any factor columns", "\n")
  factorCols <- colNames[which(colClasses == 'factor')]
  nfactors <<- length(factorCols)
  if(nfactors > 0){
    lFactors <- vector(mode = 'list', length = nfactors)
    names(lFactors) <- factorCols
    for(i in factorCols)
    {
      colClass <- class(DF[[i]][1])
      if(colClass != "factor")
      {
        DF[[i]] <- factor(DF[[i]])
      }
      lFactors[[i]] <- levels(DF[[i]][1])
    }
    factors <<- lFactors
  }
  oldNChunks <<- 0
  
  cat("Creating the matrix for writing ...", "\n")
  DF <- lapply(DF, unclass)
  DF <- do.call(cbind, DF)
  DF[1,1] <- as.numeric(DF[1,1])
  MAT <<- DF
  
  h5CreateFile(filePath, overwrite = 1)
  h5CreateMetaData(filePath);
  h5WriteInt("NRow", nrows, filePath, update = 0)
  h5WriteInt("NCol", ncols, filePath, update = 0)
  h5WriteInt("NChunks", nChunks, filePath, update = 0)
  h5WriteInt("ChunkSize", chunkSize, filePath, update = 0)
  h5WriteCharVector("ColumnNames", colNames, filePath, update = 0)
  h5WriteCharVector("ColumnClasses", colClasses, filePath, update = 0)
  h5WriteCharVector("ChunkNames", chunkNames, filePath, update = 0)
  if(nfactors > 0){
    for(i in factorCols)
    {
      h5WriteFactor(i, factors[[i]], filePath, update = 0)
    }
  }
})

# Method: writeDoubleMat()
h5DF$methods(writeDoubleMat = function(){
  ' The method writeDoubleMat() is not intended for the user. It is an internal method to be used to 
    write chunks of data as matrices to the h5 object.
    Usage:
    $writeDoubleMat()
  '
  indicies <- createIndicies()
  for(i in 1:length(indicies)){
    ind <- indicies[[i]]
    subMatrix <- MAT[seq(ind[1], ind[2]),]
    h5WriteDoubleMat(dset = chunkNames[(i + oldNChunks)], chunk = subMatrix, dim = dim(subMatrix), filePath)
  }
})

# Method: createH5DF()
h5DF$methods(createH5DF = function(DF, filePath, chunkSize, ...){
  ' The createH5DF() method populates a new h5DF object with data defined by DF, filePath, and chunkSize.
    Users are directed to the newH5DF() and openH5DF() functions which are more convenient
    @param DF the data frame to be appended. Either a data.frame or a character denoting a csv file
          containing the data frame to be appended.
    @param filePath path to the file where the h5 object will be written
    @param chunkSize number of rows in each chunk
    @param ... parameters passed to read.csv() function
    Usage:
    $createH5DF((data.frame or character) DF, (character) filePath, (numeric) chunkSize, ...)
  '
  cat("Initializing ...\n")
  
  if(class(DF) == "character"){
    if(file.exists(DF))
    {
      cat("Reading data from CSV file", "\n")
      DF <- read.csv(file = DF, ...)
    }else{
      stop("DF not recognised as text file or data frame")
    }
  }
  
  filePath <<- filePath
  chunkSize <<- chunkSize
  cat('Creating meta data on file ...', '\n')
  createMetaData(DF)
  cat('Writing data to file ...', '\n')
  writeDoubleMat()
  MAT <<- matrix(0)
})

#' @title Function to create a new h5DF object
#' 
#' @param DF data frame or file path to csv file containing data frame to be written to h5DF object
#' @param filePath path to file that will contain the h5DF data object
#' @param chunkSize the number of rows that each chunk will take
#' @param ... parameters passed to read.csv() function
#' @return a h5DF object
#' @examples
#' # Create a new h5DF object from the iris dataset
#' ir1 <- newH5DF(iris, "iris.h5", 10)
#' ir1 # The details of the object
#' chNames <- ir1$chunkNames # The names of the chunks
#' ir1$readChunk(chNames[3]) # read chunk number 3
#' ir1$readChunks(chNames[1:5]) # read the first 5 chunks
#' ir1$readTable() # reads back the whole table
#' ir2 <- openH5DF("iris.h5") # create H5 df from file
#' # Create a h5MEMDF object from a h5DF object by memorize (i.e. brings the h5DF object into memory)
#' irMDF <- ir2$memorize()
#' irMDF # this is a h5MEMDF object, chunked DF object in memory with pointers
#' irMDF$ptrs
newH5DF <- function(DF, filePath, chunkSize = 50000, ...)
{
  obj <- h5DF$new()
  obj$createH5DF(DF, filePath, chunkSize, ...)
  return(obj)
}

#------------------------------------------------------------------------------------------------
# Update Methods
#------------------------------------------------------------------------------------------------

# Method: updateMetaData()
h5DF$methods(updateMetaData = function(DF){
  ' The updateMetaData() method is an internal method and not intended to use by the user. It updates
    the meta data of the h5DF object on file and in R when the user appends new data.
    @param DF
    Usage:
    $updateMetaData((data.frame) DF)
  '
  nRows <- nrow(DF)
  nrows <<- nrows + nRows
  oldNChunks <<- nChunks
  # Updating nChunks
  stub  <- nRows %% chunkSize
  if(stub == 0){
    nchunks <- nRows %/% chunkSize
  }else{
    nchunks <- nRows %/% chunkSize + 1
  }
  nChunks <<- oldNChunks + nchunks
  newChunkNames <- paste("ch", (oldNChunks + 1):nChunks, sep = "")
  #print(newChunkNames)
  chunkNames <<- c(chunkNames, newChunkNames)
  
  # Convert DF to list
  DF <- as.list(DF)
  
  # Column class adjustments
  factorCols <- colNames[colClasses == 'factor']
  lFactors <- factors # local copy of factors
  for(i in factorCols)
  {
    colClass <- class(DF[[i]][1])
    if(colClass == "factor")
    {
      lLvls <- lFactors[[i]]
      tmpLvls <- levels(DF[[i]])
      lFactors[[i]] <- c(lLvls, tmpLvls[!(tmpLvls %in% lLvls)])
      DF[[i]] <- factor(DF[[i]], levels = lFactors[[i]])
    }
    if(colClass != "factor")
    {
      warning("Converting non factor columns to factors ...")
      lLvls <- lFactors[[i]]
      tmpUnique <- as.character(unique(DF[[i]]))
      lFactors[[i]] <- c(lLvls, tmpUnique[!(tmpUnique %in% lLvls)])
      DF[[i]] <- factor(DF[[i]], levels = lFactors[[i]])
    }
  }
  
  factors <<- lFactors
  # Conversion to numeric (may not have to do this, cbind may simple enforce numeric)
  DF <- lapply(DF, unclass)
  DF <- do.call(cbind, DF)
  # Enforcing numeric matric
  DF[1,1] <- as.numeric(DF[1,1])
  # Writing to MAT field
  MAT <<- DF
  
  # Updating the meta data
  # Update the number of rows
  h5WriteInt("NRow", nrows, filePath, update = 1)
  # Number of chunks
  h5WriteInt("NChunks", nChunks, filePath, update = 1)
  # char vector to update chunk names
  h5WriteCharVector("ChunkNames", chunkNames, filePath, update = 1)
  # Now write the factors into the meta data if they are present
  if(nfactors > 0){
    for(i in factorCols)
    {
      # Writing factors to the factor group of the metadata group of the H5 file
      h5WriteFactor(i, lFactors[[i]], filePath, update = 1)
    }
  }
  # Set Finalized
  #h5WriteInt("Finalized", 0, filePath, update = 1)
})

# Method: append()
h5DF$methods(append = function(DF, ...){
  ' The append() method allows new data to be appended to a h5DF object.
    @param DF the data frame to be appended. Either a data.frame or a character denoting a csv file
          containing the data frame to be appended.
    @param ... parameters passed to read.csv() function
    Usage:
    $append((data.frame or character) DF, (passed to read.csv) ...)
  '
  if(class(DF) == "character"){
    if(file.exists(DF))
    {
      cat("Reading data from CSV file", "\n")
      DF <- read.csv(file = DF, ...)
    }else{
      stop("DF not recognised as text file or data frame")
    }
  }
  cat('Updating meta data on file ...', '\n')
  updateMetaData(DF)
  cat('Appending data to file ...', '\n')
  writeDoubleMat()
  oldNChunks <<- 0
  MAT <<- matrix(0)
})

#------------------------------------------------------------------------------------------------
# Read Methods
#------------------------------------------------------------------------------------------------

#' @title Function to create a new h5DF object from h5 file
#' 
#' @param filePath path to file that contain the h5DF data object
#' @return a h5DF object
#' @examples
#' # Create a new h5DF object from the iris dataset
#' ir1 <- newH5DF(iris, "iris.h5", 10)
#' ir1 # The details of the object
#' chNames <- ir1$chunkNames # The names of the chunks
#' ir1$readChunk(chNames[3]) # read chunk number 3
#' ir1$readChunks(chNames[1:5]) # read the first 5 chunks
#' ir1$readTable() # reads back the whole table
#' ir2 <- openH5DF("iris.h5") # create H5 df from file
#' # Create a h5MEMDF object from a h5DF object by memorize (i.e. brings the h5DF object into memory)
#' irMDF <- ir2$memorize()
#' irMDF # this is a h5MEMDF object, chunked DF object in memory with pointers
#' irMDF$ptrs
openH5DF <- function(filePath){
  if(!file.exists(filePath)){
    stop("File does not exists")
  }
  # Creating and updating the h5DF object
  h5Obj <- h5DF$new()
  h5Obj$filePath <- filePath
  cat("Reading in basic file information", "\n")
  nChunks <- h5ReadInt(intName = "NChunks", filePath)
  chunkNames <- h5ReadCharVector(charName = "ChunkNames", filePath)
  cat("Checking chunkNames against nChunks")
  
  h5Obj$nChunks <- nChunks
  h5Obj$chunkNames <- chunkNames
  h5Obj$nrows <- h5ReadInt(intName = "NRow", filePath)
  h5Obj$ncols <- h5ReadInt(intName = "NCol", filePath)
  h5Obj$chunkSize <- h5ReadInt(intName = "ChunkSize", filePath)
  colNames <- h5ReadCharVector(charName = "ColumnNames", filePath)
  colClasses <- h5ReadCharVector(charName = "ColumnClasses", filePath)
  
  
  factorNames <- colNames[colClasses == "factor"]
  nfactors <- length(factorNames)
  if(nfactors > 0)
  {
    factors <- vector(mode = "list", length = nfactors)
    names(factors) <- factorNames
    for(i in factorNames)
    {
      factors[[i]] <- h5ReadFactor(i, filePath)
    }
  }else{
    factors <- list()
  }
  h5Obj$colNames <- colNames
  h5Obj$colClasses <- colClasses
  h5Obj$nfactors <- nfactors
  h5Obj$factors <- factors
  h5Obj$oldNChunks <- 0
  return(h5Obj)
}

# Method: readChunk()
h5DF$methods(readChunk = function(chunkName){
  ' The readChunk() method reads a chunk from the h5DF object into R as a data frame
    @param chunkName the name of the chunk to be read into R.
    Usage:
    $readChunk((character) chunkName)
  '
  return(do.call(cbind.data.frame, h5ChunkList(chunkName, filePath)))
})

# Method: chunkSel()
h5DF$methods(chunkSel = function(chunkName, selCols){
  ' The chunkSel method returns a data frame form the h5DF object selecting columns
    specified by selCols.
    @param chunkName character the name of the chunk to be read
    @param selCols character names of the columns to be selecting within the chunk
    $chunkSel((character) chunkName, (character) selCols)
  '
  return(do.call(cbind.data.frame, h5ChunkSel(chunkName, selCols, filePath)))
})

# Method: modelFrame()
h5DF$methods(modelFrame = function(chunkName, selCols){
  ' The modelFrame method returns a list from the h5DF object selecting columns
    specified by selCols, omiting rows that have NA values. Each list item represents
    a column from the data frame.
    @param chunkName character the name of the chunk to be read
    @param selCols character names of the columns to be selecting within the chunk
    $modelFrame((character) chunkName, (character) selCols)
  '
  return(h5ModelFrame(chunkName, selCols, filePath))
})

# Method: readChunks()
h5DF$methods(readChunks = function(chunks){
  ' The readChunks() methods reads chunks defined by a character vector into R
    @param chunks a character vector of chunkNames to be read into R.
    Usage:
    $readChunks((character) chunks)
  '
  cat("Reading the data from H5 file ...", "\n")
  df <- do.call(rbind, lapply(chunks, h5ReadDoubleMat, filePath = filePath))
  cat("H5 data read, now formatting the data ...", "\n")
  df <- lapply(1:ncol(df), function(x)df[,x])
  names(df) <- colNames
  fNames <- names(factors)
  for(i in 1:length(factors)){
    tmpLvls <- factors[[i]]
    tmp <- as.integer(df[[fNames[i]]])
    attr(tmp, "levels") <- tmpLvls
    attr(tmp, "class") <- "factor"
    df[[fNames[i]]] <- tmp
  }
  df <- do.call(cbind.data.frame, df)
  return(df)
})

# Method: readTable()
h5DF$methods(readTable = function(){
  ' The readTable() method reads all the chunks in the h5DF object and returns them as a single data frame.
  '
  cat("Reading the data from H5 file ...", "\n")
  df <- do.call(rbind, lapply(chunkNames, h5ReadDoubleMat, filePath = filePath))
  cat("H5 data read, now formatting the data ...", "\n")
  df <- lapply(1:ncol(df), function(x)df[,x])
  names(df) <- colNames
  fNames <- names(factors)
  for(i in 1:length(factors)){
    tmpLvls <- factors[[i]]
    tmp <- as.integer(df[[fNames[i]]])
    attr(tmp, "levels") <- tmpLvls
    attr(tmp, "class") <- "factor"
    df[[fNames[i]]] <- tmp
  }
  df <- do.call(cbind.data.frame, df)
  return(df)
})

# Method: readMatChunk()
h5DF$methods(readMatChunk = function(chunkName){
  ' The readMatChunk() function is not intended to be used by the user. It reads back the data frame
  as a numeric matrix in the form that it is stored in h5 file without converting it back into a data frame.
  It is intended for diagnostic purposes.
  @param chunkName the name of the chunk to be read back.
  Usage:
  $readMatChunk((character) chunkName)
  '
  return(h5ReadDoubleMat(chunkName, filePath))
})

#------------------------------------------------------------------------------------------------
# Legacy Methods
#------------------------------------------------------------------------------------------------
# This function returns a list from c++ which is then bound together to get a data frame
# Slower than the default version
h5DF$methods(readChunkcpp = function(chunkName){
  'The readChunkcpp() method is a legacy method and no longer used'
  cat("Reading chunk ", chunkName, "\n")
  df <- h5ReadDoubleMat2(chunkName, filePath)
  df <- do.call(cbind.data.frame, df)
  return(df)
})

# Function returns the list after processing the matrix returned from the HDF5 file
h5DF$methods(readAsList = function(chunkName){
  'The readAsList() method is a legacy method and no longer used'
  cat("Reading chunk ", chunkName, "\n")
  lst <- h5ReadDoubleMat(chunkName, filePath)
  lst <- lapply(1:ncol(lst), function(x)lst[,x])
  names(lst) <- colNames
  fNames <- names(factors)
  for(i in 1:length(factors)){
    tmpLvls <- factors[[i]]
    tmp <- as.integer(lst[[fNames[i]]])
    attr(tmp, "levels") <- tmpLvls
    attr(tmp, "class") <- "factor"
    lst[[fNames[i]]] <- tmp
  }
  return(lst)
})

# Function to read whole table returning as list of data frames
h5DF$methods(readTableList = function(){
  'The readTableList() method is a legacy method and no longer used'
  out <- list()
  for(i in chunkNames)
    out[[i]]  <- readChunk(i)
  return(out)
})
####$$$$ activeH5-master\R/h5MAT.r
# h5MAT Methods
#------------------------------------------------------------------------------------------------
# Helper Methods
#------------------------------------------------------------------------------------------------

# Method: close()
h5MAT$methods(close = function(){
  ' The close() method closes the h5 file object
    Usage:
    $close()
  '
  h5CloseFile(filePath)
})


# Method: flush()
h5MAT$methods(flush = function(){
  ' The flush() method is the same as the close method
    Usage:
    $flush()
  '
  h5FlushFile(filePath)
})

#------------------------------------------------------------------------------------------------

# Method: createIndicies()
h5MAT$methods(createIndicies = function(){
  ' The createIndicies() methods creates the indices that will be used to chunk the data
    Usage:
    $createIndicies()
  '
  nRows <- nrow(MAT)
  stubSize <- nRows %% chunkSize
  # Creating the indicies
  if(stubSize != 0)
  {
    #nChunks <- nRows %/% chunkSize + 1
    index <- c(1, seq(stubSize, nRows, by = chunkSize) + 1)
    indicies <- list()
    for(i in 2:length(index)){
      indicies[[i-1]] <- c(index[i - 1], index[i] - 1)
    }
  }else{
    #nChunks <- nRows / chunkSize
    index <- seq(chunkSize, nRows, chunkSize)
    indicies <- list()
    for(i in 1:length(index))
    {
      indicies[[i]] <- c(index[i] - chunkSize + 1, index[i])
    }
  }
  return(indicies)
})

#------------------------------------------------------------------------------------------------
# Write Methods
#------------------------------------------------------------------------------------------------

# Method: createMetaData()
h5MAT$methods(createMetaData = function(){
  ' The createMetaData() method is not intended for the user. It is used to create the
    meta data for a new object on file and in the h5MAT object.
    Usage:
    $createMetaData()
  '
  nrows <<- nrow(MAT) # Time efficient
  ncols <<- ncol(MAT) # Time efficient
  
  stub  <- nrows %% chunkSize
  if(stub == 0){
    nChunks <<- nrows %/% chunkSize
  }else{
    nChunks <<- nrows %/% chunkSize + 1
  }
  chunkNames <<- paste("ch", 1:nChunks, sep = "")
  
  cat('Creating meta data on file ...', '\n')
  
  oldNChunks <<- 0
  
  # Create the H5 file
  h5CreateFile(filePath, overwrite = 1)
  # Initialize the structure for the meta data group
  h5CreateMetaData(filePath)
  # Write the number of rows
  h5WriteInt("NRow", nrows, filePath, update = 0)
  # Write the number of columns
  h5WriteInt("NCol", ncols, filePath, update = 0)
  # Number of chunks
  h5WriteInt("NChunks", nChunks, filePath, update = 0)
  # Chunk Size
  h5WriteInt("ChunkSize", chunkSize, filePath, update = 0)
  # Chunk Names
  h5WriteCharVector("ChunkNames", chunkNames, filePath, update = 0)
#   h5WriteInt("Finalized", 0, filePath, update = 0)
})

# Method: writeDoubleMat()
h5MAT$methods(writeDoubleMat = function(){
  ' The method writeDoubleMat() is not intended for the user. It is an internal method to be used to 
    write chunks of data as matrices to the h5 object.
    Usage:
    $writeDoubleMat()
  '
  indicies <- createIndicies()
  for(i in 1:length(indicies)){
    ind <- indicies[[i]]
    subMatrix <- MAT[seq(ind[1], ind[2]),]
    cat("Writing chunk", i, "\n")
    h5WriteDoubleMat(dset = chunkNames[(i + oldNChunks)], chunk = subMatrix, dim = dim(subMatrix), filePath)
  }
})

# Method: createH5MAT()
h5MAT$methods(createH5MAT = function(MAT, filePath, chunkSize, ...){
  ' The createH5MAT() method populates a new h5MAT object with data defined by MAT, filePath, and chunkSize.
    Users are directed to the newH5MAT() and openH5MAT() functions which are more convenient.
    @param MAT matrix or character file path to CSV containing matrix to be written to H5 file object
    @param filePath character path to file where h5 file will be written
    @param ... arguments passed to read.csv() function
    Usage:
    $createH5MAT((matrix or character) MAT, (character) filePath, (numeric) chunkSize, ...)
  '
  cat("Initializing ...\n")
  if(class(MAT) == "character"){
    if(file.exists(MAT))
    {
      cat("Reading data from CSV file", "\n")
      mat <- read.csv(file = MAT, ...)
      MAT <<- do.call(cbind, lapply(1:ncol(mat), function(i)mat[,i]))
    }else{
      stop("MAT not recognised as text file or matrix")
    }
  }else{
    MAT <<- MAT
  }
  filePath <<- filePath
  chunkSize <<- chunkSize
  createMetaData()
  writeDoubleMat()
  MAT <<- matrix(0)
})

#' @title Function to create a new h5MAT object
#' 
#' @param MAT matrix or csv file containing a matrix to be converted into a h5MAT object
#' @param filePath character path to the file to be written
#' @param chunkSize the number of rows for each chunk
#' @param ... arguments sent to \code{read.csv()} function
#' @return returns a h5MAT object
#' @examples
#' n <- 1e3
#' mat <- matrix(runif(n^2), nc = n) 
#' hmat <- newH5MAT(mat, "mat.h5", 1E2) # a h5MAT object
#' hmat$append(mat, "mat.h5", 1E2) # append the matrix
#' ch <- hmat$readChunk("ch2") # reading a chunk into the matrix
#' ch[1:10, 1:10]
#' # Reading several chunks
#' hmat$readChunks(paste("ch", 1:5, sep = ""))
#' # Reading the table
#' tab <- hmat$readTable()
#' # Create a h5MEMMAT object
#' memtab <- hmat$memorize()
newH5MAT <- function(MAT, filePath, chunkSize, ...)
{
  obj <- h5MAT$new()
  obj$createH5MAT(MAT, filePath, chunkSize, ...)
  return(obj)
}

#------------------------------------------------------------------------------------------------
# Update Methods
#------------------------------------------------------------------------------------------------

# Method: updateMetaData()
h5MAT$methods(updateMetaData = function(){
  ' The updateMetaData() method is an internal method and not intended to use by the user. It updates
    the meta data of the h5MAT object on file and in R when the user appends new data.
    Usage:
    $updateMetaData()
  '
  nRows <- nrow(MAT)
  nrows <<- nrows + nRows
  oldNChunks <<- nChunks
  # Updating nChunks
  stub  <- nRows %% chunkSize
  if(stub == 0){
    nchunks <- nRows %/% chunkSize
  }else{
    nchunks <- nRows %/% chunkSize + 1
  }
  nChunks <<- oldNChunks + nchunks
  newChunkNames <- paste("ch", (oldNChunks + 1):nChunks, sep = "")
  chunkNames <<- c(chunkNames, newChunkNames)
  
  h5WriteInt("NRow", nrows, filePath, update = 1)
  h5WriteInt("NChunks", nChunks, filePath, update = 1)
  h5WriteCharVector("ChunkNames", chunkNames, filePath, update = 1)
})

# Method: append()
h5MAT$methods(append = function(MAT, ...){
  ' The append() method allows new data to be appended to a h5MAT object.
    @param MAT the matrix to be appended. Either a matrix or a character denoting a csv file
          containing the matrix to be appended.
    @param ... parameters passed to read.csv() function
    Usage:
    $append((matrix or character) MAT, (passed to read.csv()) ...)
  '
  if(class(MAT) == "character"){
    if(file.exists(MAT))
    {
      cat("Reading data from CSV file", "\n")
      mat <- read.csv(file = MAT, ...)
      MAT <<- do.call(cbind, lapply(1:ncol(mat), function(i)mat[,i]))
    }else{
      stop("MAT not recognised as text file or matrix")
    }
  }else{
    MAT <<- MAT
  }
  updateMetaData()
  writeDoubleMat()
  oldNChunks <<- 0
  MAT <<- matrix(0)
})

#------------------------------------------------------------------------------------------------
# Read Methods
#------------------------------------------------------------------------------------------------

#' @title Function to create a h5MAT object from a saved h5 file
#' 
#' @param filePath path to file containing h5MAT object
#' @return returns a h5MAT object
#' @examples
#' n <- 1e3
#' mat <- matrix(runif(n^2), nc = n) 
#' hmat <- newH5MAT(mat, "mat.h5", 1E2) # a h5MAT object
#' hmat2 <- openH5MAT("mat.h5")
openH5MAT <- function(filePath){
  if(!file.exists(filePath)){
    stop("File does not exists")
  }
  cat("Reading in basic file information", "\n")
  nChunks <- h5ReadInt(intName = "NChunks", filePath)
  chunkNames <- h5ReadCharVector(charName = "ChunkNames", filePath)
  nrows <- h5ReadInt(intName = "NRow", filePath)
  ncols <- h5ReadInt(intName = "NCol", filePath)
  chunkSize <- h5ReadInt(intName = "ChunkSize", filePath)
  
  cat("Writing items to local h5MAT object")
#   finalized <- h5ReadInt(intName = "Finalized", filePath)
#   if(finalized == 0){
#     eMess <- "The file you are trying to read is corrupted, it has not been finalized."
#     stop(eMess)
#   }
  
  # Creating and updating the h5MAT object
  h5Obj <- h5MAT$new()
  h5Obj$filePath <- filePath
  h5Obj$nrows <- nrows
  h5Obj$ncols <- ncols
  h5Obj$nChunks <- nChunks
  h5Obj$chunkNames <- chunkNames
  h5Obj$chunkSize <- chunkSize
  h5Obj$oldNChunks <- 0
  return(h5Obj)
}

# Method: readChunk()
h5MAT$methods(readChunk = function(chunkName){
  ' The readChunk() method reads a chunk from the h5MAT object into R as a matrix
    @param chunkName the name of the chunk to be read into R.
    Usage:
    $readChunk((character) chunkName)
  '
  cat("Reading chunk ", chunkName, "\n")
  df <- h5ReadDoubleMat(chunkName, filePath)
  return(df)
})

# Method: readChunks()
h5MAT$methods(readChunks = function(chunks){
  ' The readChunks() methods reads chunks defined by a character vector into R
    @param chunks a character vector of chunkNames to be read into R.
    Usage:
    $readChunks((character) chunks)
  '
  cat("Reading the data from H5 file ...", "\n")
  df <- do.call(rbind, lapply(chunks, h5ReadDoubleMat, filePath = filePath))
  return(df)
})


# Method: readTable()
h5MAT$methods(readTable = function(){
  ' The readTable() method reads all the chunks in the h5MAT object and returns them as a single matrix.
    Usage:
    $readTable()
  '
  cat("Reading the data from H5 file ...", "\n")
  df <- do.call(rbind, lapply(chunkNames, h5ReadDoubleMat, filePath = filePath))
  return(df)
})

####$$$$ activeH5-master\R/h5MEMDF.r
# h5MEMDF Methods
#------------------------------------------------------------------------------------------------
# Helper Methods
#------------------------------------------------------------------------------------------------

# Method: createIndicies()
h5MEMDF$methods(createIndicies = function(){
  ' This methods creates chunking indices from the current data in the DF field
  Usage:
  $createIndicies()
  '
  nRows <- nrow(DF)
  stubSize <- nRows %% chunkSize
  # Creating the indicies
  if(stubSize != 0)
  {
    index <- c(1, seq(stubSize, nRows, by = chunkSize) + 1)
    indicies <- list()
    for(i in 2:length(index)){
      indicies[[i-1]] <- c(index[i - 1], index[i] - 1)
    }
  }else{
    index <- seq(chunkSize, nRows, chunkSize)
    indicies <- list()
    for(i in 1:length(index))
    {
      indicies[[i]] <- c(index[i] - chunkSize + 1, index[i])
    }
  }
  return(indicies)
})

#------------------------------------------------------------------------------------------------
# Write Methods
#------------------------------------------------------------------------------------------------

# Method: createMetaData()
h5MEMDF$methods(createMetaData = function(df){
  ' The createMetaData() method is not intended for the user. It is used to create the
    meta data for a new object in the h5MEMDF object.
    @param df data frame to be written to memory
    Usage:
    $createMetaData((data.frame) df)
  '
  
  nrows <<- nrow(df)
  ncols <<- ncol(df)
  
  stub  <- nrows %% chunkSize
  if(stub == 0){
    nChunks <<- nrows %/% chunkSize
  }else{
    nChunks <<- nrows %/% chunkSize + 1
  }
  
  colNames <<- colnames(df)
  colClasses <<- unlist(lapply(df, function(x)class(x)[1]))
  
  cat("Converting character to factors", "\n")
  colClasses[colClasses == "character"] <<- "factor"
  cat("Registering any factor columns", "\n")
  factorCols <- colNames[which(colClasses == 'factor')]
  nfactors <<- length(factorCols)
  if(nfactors > 0){
    lFactors <- vector(mode = 'list', length = nfactors)
    names(lFactors) <- factorCols
    for(i in factorCols)
    {
      colClass <- class(df[[i]][1])
      if(colClass != "factor")
      {
        df[[i]] <- factor(df[[i]])
      }
      lFactors[[i]] <- levels(df[[i]][1])
    }
    factors <<- lFactors
  }
  oldNChunks <<- 0

  DF <<- df
})

h5MEMDF$methods(writeDataFrame = function(){
  ' The writeDataFrame() method writes the data frame to memory and populates the ptrs field in the 
    h5MEMDF object. This function is not intended for the user.
    Usage:
    $writeDataFrame()
  '
  indicies <- createIndicies()
  cat("Writing to memory", "\n")
  for(i in 1:length(indicies)){
    ind <- indicies[[i]]
    subDF <- DF[seq(ind[1], ind[2]),]
    ptrs <<- c(ptrs, h5WriteMemDF(obj = subDF))
  }
})


h5MEMDF$methods(createH5MEMDF = function(df, chunkSize, ...){
  ' The createH5MEMDF() method populates data in memory and the meta data in the h5MEMDF object
  @param df a data frame or path to a csv file containing a data frame
  @param chunkSize the number of rows that each chunk should contain
  @param ... parameters passed to read.csv() function
  Usage:
  $initialize((data.frame or character) df, (character) filePath, (numeric) chunkSize, 
        (parameters passed to read.csv()) ...)
  '
  cat("Initializing ...\n")
  if(class(df) == "character"){
    if(file.exists(df))
    {
      cat("Reading data from CSV file", "\n")
      df <- read.csv(file = df, ...)
    }else{
      stop("DF not recognised as text file or data frame")
    }
  }
  chunkSize <<- chunkSize
  createMetaData(df)
  writeDataFrame()
  DF <<- data.frame(0)
})


#' @title Function to create a new h5MEMDF object
#' 
#' @param df data frame or file path to csv file containing data frame to be written to h5DF object
#' @param chunkSize the number of rows that each chunk will take.
#' @param ... parameters passed to read.csv() function
#' @return a h5MEMDF object
#' @examples
#' # Create a new h5MEMDF object from the iris dataset
#' ir1 <- newH5MEMDF(iris[1:100,], 10)
#' ir1 # The details of the object
#' ir1$readChunk(1) # read chunk number 3
#' ir1$append(iris[101:150,]) # appending data
newH5MEMDF <- function(df, chunkSize = 50000, ...)
{
  obj <- h5MEMDF$new()
  obj$createH5MEMDF(df, chunkSize, ...)
  return(obj)
}

#------------------------------------------------------------------------------------------------
# Update Methods
#------------------------------------------------------------------------------------------------

# Method: updateMetaData()
h5MEMDF$methods(updateMetaData = function(df){
  ' The updateMetaData() function updates the meta data in the h5MEMDF object with any new information
    form data to be appended to the current data set.
    @param df data frame or character with path to cssv file containing data frame with data to be used
            to update the h5MEMDF object.
    Usage:
    $updateMetaData((data.frame or character df))
  '
  nRows <- nrow(df)
  nrows <<- nrows + nRows
  oldNChunks <<- nChunks
  # Updating nChunks
  stub  <- nRows %% chunkSize
  if(stub == 0){
    nchunks <- nRows %/% chunkSize
  }else{
    nchunks <- nRows %/% chunkSize + 1
  }
  nChunks <<- oldNChunks + nchunks
  newChunkNames <- paste("ch", (oldNChunks + 1):nChunks, sep = "")
  
  # Column class adjustments
  factorCols <- colNames[colClasses == 'factor']
  lFactors <- factors # local copy of factors
  for(i in factorCols)
  {
    colClass <- class(df[[i]][1])
    if(colClass == "factor")
    {
      lLvls <- lFactors[[i]]
      tmpLvls <- levels(df[[i]][1])
      lFactors[[i]] <- c(lLvls, tmpLvls[!(tmpLvls %in% lLvls)])
      df[[i]] <- factor(df[[i]], levels = lFactors[[i]])
    }
    if(colClass != "factor")
    {
      warning("Converting non factor columns to factors ...")
      lLvls <- lFactors[[i]]
      tmpUnique <- as.character(unique(df[[i]]))
      lFactors[[i]] <- c(lLvls, tmpUnique[!(tmpUnique %in% lLvls)])
      df[[i]] <- factor(df[[i]], levels = lFactors[[i]])
    }
  }
  
  factors <<- lFactors
  DF <<- df
})

# Method: append()
h5MEMDF$methods(append = function(df, ...){
  ' The append() method allows the user to append new data to the current h5MEMDF object.
    @param df the data frame or character path to a csv file containing the data frame to
            be appended to the h5MEMDF object
    @param ... arguments to be passed to read.csv()
    Usage:
    $append((data.frame or character) df, (arguments passed to read.csv()) ...)
  '
  if(class(df) == "character"){
    if(file.exists(df))
    {
      cat("Reading data from CSV file", "\n")
      df <- read.csv(file = df, ...)
    }else{
      stop("DF not recognised as text file or data frame")
    }
  }
  updateMetaData(df)
  writeDataFrame()
  oldNChunks <<- 0
  DF <<- data.frame(0)
})

#------------------------------------------------------------------------------------------------
# Read Methods
#------------------------------------------------------------------------------------------------

# Method: readChunk()
h5MEMDF$methods(readChunk = function(chunkNum){
  ' The readChunk() method reads a chunk denoted by chunkNum from memory into R.
    @param chunkNum numeric number of chunk to be read back into R.
    Usage:
    $readChunk((numeric (chunkNum)))
  '
  return(h5ReadMemDF(ptrs[[chunkNum]]))
})

# Method: readTable()
h5MEMDF$methods(readTable = function(){
  ' The readTable() method allows the user to either read a list of chunks as
    a data frame from memory or read the whole data as a table
    @param: chunkNums the vector of chunks to be read back to R.
    Usage:
    $readTable((numeric) (chunkNums))
  '
  # empty output list object
  output <- replicate(length(colNames), vector(mode = "numeric", 
                                               length = nrows), simplify = F)
  names(output) <- colNames
  startRow <- 1 # the row that were are at
  for(i in 1:nChunks)
  {
    temp <- readChunk(i)
    nRowsChunk <- nrow(temp) # The number of rows in this chunk
    endRow <- startRow + nRowsChunk - 1
    # Inserts into respective positions in columns
    for(j in 1:length(colNames))
    {
      output[[j]][startRow:endRow] <- temp[[j]]
    }
    startRow <- startRow + nRowsChunk
  }
  
  output <- do.call(cbind.data.frame, output)
  
  # Adjustments for the factors
  if(nfactors > 0)
  {
    for(k in names(factors))
    {
      output[[k]] <- createFactor(output[[k]], levels(temp[[k]][1]))
    }
  }
  
  return(output)
})

#------------------------------------------------------------------------------------------------
# Write to H5 file
#------------------------------------------------------------------------------------------------

# Method: createH5DF()
h5MEMDF$methods(createH5DF = function(filePath){
  ' The createH5DF() method writes the memory matrix to file and returns a h5MAT object.
    @param filePath character denoting the path a location where the h5 file can be written.
    Usage:
    $createH5DF((chaaracter) filePath)
  '
  h5CreateFile(filePath, overwrite = 1)
  cat("Creating the meta data on the h5DF object", "\n")
  newObj <- h5DF$new()
  newObj$nChunks <- nChunks
  newObj$nrows <- nrows
  newObj$ncols <- ncols
  newObj$filePath <- filePath
  newObj$chunkSize <- chunkSize
  newObj$oldNChunks <- oldNChunks
  newObj$colNames <- colNames
  newObj$colClasses <- colClasses
  newObj$factors <- factors
  newObj$nfactors <- nfactors
  chunkNames = paste("ch", 1:nChunks, sep = "")
  newObj$chunkNames <- chunkNames
  
  cat("Writing the meta data to file", "\n")
  h5CreateMetaData(filePath)
  h5WriteInt("NRow", nrows, filePath, update = 0)
  h5WriteInt("NCol", ncols, filePath, update = 0)
  h5WriteInt("NChunks", nChunks, filePath, update = 0)
  h5WriteInt("ChunkSize", chunkSize, filePath, update = 0)
  h5WriteCharVector("ColumnNames", colNames, filePath, update = 0)
  h5WriteCharVector("ColumnClasses", colClasses, filePath, update = 0)
  h5WriteCharVector("ChunkNames", chunkNames, filePath, update = 0)
  h5WriteInt("Finalized", 0, filePath, update = 0)
  factorCols <- colNames[which(colClasses == 'factor')]
  # Now write the factors into the meta data if they are present
  if(nfactors > 0){
    for(i in factorCols)
    {
      # Writing factors to the factor group of the metadata group of the H5 file
      h5WriteFactor(i, factors[[i]], filePath, update = 0)
    }
  }
  
  cat("Writing the chunks to file", "\n")
  # Write the matrix chunks to the file
  for(i in 1:nChunks)
  {
    subDF <- readChunk(i)
    subDF <- as.list(subDF)
    subDF <- lapply(subDF, unclass)
    subDF <- do.call(cbind, subDF)
    h5WriteDoubleMat(dset = chunkNames[i], chunk = subDF, dim = dim(subDF), filePath)
  }
  cat("h5MEMDF written to file", "\n")
  return(newObj)
})

# Methods related to h5DF
#------------------------------------------------------------------------------------------------
# Method: memorize()
h5DF$methods(memorize = function(){
  ' The memorize() method takes a h5DF object and puts all DF chunks into memory 
    then returns a h5MEMDF object.
    Usage:
    $memorize()
  '
  cat("Writing all the chunks to memory", "\n")
  ptrs <- list()
  for(i in chunkNames){
    ptrs <- c(ptrs, h5WriteMemDF(readChunk(i)))
  }
  cat("Chunks written to memory", "\n")
  newObj <- h5MEMDF$new()
  newObj$ptrs <- ptrs
  newObj$nChunks <- nChunks
  newObj$chunkSize <- chunkSize
  newObj$colNames <- colNames
  newObj$colClasses <- colClasses
  newObj$nrows <- nrows
  newObj$ncols <- ncols
  newObj$nfactors <- nfactors
  newObj$factors <- factors
  newObj$oldNChunks <- 0
  return(newObj)
})

####$$$$ activeH5-master\R/h5MEMMAT.r
# h5MEMMAT Methods
#------------------------------------------------------------------------------------------------
# Helper Methods
#------------------------------------------------------------------------------------------------

# Method: createIndicies()
h5MEMMAT$methods(createIndicies = function(){
  ' The createIndicies() methods creates the indices that will be used to chunk the data
    Usage:
    $createIndicies()
  '
  nRows <- nrow(MAT)
  stubSize <- nRows %% chunkSize
  # Creating the indicies
  if(stubSize != 0)
  {
    index <- c(1, seq(stubSize, nRows, by = chunkSize) + 1)
    indicies <- list()
    for(i in 2:length(index)){
      indicies[[i-1]] <- c(index[i - 1], index[i] - 1)
    }
  }else{
    index <- seq(chunkSize, nRows, chunkSize)
    indicies <- list()
    for(i in 1:length(index))
    {
      indicies[[i]] <- c(index[i] - chunkSize + 1, index[i])
    }
  }
  return(indicies)
})

#------------------------------------------------------------------------------------------------
# Write Methods
#------------------------------------------------------------------------------------------------

# Method: createMetaData()
h5MEMMAT$methods(createMetaData = function(){
  ' The createMetaData() method is not intended for the user. It is used to create the
    meta data for a new object in the h5MEMMAT object.
    Usage:
    $createMetaData()
  '
  
  nrows <<- nrow(MAT)
  ncols <<- ncol(MAT)
  
  stub  <- nrows %% chunkSize
  if(stub == 0){
    nChunks <<- nrows %/% chunkSize
  }else{
    nChunks <<- nrows %/% chunkSize + 1
  }
  
  oldNChunks <<- 0
})

# Method: writeMatrix()
h5MEMMAT$methods(writeMatrix = function(){
  ' The method writeMatrix() is not intended for the user. It is an internal method to be used to 
    write chunks of data as matrices to the h5 object.
    Usage:
    $writeMatrix()
  '
  indicies <- createIndicies()
  cat("Writing to memory", "\n")
  for(i in 1:length(indicies)){
    ind <- indicies[[i]]
    subMAT <- MAT[seq(ind[1], ind[2]),]
    ptrs <<- c(ptrs, h5WriteMemMAT(obj = subMAT))
  }
})

# Method: createH5MEMMAT()
h5MEMMAT$methods(createH5MEMMAT = function(MAT, chunkSize, ...){
  ' The createH5MEMMAT() method populates a new h5MAT object with data defined by MAT, filePath, and chunkSize.
    Users are directed to the newH5MEMMAT() function which are more convenient.
    @param MAT matrix or character file path to CSV containing matrix to be written to H5 file object
    @param chunkSize the number of rows the defines each chunk
    @param ... arguments passed to read.csv() function
    Usage:
    $createH5MEMMAT((matrix or character) MAT, (numeric) chunkSize, ...)
  '
  cat("Initializing ...\n")
  if(class(MAT) == "character"){
    if(file.exists(MAT))
    {
      cat("Reading data from CSV file", "\n")
      mat <- read.csv(file = MAT, ...)
      MAT <<- do.call(cbind, lapply(1:ncol(mat), function(i)mat[,i]))
    }else{
      stop("MAT not recognised as text file or data frame")
    }
  }else{
    MAT <<- MAT
  }
  chunkSize <<- chunkSize
  createMetaData()
  writeMatrix()
  MAT <<- matrix(0)
})

#' @title Function for instantiating a h5MEMMAT object
#' 
#' @param MAT the matrix or path to a csv file containing a matrix to be written to a h5MEMMAT object
#' @param chunkSize the number of rows in each chunk
#' @param ... arguments passed to read.csv() file
#' @return a h5MEMMAT object
#' @examples
#' cat(getwd(), "\n")
#' n <- 1e3
#' mat <- matrix(runif(n^2), nc = n)
#' hmat <- newH5MEMMAT(mat, 10) # creating the h5MEMMAT object
#' hmat$append(mat, 10) # appending to the h5MEMMAT object
#' hmat$readChunk(2)[,1:6] # reading the second chunk
#' # Writing a h5MAT object to file
#' hmat2 <- newH5MAT(mat, "mat.h5", 10)
#' hmat2 # this is a h5MAT object
#' # Reading the matrix to memory
#' hmat3 <- hmat2$memorize()
newH5MEMMAT <- function(MAT, chunkSize, ...)
{
  obj <- h5MEMMAT$new()
  obj$createH5MEMMAT(MAT, chunkSize, ...)
  return(obj)
}

#------------------------------------------------------------------------------------------------
# Update Methods
#------------------------------------------------------------------------------------------------

# Matrix: updateMetaData()
h5MEMMAT$methods(updateMetaData = function(){
  ' The updateMetaData() method is an internal method and not intended to use by the user. It updates
    the meta data of the h5MEMMAT object on file and in R when the user appends new data.
    Usage:
    $updateMetaData()
  '
  nRows <- nrow(MAT)
  nrows <<- nrows + nRows
  oldNChunks <<- nChunks
  # Updating nChunks
  stub  <- nRows %% chunkSize
  if(stub == 0){
    nchunks <- nRows %/% chunkSize
  }else{
    nchunks <- nRows %/% chunkSize + 1
  }
  nChunks <<- oldNChunks + nchunks
  newChunkNames <- paste("ch", (oldNChunks + 1):nChunks, sep = "")
})

# Method: append()
h5MEMMAT$methods(append = function(MAT, ...){
  ' The append() method allows new data to be appended to a h5MEMMAT object.
    @param MAT the matrix to be appended. Either a matrix or a character denoting a csv file
          containing the matrix to be appended.
    @param ... parameters passed to read.csv() function
    Usage:
    $append((matrix or character) MAT, (passed to read.csv()) ...)
  '
  if(class(MAT) == "character"){
    if(file.exists(MAT))
    {
      cat("Reading data from CSV file", "\n")
      mat <- read.csv(file = MAT, ...)
      MAT <<- do.call(cbind, lapply(1:ncol(mat), function(i)mat[,i]))
    }else{
      stop("MAT not recognised as text file or data frame")
    }
  }else{
    MAT <<- MAT
  }
  updateMetaData()
  writeMatrix()
  oldNChunks <<- 0
  MAT <<- matrix(0)
})

#------------------------------------------------------------------------------------------------
# Read Methods
#------------------------------------------------------------------------------------------------

# Method: readChunk()
h5MEMMAT$methods(readChunk = function(chunkNum){
  ' The readChunk() method reads a chunk from the h5MEMMAT object into R as a matrix
    @param chunkNum the number of the chunk to be read into R.
    Usage:
    $readChunk((numeric) chunkNum)
  '
  return(h5ReadMemMAT(ptrs[[chunkNum]]))
})

# Method: readChunks()
h5MEMMAT$methods(readChunks = function(chunkNums){
  ' The readChunks() methods reads chunks defined by a numeric vector into R
    @param chunkNums a numeric vector of chunks to be read into R.
    Usage:
    $readChunks((numeric) chunkNums)
  '
  return(do.call(rbind, lapply(ptrs[chunkNums], h5ReadMemMAT)))
})

# Method: readTable()
h5MEMMAT$methods(readTable = function(){
  ' The readTable() method reads all the chunks in the h5MEMMAT object and returns them as a single matrix.
    Usage:
    $readTable()
  '
  return(do.call(rbind, lapply(ptrs, h5ReadMemMAT)))
})

#------------------------------------------------------------------------------------------------
# Write to H5 file
#------------------------------------------------------------------------------------------------

# Method: createH5MAT()
h5MEMMAT$methods(createH5MAT = function(filePath){
  ' The createH5MAT() method writes the memory matrix to file and returns a h5MAT object
    @param filePath character for the path to the file where the h5 object will be written
    Usage:
    $createH5MAT((character) filePath)
  '
  h5CreateFile(filePath, overwrite = 1)
  cat("Creating the meta data on the h5MAT object", "\n")
  newObj <- h5MAT$new()
  newObj$nChunks <- nChunks
  newObj$nrows <- nrows
  newObj$ncols <- ncols
  newObj$filePath <- filePath
  newObj$chunkSize <- chunkSize
  newObj$oldNChunks <- oldNChunks
  
  chunkNames = paste("ch", 1:nChunks, sep = "")
  newObj$chunkNames <- chunkNames
  
  cat("Writing the meta data to file", "\n")
  # Creating the meta data on the file
  # Initialize the structure for the meta data group
  h5CreateMetaData(filePath)
  h5WriteInt("NRow", nrows, filePath, update = 0)
  h5WriteInt("NCol", ncols, filePath, update = 0)
  h5WriteInt("NChunks", nChunks, filePath, update = 0)
  h5WriteInt("ChunkSize", chunkSize, filePath, update = 0)
  h5WriteInt("Finalized", 0, filePath, update = 0)
  h5WriteCharVector("ChunkNames", chunkNames, filePath, update = 0)
  
  cat("Writing the matrix chunks to file", "\n")
  # Write the matrix chunks to the file
  for(i in 1:nChunks)
  {
    subMatrix <- readChunk(i)
    h5WriteDoubleMat(dset = chunkNames[i], chunk = subMatrix, dim = dim(subMatrix), filePath)
  }
  cat("h5MEMMAT written to file", "\n")
  return(newObj)
})

#------------------------------------------------------------------------------------------------
# Methods related to h5MAT
#------------------------------------------------------------------------------------------------

# Method: memorize()
h5MAT$methods(memorize = function(){
  ' The memorize() method writes a h5MAT object to memory and returns a h5MEMMAT object
    Usage:
    $memorize()
  '
  cat("Writing all the chunks to memory", "\n")
  ptrs <- list()
  for(i in chunkNames){
    ptrs <- c(ptrs, h5WriteMemMAT(readChunk(i)))
  }
  cat("Chunks written to memory", "\n")
  newObj <- h5MEMMAT$new()
  newObj$ptrs <- ptrs
  newObj$nChunks <- nChunks
  newObj$chunkSize <- chunkSize
  newObj$nrows <- nrows
  newObj$ncols <- ncols
  newObj$oldNChunks <- 0
  return(newObj)
})

####$$$$ activeH5-master\R/RcppExports.R
# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'@title Function to create a factor
#'
#'@description Function creates a factor when supplied with a numeric vector and character vector for levels
#'
#'@param x a numeric vector that denotes the indexes of the factor
#'@param levels character vector for the unique levels of the factor
#'@return a factor
#'@examples
#'createFactor(sample(1:3, 10, TRUE), LETTERS[1:3])
createFactor <- function(x, levels) {
    .Call('activeH5_createFactor', PACKAGE = 'activeH5', x, levels)
}

#'@title Function to create file a h5 file
#'
#'@description Function to create a h5 file. It is intended for internal use only
#'
#'@param filePath a character denoting the path to the location where the h5 file will be written
#'@param overwrite integer 1 for overwrite and 0 for not overwrite. Will fail if overwrite is 0
#'@return int 0
h5CreateFile <- function(filePath, overwrite) {
    .Call('activeH5_h5CreateFile', PACKAGE = 'activeH5', filePath, overwrite)
}

#'@title Function creates the groups for the meta data to be written to the h5 file
#'
#'@description Function to create the groups in the h5 file before it is populated.
#'This function is intended for internal use only
#'
#'@param filePath character path to the location where the h5 file will be written
#'@return int 0
h5CreateMetaData <- function(filePath) {
    .Call('activeH5_h5CreateMetaData', PACKAGE = 'activeH5', filePath)
}

#'@title This function writes a character vector to the meta data
#'
#'@description This function writes a character vector to the meta data and is intended for internal use.
#'
#'@param charName the name that will be given to the meta data character vector
#'@param charVec the character vector to be written as meta data
#'@param filePath the path to the h5 file where the data will be written
#'@param update integer denoting whether the data item is new or whether it is an update 
#'(which will overwrite any previous item)
#'@return int 0
h5WriteCharVector <- function(charName, charVec, filePath, update) {
    .Call('activeH5_h5WriteCharVector', PACKAGE = 'activeH5', charName, charVec, filePath, update)
}

#'@title This function writes an integer meta data to file
#'
#'@description This function is inteded for internal use
#'
#'@param intName the name of the meta data item to be written
#'@param integer int that will be written to the meta data described by intName
#'@param filePath character path to the h5 file where data will be written
#'@param update int flag for whether item is new (0) or whether it will overwrite a previous item (1)
#'@return int 0
h5WriteInt <- function(intName, integer, filePath, update) {
    .Call('activeH5_h5WriteInt', PACKAGE = 'activeH5', intName, integer, filePath, update)
}

#'@title Function to write the levels of a factor variable to meta data
#'
#'@description Function is intended for internal use
#'
#'@param charName character denoting the meta data name of the factor to be written
#'@param charVec characer denoting the factor levels to be written
#'@param filePath character denoting the location of the h5 file
#'@param update int flag for whether item is new (0) or whether it will overwrite a previous item (1)
#'@return int 0
h5WriteFactor <- function(charName, charVec, filePath, update) {
    .Call('activeH5_h5WriteFactor', PACKAGE = 'activeH5', charName, charVec, filePath, update)
}

#'@title Function to write a matrix chunk to file
#'
#'@description Function is intended for internal use
#'
#'@param dset character denoting the meta data name of the data set
#'@param chunk matrix that will be written to h5file
#'@param dim numeric containing the dimension of the matrix that will be written to file
#'@param filePath character denoting the location of the h5 file
#'@return int 0
h5WriteDoubleMat <- function(dset, chunk, dim, filePath) {
    .Call('activeH5_h5WriteDoubleMat', PACKAGE = 'activeH5', dset, chunk, dim, filePath)
}

#'@title Function to finalize h5 file contents allowing them to be read by another user
#'
#'@description The same as the h5CloseFile() function
#'
#'@param filePath character path to the file which will be flushed
#'@return int 0
h5FlushFile <- function(filePath) {
    .Call('activeH5_h5FlushFile', PACKAGE = 'activeH5', filePath)
}

#'@title Function to close the h5 file
#'
#'@description Closes the h5 file
#'
#'@param filePath character path to the file which will be flushed
#'@return int 0
h5CloseFile <- function(filePath) {
    .Call('activeH5_h5CloseFile', PACKAGE = 'activeH5', filePath)
}

#'@title Function to read a character vector from meta data
#'
#'@param charName character the name of the meta data item to be read back from file
#'@param filePath character for the path to the file where the item will be read
#'@return character containing the character vector that has been read from meta data
h5ReadCharVector <- function(charName, filePath) {
    .Call('activeH5_h5ReadCharVector', PACKAGE = 'activeH5', charName, filePath)
}

#'@title Function to read factor levels from meta data for a pgiven factor
#'
#'@param charName character denoting the factor from the meta data factor
#'@param filePath character denoting the path to the h5 file
#'@return character of factor levels
h5ReadFactor <- function(charName, filePath) {
    .Call('activeH5_h5ReadFactor', PACKAGE = 'activeH5', charName, filePath)
}

#'@title Function to read an integer item from meta data
#'
#'@param intName character for the name of the item to be read back
#'@param filePath character for the path to the h5 file
#'@return int iteger item defined by intName in the meta data
h5ReadInt <- function(intName, filePath) {
    .Call('activeH5_h5ReadInt', PACKAGE = 'activeH5', intName, filePath)
}

#'@title Function to read a matrix chunk from a h5 file
#' 
#'@param chunkName the name of the chunk to be read back
#'@param filePath the path to the h5 file
#'@return matrix chunk defined by chunkName
h5ReadDoubleMat <- function(chunkName, filePath) {
    .Call('activeH5_h5ReadDoubleMat', PACKAGE = 'activeH5', chunkName, filePath)
}

#'@title Function for dummy read
#' 
#'@param chunkName the name of the chunk to be read back
#'@param filePath the path to the h5 file
#'@return int 0
h5DummyRead <- function(chunkName, filePath) {
    .Call('activeH5_h5DummyRead', PACKAGE = 'activeH5', chunkName, filePath)
}

#' @title Fast model frame for activeReg
#' 
#' @description Function returns a scaled down model frame essentially returning list with no NA values.
#' Each item in the list represents a column in the data frame.
#' 
#' @param chunkName character name of the chunk to be read
#' @param selCols character vector of columns to select
#' @param filePath character path to file where chunk is to be read from
#' @return list representing a data frame with no NA values.
h5ModelFrame <- function(chunkName, selCols_, filePath) {
    .Call('activeH5_h5ModelFrame', PACKAGE = 'activeH5', chunkName, selCols_, filePath)
}

#'@title Function returns a data frame chunk as a list object to R where the final cbind will take place 
#'
#'@param chunkName the name of the chunk to be read
#'@param filePath the path to the h5 file
#'@return List representing chunk data frame
h5ChunkList <- function(chunkName, filePath) {
    .Call('activeH5_h5ChunkList', PACKAGE = 'activeH5', chunkName, filePath)
}

#'@title Function returns a column subset of data frame chunk as a list
#'
#'@param chunkName the name of the chunk to be read
#'@param selCols the columns that will be selected
#'@param filePath the path to the h5 file
#'@return List representing chunk data frame
h5ChunkSel <- function(chunkName, selCols, filePath) {
    .Call('activeH5_h5ChunkSel', PACKAGE = 'activeH5', chunkName, selCols, filePath)
}

#'@title Legacy function to return a data frame chunk as a list
#'
#'@description Experimental function not intended for use at all
#'
#'@param chunkName the name of the chunk to be read
#'@param filePath the path to the h5 file
#'@return List of the data frame chunk
h5ReadDoubleMat2 <- function(chunkName, filePath) {
    .Call('activeH5_h5ReadDoubleMat2', PACKAGE = 'activeH5', chunkName, filePath)
}

#'@title Legacy function to return a data frame chunk as a list
#'
#'@description Experimental function not intended for use at all
#'
#'@param chunkName the name of the chunk to be read
#'@param filePath the path to the h5 file
#'@return List of the data frame chunk
h5ReadDoubleMat3 <- function(chunkName, filePath) {
    .Call('activeH5_h5ReadDoubleMat3', PACKAGE = 'activeH5', chunkName, filePath)
}

#'@title Function to write a matrix to memory and return a pointer
#'
#'@description Intended for internal use only
#'
#'@param obj matrix to be written to memory
#'@return externalptr 
h5WriteMemMAT <- function(obj) {
    .Call('activeH5_h5WriteMemMAT', PACKAGE = 'activeH5', obj)
}

#'@title Function to write a data frame object to memory and return a pointer
#'
#'@description Intended for internal use only
#'
#'@param obj data frame to be written to memory
#'@return externalptr 
h5WriteMemDF <- function(obj) {
    .Call('activeH5_h5WriteMemDF', PACKAGE = 'activeH5', obj)
}

#'@title Function to read a matrix from memory when given the external pointer
#'
#'@description Intended for internal use only
#'
#'@param ptr an externalptr to the matrix object to be retrieved
#'@return matrix that is held at the externalptr
h5ReadMemMAT <- function(ptr) {
    .Call('activeH5_h5ReadMemMAT', PACKAGE = 'activeH5', ptr)
}

#'@title Function to read a data frame that has been stored in memory when given the external pointer
#'
#'@param ptr externalptr to data frame stored in memory
#'@return the data frame that is held at the externalptr
h5ReadMemDF <- function(ptr) {
    .Call('activeH5_h5ReadMemDF', PACKAGE = 'activeH5', ptr)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('activeH5_RcppExport_registerCCallable', PACKAGE = 'activeH5')
})
####$$$$ activeH5-master\src/activeH5.cpp
/*
  Date: 2014-01-15
  Author: Chibisi Chima-Okereke
  Purpose: C++ backend to HDF5 functionality for h5DF reference class object
*/
// [[Rcpp::interfaces(r, cpp)]]
#include <Rcpp.h>
#include <iostream>
#include <string>
#include <vector>
#include <H5Cpp.h>
#include <stdlib.h>
#include <fstream>

using namespace Rcpp;
using namespace H5;
using namespace std;


/* This is a worker function to convert SEXP character to a H5std_string */

/* For an SEXP CharacterVector of length 1 */
char* convertChar(SEXP Char)
{
  char *stdString = (char*)CHAR(STRING_ELT(Char, 0));
  //H5std_string StdString(stdString);
  return stdString;
}

/* Overload for an SEXP CharacterVector of any length */
char** convertCharArray(SEXP charVec)
{
  int len = Rf_length(charVec);
  
  // This is the char array
  char** arr = NULL;
  
  // Filling the char* array
  arr = (char**) calloc(len, sizeof(char*));
  for (int i = 0; i < len; i++)
    arr[i] = (char*) CHAR(STRING_ELT(charVec, i));
    
  return arr;
}

/* Check that file exists */
int fileExists(string filePath)
{
  ifstream file(filePath.c_str());
  if(file)
  {
    return 1;
  }
  return 0;
}

IntegerVector cCreateFactor(NumericVector x, CharacterVector levels)
{
  IntegerVector y = (IntegerVector)x;
  y.attr("levels") = levels;
  y.attr("class") = "factor";
  return y;
}

//'@title Function to create a factor
//'
//'@description Function creates a factor when supplied with a numeric vector and character vector for levels
//'
//'@param x a numeric vector that denotes the indexes of the factor
//'@param levels character vector for the unique levels of the factor
//'@return a factor
//'@examples
//'createFactor(sample(1:3, 10, TRUE), LETTERS[1:3])
// [[Rcpp::export]]
SEXP createFactor(NumericVector x, CharacterVector levels)
{
  return wrap(cCreateFactor(x, levels));
}


// Writing to file
/*--------------------------------------------------------------------------------------------------*/

//'@title Function to create file a h5 file
//'
//'@description Function to create a h5 file. It is intended for internal use only
//'
//'@param filePath a character denoting the path to the location where the h5 file will be written
//'@param overwrite integer 1 for overwrite and 0 for not overwrite. Will fail if overwrite is 0
//'@return int 0
// [[Rcpp::export]]
int h5CreateFile(std::string filePath, int overwrite)
{
  H5File* file;
  
  if(fileExists(filePath))
  {
    if(overwrite)
    {
      file = new H5File(filePath, H5F_ACC_TRUNC);
    }else{
      throw "Error: file exists and overwrite is set to 0.";
    }
  }else{
    file = new H5File(filePath, H5F_ACC_TRUNC);
  }
  file->close();
  return 0;
}

//'@title Function creates the groups for the meta data to be written to the h5 file
//'
//'@description Function to create the groups in the h5 file before it is populated.
//'This function is intended for internal use only
//'
//'@param filePath character path to the location where the h5 file will be written
//'@return int 0
// [[Rcpp::export]]
int h5CreateMetaData(std::string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  
  hsize_t dims[1] = {1};  
  // The variable length string type
  StrType vlst(0, H5T_VARIABLE);
  
  // Creating the meta data group
  Group *metaGroup = new Group(file->createGroup("/MetaData"));
  
  // File path
  H5std_string fString("FilePath");
  DataSpace fileDataSpace (1, dims, NULL);
  
  DataSet fileDataSet;
  
  // Create a dataset in the group
  fileDataSet = metaGroup->createDataSet(fString, vlst, fileDataSpace);
  fileDataSet.write(filePath, vlst);
  
  // Create the factor group
  Group *factorGroup = new Group(metaGroup->createGroup("/MetaData/Factor"));
  fileDataSet.close(); //nn
  factorGroup->close();
  metaGroup->close();
  file->close();
  return 0;
}

//'@title This function writes a character vector to the meta data
//'
//'@description This function writes a character vector to the meta data and is intended for internal use.
//'
//'@param charName the name that will be given to the meta data character vector
//'@param charVec the character vector to be written as meta data
//'@param filePath the path to the h5 file where the data will be written
//'@param update integer denoting whether the data item is new or whether it is an update 
//'(which will overwrite any previous item)
//'@return int 0
// [[Rcpp::export]]
int h5WriteCharVector(std::string charName, SEXP charVec, std::string filePath, int update)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  
  int len = Rf_length(charVec);
  hsize_t DIM1 = len;
  int rank = 1;
  //cout << "The length is ... " << len << endl;
  // Create a datatype to refer to
  StrType vlst(0, H5T_VARIABLE);
  
  // This is the char array
  char** arr = convertCharArray(charVec);
  
  string meta = "/MetaData";
  
  // Group Meta Group
  Group* metaGroup = new Group(file->openGroup(meta));
  
  // The dataset and dataspace
  hsize_t dims[] = {DIM1};
  //hsize_t maxdims[] = {H5S_UNLIMITED};
  DataSet dataset;
  if(update == 1)
  {
    string slash = "/";
    string groupName = meta + slash + charName;
    file->unlink(groupName); 
  }
  
  DataSpace dataspace(rank, dims);
  dataset = metaGroup->createDataSet(charName, vlst, dataspace);
  dataset.write(arr, vlst);
  dataset.close(); //nn
  metaGroup->close();
  file->close();
  return 0;
}

//'@title This function writes an integer meta data to file
//'
//'@description This function is inteded for internal use
//'
//'@param intName the name of the meta data item to be written
//'@param integer int that will be written to the meta data described by intName
//'@param filePath character path to the h5 file where data will be written
//'@param update int flag for whether item is new (0) or whether it will overwrite a previous item (1)
//'@return int 0
// [[Rcpp::export]]
int h5WriteInt(std::string intName, int integer, std::string filePath, int update)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  
  // Colclasses dim
  hsize_t dim[1] = {1};
  
  string meta = "/MetaData";
  // Group Meta Group
  Group* metaGroup = new Group(file->openGroup(meta));
  
  // dataspace
  DataSpace dataspace = DataSpace(1, dim);
  DataSet dataset;
  if(update == 1)
  {
    string slash = "/";
    string groupName = meta + slash + intName;
    file->unlink(groupName);
  }
  dataset = metaGroup->createDataSet(intName, PredType::NATIVE_INT, dataspace);
  dataset.write(&integer, PredType::NATIVE_INT);
  dataset.close(); //nn
  metaGroup->close();
  file->close();
  return 0;
}

//'@title Function to write the levels of a factor variable to meta data
//'
//'@description Function is intended for internal use
//'
//'@param charName character denoting the meta data name of the factor to be written
//'@param charVec characer denoting the factor levels to be written
//'@param filePath character denoting the location of the h5 file
//'@param update int flag for whether item is new (0) or whether it will overwrite a previous item (1)
//'@return int 0
// [[Rcpp::export]]
int h5WriteFactor(std::string charName, SEXP charVec, std::string filePath, int update)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  
  int len = Rf_length(charVec);
  hsize_t DIM1 = len;
  int rank = 1;
  
  // Create a datatype to refer to
  StrType vlst(0, H5T_VARIABLE);
  
  // This is the char array
  char** arr = convertCharArray(charVec);
  
  string meta = "/MetaData/Factor";
  
  // Group Meta Group
  Group* metaGroup = new Group(file->openGroup(meta));
  
  // The dataset and dataspace
  hsize_t dims[] = {DIM1};
  DataSpace dataspace(rank, dims);
  DataSet dataset;
  if(update == 1)
  {
    string slash = "/";
    string groupName = meta + slash + charName;
    file->unlink(groupName);
  }
  dataset = metaGroup->createDataSet(charName, vlst, dataspace);
  dataset.write(arr, vlst);
  dataset.close(); //nn
  metaGroup->close();
  file->close();
  return 0;
}

//'@title Function to write a matrix chunk to file
//'
//'@description Function is intended for internal use
//'
//'@param dset character denoting the meta data name of the data set
//'@param chunk matrix that will be written to h5file
//'@param dim numeric containing the dimension of the matrix that will be written to file
//'@param filePath character denoting the location of the h5 file
//'@return int 0
// [[Rcpp::export]]
int h5WriteDoubleMat (std::string dset, SEXP chunk, NumericVector dim, std::string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  
  // Data initialization.
  int rank = 2;
  hsize_t dims[rank];              // dataset dimensions
  for(int k = 0; k < rank; k++)
    dims[k] = dim(k);
  const void *buf = REAL(chunk);
  
  // Create the data space for the dataset.
  DataSpace dataspace (rank, dims, NULL);
  
  // Create the dataset.
  H5std_string dsetName(dset);
  DataSet dataset = file->createDataSet(dsetName, PredType::NATIVE_DOUBLE, dataspace);

  // Write the data to the dataset using default memory space, file
  // space, and transfer properties.
  dataset.write(buf, PredType::NATIVE_DOUBLE);
  dataset.close(); //nn
  file->close();
  return 0;
}

//'@title Function to finalize h5 file contents allowing them to be read by another user
//'
//'@description The same as the h5CloseFile() function
//'
//'@param filePath character path to the file which will be flushed
//'@return int 0
// [[Rcpp::export]]
int h5FlushFile(std::string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  file->close();
  return 0;
}

//'@title Function to close the h5 file
//'
//'@description Closes the h5 file
//'
//'@param filePath character path to the file which will be flushed
//'@return int 0
// [[Rcpp::export]]
int h5CloseFile(std::string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDWR);
  file->close();
  return 0;
}

// Reading from file
/*--------------------------------------------------------------------------------------------------*/

CharacterVector ch5ReadCharVector(std::string charName, std::string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  
  // Group Meta Group
  Group* metaGroup = new Group(file->openGroup("/MetaData"));
  
  // Getting the data set from the file - we cast in place here
  DataSet dataset = metaGroup->openDataSet((H5std_string)charName);
  // Getting the data space from the dataset
  DataSpace dataspace = dataset.getSpace();
  // We know that it is a char vector array so ndim = 1
  hsize_t dims[1];
  // Getting the length of strings
  dataspace.getSimpleExtentDims(dims, NULL);
  
  // for convenience
  int dim = dims[0];
  // String Type
  StrType vlst(0, H5T_VARIABLE);
  // Returning  the data
  char *strRet[dim];
  dataset.read(strRet, vlst);
  // Creating the return data
  CharacterVector out(dim);
  for(int i = 0; i < dim; i++)
  {
    out[i] = strRet[i];
  }
  dataset.close(); //nn
  metaGroup->close();
  file->close();
  return out;
}

//'@title Function to read a character vector from meta data
//'
//'@param charName character the name of the meta data item to be read back from file
//'@param filePath character for the path to the file where the item will be read
//'@return character containing the character vector that has been read from meta data
// [[Rcpp::export]]
SEXP h5ReadCharVector(std::string charName, std::string filePath)
{
  return wrap(ch5ReadCharVector(charName, filePath));
}


CharacterVector ch5ReadFactor(string charName, string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  
  // Group Meta Group
  Group* metaGroup = new Group(file->openGroup("/MetaData/Factor"));
  
  // Getting the data set from the file 
  DataSet dataset = metaGroup->openDataSet((H5std_string)charName);
  // Getting the data space from the dataset
  DataSpace dataspace = dataset.getSpace();
  // We know that it is a char vector array so ndim = 1
  hsize_t dims[1];
  // Getting the length of strings
  dataspace.getSimpleExtentDims(dims, NULL);
  
  // for convenience
  int dim = dims[0];
  // String Type
  StrType vlst(0, H5T_VARIABLE);
  // Returning  the data
  char *strRet[dim];
  dataset.read(strRet, vlst);
  CharacterVector out(dim);
  for(int i = 0; i < dim; i++)
  {
    out[i] = strRet[i];
  }
  dataset.close(); //nn
  metaGroup->close();
  file->close();
  return out;
}

//'@title Function to read factor levels from meta data for a pgiven factor
//'
//'@param charName character denoting the factor from the meta data factor
//'@param filePath character denoting the path to the h5 file
//'@return character of factor levels
// [[Rcpp::export]]
SEXP h5ReadFactor(std::string charName, std::string filePath)
{
  return wrap(ch5ReadFactor(charName, filePath));
}

//'@title Function to read an integer item from meta data
//'
//'@param intName character for the name of the item to be read back
//'@param filePath character for the path to the h5 file
//'@return int iteger item defined by intName in the meta data
// [[Rcpp::export]]
int h5ReadInt(std::string intName, std::string filePath)
{
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  
  // Group Meta Group
  Group* metaGroup = new Group(file->openGroup("/MetaData"));
  
  // Getting the data set from the file 
  DataSet dataset = metaGroup->openDataSet((H5std_string)intName);
  // Getting the data space from the dataset
  DataSpace dataspace = dataset.getSpace();
  
  // Returning  the data
  int intRet;
  dataset.read(&intRet, PredType::NATIVE_INT);
  
  dataset.close(); //nn
  metaGroup->close();
  file->close();
  return intRet;
}


//'@title Function to read a matrix chunk from a h5 file
//' 
//'@param chunkName the name of the chunk to be read back
//'@param filePath the path to the h5 file
//'@return matrix chunk defined by chunkName
// [[Rcpp::export]]
SEXP h5ReadDoubleMat(std::string chunkName, std::string filePath)
{ 
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  SEXP data;
  // Allocating a matrix of the right size and dimension
  data = PROTECT(Rf_allocMatrix(REALSXP, dims[0], dims[1]));
  // Filling the matrix with data form the dataspace
  dataset.read(REAL(data), PredType::NATIVE_DOUBLE, dataspace);
  UNPROTECT(1);
  
  dataset.close(); //nn
  file->close();
  
  return data;
}

//'@title Function for dummy read
//' 
//'@param chunkName the name of the chunk to be read back
//'@param filePath the path to the h5 file
//'@return int 0
// [[Rcpp::export]]
int h5DummyRead(std::string chunkName, std::string filePath)
{ 
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  SEXP data;
  // Allocating a matrix of the right size and dimension
  data = PROTECT(Rf_allocMatrix(REALSXP, dims[0], dims[1]));
  // Filling the matrix with data form the dataspace
  dataset.read(REAL(data), PredType::NATIVE_DOUBLE, dataspace);
  UNPROTECT(1);
  
  dataset.close();
  file->close();
  
  return 0;
}



/*--------------------------------------------------------------------------------------------------*/

//' @title Fast model frame for activeReg
//' 
//' @description Function returns a scaled down model frame essentially returning list with no NA values.
//' Each item in the list represents a column in the data frame.
//' 
//' @param chunkName character name of the chunk to be read
//' @param selCols character vector of columns to select
//' @param filePath character path to file where chunk is to be read from
//' @return list representing a data frame with no NA values.
//[[Rcpp::export]]
SEXP h5ModelFrame(std::string chunkName, SEXP selCols_, std::string filePath)
{ 
  // Quick conversion of the SEXP column selection to character vector
  CharacterVector selCols(selCols_);
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  // Filling the matrix with data form the dataspace
  SEXP data;
  // Allocating a matrix of the right size and dimension
  data = PROTECT(Rf_allocMatrix(REALSXP, dims[0], dims[1]));
  // Filling the matrix with data form the dataspace
  dataset.read(REAL(data), PredType::NATIVE_DOUBLE, dataspace);
  UNPROTECT(1);
  // Convert the R object to a numeric matrix
  NumericMatrix M__(data);
  CharacterVector colNames = ch5ReadCharVector("ColumnNames", filePath);
  CharacterVector colClasses = ch5ReadCharVector("ColumnClasses", filePath);
  // Create the output
  List DF;
  string colName;
  string colClass;
  NumericVector vect;
  CharacterVector levels;
  int n = selCols.size();
  IntegerVector sel(n);
  int selN;
  NumericMatrix M_(M__.nrow(), n);
  // Find which of the columns has been selected
  sel = match(selCols, colNames);
  // Copy the correct matrix columns
  for(int i = 0; i < n; i++)
  {
    selN = sel[i] - 1;
    M_(_, i) = M__(_, selN);
  }
  // Number of rows in the matrix
  int nr = M_.nrow();
  int goodRow;
  NumericVector goodRows(nr);
  int badRow;
  for(int i = 0; i < nr; i++)
  {
    badRow = sum(is_na(M_(i, _)));
    if(badRow >= 1)
    {
      goodRows[i] = 0;
    }else{
      goodRows[i] = 1;
    }
  }
  //goodRows = goodRows*-1 + 1;
  NumericMatrix M(sum(goodRows), n);
  int j = 0;
  // Remove NA rows
  for(int i = 0; i < nr; i++)
  {
    goodRow = goodRows[i];
    if(goodRow == 1)
    {
      M(j, _) = M_(i, _);
      j++;
    }
  }
  // Compile the list
  for(int i = 0; i < n; i++)
  {
    colName = selCols[i];
    selN = sel[i] - 1;
    colClass = colClasses[selN];
    if(colClass != "factor")
    {
      DF[colName] = M(_, i); 
    }else{
      vect = M(_, i);
      levels = (CharacterVector)ch5ReadFactor(colName, filePath);
      DF[colName] = cCreateFactor(vect, levels);
    }
    
  }
  dataset.close();
  file->close();
  
  return wrap(DF);
}


// 2014-01-29 New Read DF methods
// Function to return data frame chunk as list
List ch5ChunkList(string chunkName, string filePath)
{ 
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  // Filling the matrix with data form the dataspace
  SEXP data;
  // Allocating a matrix of the right size and dimension
  data = PROTECT(Rf_allocMatrix(REALSXP, dims[0], dims[1]));
  // Filling the matrix with data form the dataspace
  dataset.read(REAL(data), PredType::NATIVE_DOUBLE, dataspace);
  UNPROTECT(1);
  // converting the R object to a numeric matrix
  NumericMatrix M = as<NumericMatrix>(data);
  CharacterVector colNames = ch5ReadCharVector("ColumnNames", filePath);
  CharacterVector colClasses = ch5ReadCharVector("ColumnClasses", filePath);
  
  // Create the output
  List DF;
  string colName;
  string colClass;
  NumericVector vec;
  CharacterVector levels;
  for(int i = 0; i < dims[1]; i++)
  {
    colName = colNames[i];
    colClass = colClasses[i];
    if(colClass != "factor")
    {
      DF[colName] = M(_, i); 
    }else{
      vec = M(_, i);
      levels = (CharacterVector)ch5ReadFactor(colName, filePath);
      DF[colName] = cCreateFactor(vec, levels);
    }
    
  }
  
  dataset.close();
  file->close();
  
  return DF;
}

//'@title Function returns a data frame chunk as a list object to R where the final cbind will take place 
//'
//'@param chunkName the name of the chunk to be read
//'@param filePath the path to the h5 file
//'@return List representing chunk data frame
// [[Rcpp::export]]
SEXP h5ChunkList(std::string chunkName, std::string filePath)
{
  return wrap(ch5ChunkList(chunkName, filePath));
}


// Function to return a selected part of a data frame as a list
List ch5ChunkSel(string chunkName, CharacterVector selCols, string filePath)
{ 
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  // Filling the matrix with data form the dataspace
  SEXP data;
  // Allocating a matrix of the right size and dimension
  data = PROTECT(Rf_allocMatrix(REALSXP, dims[0], dims[1]));
  // Filling the matrix with data form the dataspace
  dataset.read(REAL(data), PredType::NATIVE_DOUBLE, dataspace);
  UNPROTECT(1);
  // converting the R object to a numeric matrix
  NumericMatrix M = as<NumericMatrix>(data);
  CharacterVector colNames = ch5ReadCharVector("ColumnNames", filePath);
  CharacterVector colClasses = ch5ReadCharVector("ColumnClasses", filePath);
  
  // Create the output
  List DF;
  string colName;
  string colClass;
  NumericVector vec;
  CharacterVector levels;
  int n = selCols.size();
  IntegerVector sel(n);
  int selN;
  // First we need to find which of the columns has been selected
  sel = match(selCols, colNames);
  
  for(int i = 0; i < n; i++)
  {
    colName = selCols[i];
    selN = sel[i] - 1;
    colClass = colClasses[selN];
    if(colClass != "factor")
    {
      DF[colName] = M(_, selN); 
    }else{
      vec = M(_, selN);
      levels = (CharacterVector)ch5ReadFactor(colName, filePath);
      DF[colName] = cCreateFactor(vec, levels);
    }
    
  }
  
  dataset.close();
  file->close();
  
  return DF;
}

//'@title Function returns a column subset of data frame chunk as a list
//'
//'@param chunkName the name of the chunk to be read
//'@param selCols the columns that will be selected
//'@param filePath the path to the h5 file
//'@return List representing chunk data frame
// [[Rcpp::export]]
SEXP h5ChunkSel(std::string chunkName, SEXP selCols, std::string filePath)
{
  CharacterVector SelCols = as<CharacterVector>(selCols);
  return wrap(ch5ChunkSel(chunkName, SelCols, filePath));
}


/*--------------------------------------------------------------------------------------------------*/

//'@title Legacy function to return a data frame chunk as a list
//'
//'@description Experimental function not intended for use at all
//'
//'@param chunkName the name of the chunk to be read
//'@param filePath the path to the h5 file
//'@return List of the data frame chunk
// [[Rcpp::export]]
SEXP h5ReadDoubleMat2(std::string chunkName, std::string filePath)
{ 
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  // Filling the matrix with data form the dataspace
  SEXP data;
  // Allocating a matrix of the right size and dimension
  data = PROTECT(Rf_allocMatrix(REALSXP, dims[0], dims[1]));
  // Filling the matrix with data form the dataspace
  dataset.read(REAL(data), PredType::NATIVE_DOUBLE, dataspace);
  UNPROTECT(1);
  // converting the R object to a numeric matrix
  NumericMatrix M = as<NumericMatrix>(data);
  List out;
  NumericVector vec(dims[0]);
  CharacterVector colNames = ch5ReadCharVector("ColumnNames", filePath);
  CharacterVector colClasses = ch5ReadCharVector("ColumnClasses", filePath);
  string colName;
  for(int i = 0; i < dims[1]; i++)
  {
    NumericVector vec(dims[0]);
    for(int j = 0; j < dims[0]; j++)
    {
      vec(j) = M(j,i);
    }
    colName = colNames[i];
    if(colClasses[i] == "factor")
    {
      CharacterVector levels;
      levels = ch5ReadFactor(colName, filePath);
      IntegerVector fact(vec.size());
      fact = cCreateFactor(vec, levels);
      out[colName] = fact;
    }else{
      out[colName] = vec;
    }
    
  }
  dataset.close(); //nn
  file->close();
  // Returning the data
  return wrap(out);
}

//'@title Legacy function to return a data frame chunk as a list
//'
//'@description Experimental function not intended for use at all
//'
//'@param chunkName the name of the chunk to be read
//'@param filePath the path to the h5 file
//'@return List of the data frame chunk
// [[Rcpp::export]]
SEXP h5ReadDoubleMat3(std::string chunkName, std::string filePath)
{ 
  // Open the file in Read/Write Mode, H5F_ACC_RDONLY
  H5File *file = new H5File(filePath, H5F_ACC_RDONLY);
  // Opening the data set 
  DataSet dataset = file->openDataSet((H5std_string)chunkName);
  // Opening the data space
  DataSpace dataspace = dataset.getSpace();
  // Get the number of dimensions
  int ndim = dataspace.getSimpleExtentNdims();
  // Create a dimension object to be filled with the dimensions of the data set
  hsize_t dims[ndim];
  // Fill the dimension of the dataset
  dataspace.getSimpleExtentDims(dims, NULL);
  // Create the return data
  // Filling the matrix with data form the dataspace
  //double (*buf)[dims[1]]*[dims[0]] = malloc(dims[1]]*[dims[0] * sizeof *buf);
  //buf[dims[1]][dims[0]] = 0.0;
  double **buf = (double**) calloc (dims[1]*dims[0], sizeof(double));
  buf[dims[1]][dims[0]] = 0.0;
  //double buf[dims[1]][dims[0]];
  dataset.read(buf, PredType::NATIVE_DOUBLE, dataspace);
  // Attempt tp append the contents to a list
  List out;
  NumericVector vec(dims[0]);
  NumericMatrix M(dims[0], dims[1]);
  CharacterVector colNames = ch5ReadCharVector("ColumnNames", filePath);
  CharacterVector colClasses = ch5ReadCharVector("ColumnClasses", filePath);
  string colName;
  for(int i = 0; i < dims[1]; i++)
  {
    NumericVector vec(dims[0]);
    for(int j = 0; j < dims[0]; j++)
    {
      M(j,i) = buf[i][j];
      vec(j) = buf[i][j];
    }
    colName = colNames[i];
    if(colClasses[i] == "factor")
    {
      CharacterVector levels;
      levels = h5ReadFactor(colName, filePath);
      IntegerVector fact(vec.size());
      fact = cCreateFactor(vec, levels);
      out[colName] = fact;
    }else{
      out[colName] = vec;
    }
    
  }
  free(buf);
  
  dataset.close(); //nn
  file->close();
  
  return wrap(out);
}

// Functions for reading and writing data frame and matrix chunks to memory
/*--------------------------------------------------------------------------------------------------*/

//'@title Function to write a matrix to memory and return a pointer
//'
//'@description Intended for internal use only
//'
//'@param obj matrix to be written to memory
//'@return externalptr 
// [[Rcpp::export]]
SEXP h5WriteMemMAT(NumericMatrix obj)
{
  XPtr<NumericMatrix> ptr(new NumericMatrix(obj), true);
  return ptr;
}

//'@title Function to write a data frame object to memory and return a pointer
//'
//'@description Intended for internal use only
//'
//'@param obj data frame to be written to memory
//'@return externalptr 
// [[Rcpp::export]]
SEXP h5WriteMemDF(DataFrame obj)
{
  XPtr<DataFrame> ptr(new DataFrame(obj), true);
  return ptr;
}

//'@title Function to read a matrix from memory when given the external pointer
//'
//'@description Intended for internal use only
//'
//'@param ptr an externalptr to the matrix object to be retrieved
//'@return matrix that is held at the externalptr
// [[Rcpp::export]]
NumericMatrix h5ReadMemMAT(SEXP ptr)
{
  XPtr<NumericMatrix> out(ptr);
  return *out;
}

//'@title Function to read a data frame that has been stored in memory when given the external pointer
//'
//'@param ptr externalptr to data frame stored in memory
//'@return the data frame that is held at the externalptr
// [[Rcpp::export]]
DataFrame h5ReadMemDF(SEXP ptr)
{
  XPtr<DataFrame> out(ptr);
  return *out;
}
####$$$$ activeH5-master\src/activeH5.o
ELF         >                    X
         @     @ KH   m      o      q      r      s      t      v      x      z      |      ~                                                                                                                                                                                                                                                                                                                                                                                                                                     	                                                  ####$$$$ activeH5-master\src/activeH5.so
ELF         >          @                @ 8  @ % "                               y     y                        "     "           H                         "     "                                                $       $              Ptd   `     `     `                        Qtd                                                  Rtd        "     "                                 GNU Z(k?o~                   A @@ A	LB ;b   *     D  HH @ ()F! ad@P3 @ &P  A	 , `X` H$@ @    D EB      P$HA$H ) G "   " @@!P####$$$$ activeH5-master\src/Makevars
PKG_LIBS = `$(R_HOME)/bin/Rscript -e "Rcpp:::LdFlags()"`

CXXFLAGS += -I/usr/include -L/usr/lib/x86_64-linux-gnu -std=c++0x -lhdf5 -lhdf5_cpp -lhdf5_hl -lhdf5_hl_cpp -lpthread -lz -ldl -lm
PKG_LIBS += -I/usr/include -L/usr/lib/x86_64-linux-gnu -std=c++0x -lhdf5 -lhdf5_cpp -lhdf5_hl -lhdf5_hl_cpp -lpthread -lz -ldl -lm

PKG_CPPFLAGS += -I../inst/include
PKG_LIBS += $(RCPP_LDFLAGS)

CXX_STD = CXX11
####$$$$ activeH5-master\src/RcppExports.cpp
// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/activeH5.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// createFactor
SEXP createFactor(NumericVector x, CharacterVector levels);
static SEXP activeH5_createFactor_try(SEXP xSEXP, SEXP levelsSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< NumericVector >::type x(xSEXP );
        Rcpp::traits::input_parameter< CharacterVector >::type levels(levelsSEXP );
        SEXP __result = createFactor(x, levels);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_createFactor(SEXP xSEXP, SEXP levelsSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_createFactor_try(xSEXP, levelsSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5CreateFile
int h5CreateFile(std::string filePath, int overwrite);
static SEXP activeH5_h5CreateFile_try(SEXP filePathSEXP, SEXP overwriteSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        Rcpp::traits::input_parameter< int >::type overwrite(overwriteSEXP );
        int __result = h5CreateFile(filePath, overwrite);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5CreateFile(SEXP filePathSEXP, SEXP overwriteSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5CreateFile_try(filePathSEXP, overwriteSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5CreateMetaData
int h5CreateMetaData(std::string filePath);
static SEXP activeH5_h5CreateMetaData_try(SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        int __result = h5CreateMetaData(filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5CreateMetaData(SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5CreateMetaData_try(filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5WriteCharVector
int h5WriteCharVector(std::string charName, SEXP charVec, std::string filePath, int update);
static SEXP activeH5_h5WriteCharVector_try(SEXP charNameSEXP, SEXP charVecSEXP, SEXP filePathSEXP, SEXP updateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type charName(charNameSEXP );
        Rcpp::traits::input_parameter< SEXP >::type charVec(charVecSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        Rcpp::traits::input_parameter< int >::type update(updateSEXP );
        int __result = h5WriteCharVector(charName, charVec, filePath, update);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5WriteCharVector(SEXP charNameSEXP, SEXP charVecSEXP, SEXP filePathSEXP, SEXP updateSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5WriteCharVector_try(charNameSEXP, charVecSEXP, filePathSEXP, updateSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5WriteInt
int h5WriteInt(std::string intName, int integer, std::string filePath, int update);
static SEXP activeH5_h5WriteInt_try(SEXP intNameSEXP, SEXP integerSEXP, SEXP filePathSEXP, SEXP updateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type intName(intNameSEXP );
        Rcpp::traits::input_parameter< int >::type integer(integerSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        Rcpp::traits::input_parameter< int >::type update(updateSEXP );
        int __result = h5WriteInt(intName, integer, filePath, update);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5WriteInt(SEXP intNameSEXP, SEXP integerSEXP, SEXP filePathSEXP, SEXP updateSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5WriteInt_try(intNameSEXP, integerSEXP, filePathSEXP, updateSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5WriteFactor
int h5WriteFactor(std::string charName, SEXP charVec, std::string filePath, int update);
static SEXP activeH5_h5WriteFactor_try(SEXP charNameSEXP, SEXP charVecSEXP, SEXP filePathSEXP, SEXP updateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type charName(charNameSEXP );
        Rcpp::traits::input_parameter< SEXP >::type charVec(charVecSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        Rcpp::traits::input_parameter< int >::type update(updateSEXP );
        int __result = h5WriteFactor(charName, charVec, filePath, update);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5WriteFactor(SEXP charNameSEXP, SEXP charVecSEXP, SEXP filePathSEXP, SEXP updateSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5WriteFactor_try(charNameSEXP, charVecSEXP, filePathSEXP, updateSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5WriteDoubleMat
int h5WriteDoubleMat(std::string dset, SEXP chunk, NumericVector dim, std::string filePath);
static SEXP activeH5_h5WriteDoubleMat_try(SEXP dsetSEXP, SEXP chunkSEXP, SEXP dimSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type dset(dsetSEXP );
        Rcpp::traits::input_parameter< SEXP >::type chunk(chunkSEXP );
        Rcpp::traits::input_parameter< NumericVector >::type dim(dimSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        int __result = h5WriteDoubleMat(dset, chunk, dim, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5WriteDoubleMat(SEXP dsetSEXP, SEXP chunkSEXP, SEXP dimSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5WriteDoubleMat_try(dsetSEXP, chunkSEXP, dimSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5FlushFile
int h5FlushFile(std::string filePath);
static SEXP activeH5_h5FlushFile_try(SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        int __result = h5FlushFile(filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5FlushFile(SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5FlushFile_try(filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5CloseFile
int h5CloseFile(std::string filePath);
static SEXP activeH5_h5CloseFile_try(SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        int __result = h5CloseFile(filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5CloseFile(SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5CloseFile_try(filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadCharVector
SEXP h5ReadCharVector(std::string charName, std::string filePath);
static SEXP activeH5_h5ReadCharVector_try(SEXP charNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type charName(charNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ReadCharVector(charName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadCharVector(SEXP charNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadCharVector_try(charNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadFactor
SEXP h5ReadFactor(std::string charName, std::string filePath);
static SEXP activeH5_h5ReadFactor_try(SEXP charNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type charName(charNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ReadFactor(charName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadFactor(SEXP charNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadFactor_try(charNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadInt
int h5ReadInt(std::string intName, std::string filePath);
static SEXP activeH5_h5ReadInt_try(SEXP intNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type intName(intNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        int __result = h5ReadInt(intName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadInt(SEXP intNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadInt_try(intNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadDoubleMat
SEXP h5ReadDoubleMat(std::string chunkName, std::string filePath);
static SEXP activeH5_h5ReadDoubleMat_try(SEXP chunkNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ReadDoubleMat(chunkName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadDoubleMat(SEXP chunkNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadDoubleMat_try(chunkNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5DummyRead
int h5DummyRead(std::string chunkName, std::string filePath);
static SEXP activeH5_h5DummyRead_try(SEXP chunkNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        int __result = h5DummyRead(chunkName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5DummyRead(SEXP chunkNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5DummyRead_try(chunkNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ModelFrame
SEXP h5ModelFrame(std::string chunkName, SEXP selCols_, std::string filePath);
static SEXP activeH5_h5ModelFrame_try(SEXP chunkNameSEXP, SEXP selCols_SEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< SEXP >::type selCols_(selCols_SEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ModelFrame(chunkName, selCols_, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ModelFrame(SEXP chunkNameSEXP, SEXP selCols_SEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ModelFrame_try(chunkNameSEXP, selCols_SEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ChunkList
SEXP h5ChunkList(std::string chunkName, std::string filePath);
static SEXP activeH5_h5ChunkList_try(SEXP chunkNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ChunkList(chunkName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ChunkList(SEXP chunkNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ChunkList_try(chunkNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ChunkSel
SEXP h5ChunkSel(std::string chunkName, SEXP selCols, std::string filePath);
static SEXP activeH5_h5ChunkSel_try(SEXP chunkNameSEXP, SEXP selColsSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< SEXP >::type selCols(selColsSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ChunkSel(chunkName, selCols, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ChunkSel(SEXP chunkNameSEXP, SEXP selColsSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ChunkSel_try(chunkNameSEXP, selColsSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadDoubleMat2
SEXP h5ReadDoubleMat2(std::string chunkName, std::string filePath);
static SEXP activeH5_h5ReadDoubleMat2_try(SEXP chunkNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ReadDoubleMat2(chunkName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadDoubleMat2(SEXP chunkNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadDoubleMat2_try(chunkNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadDoubleMat3
SEXP h5ReadDoubleMat3(std::string chunkName, std::string filePath);
static SEXP activeH5_h5ReadDoubleMat3_try(SEXP chunkNameSEXP, SEXP filePathSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type chunkName(chunkNameSEXP );
        Rcpp::traits::input_parameter< std::string >::type filePath(filePathSEXP );
        SEXP __result = h5ReadDoubleMat3(chunkName, filePath);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadDoubleMat3(SEXP chunkNameSEXP, SEXP filePathSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadDoubleMat3_try(chunkNameSEXP, filePathSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5WriteMemMAT
SEXP h5WriteMemMAT(NumericMatrix obj);
static SEXP activeH5_h5WriteMemMAT_try(SEXP objSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< NumericMatrix >::type obj(objSEXP );
        SEXP __result = h5WriteMemMAT(obj);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5WriteMemMAT(SEXP objSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5WriteMemMAT_try(objSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5WriteMemDF
SEXP h5WriteMemDF(DataFrame obj);
static SEXP activeH5_h5WriteMemDF_try(SEXP objSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< DataFrame >::type obj(objSEXP );
        SEXP __result = h5WriteMemDF(obj);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5WriteMemDF(SEXP objSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5WriteMemDF_try(objSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadMemMAT
NumericMatrix h5ReadMemMAT(SEXP ptr);
static SEXP activeH5_h5ReadMemMAT_try(SEXP ptrSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< SEXP >::type ptr(ptrSEXP );
        NumericMatrix __result = h5ReadMemMAT(ptr);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadMemMAT(SEXP ptrSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadMemMAT_try(ptrSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// h5ReadMemDF
DataFrame h5ReadMemDF(SEXP ptr);
static SEXP activeH5_h5ReadMemDF_try(SEXP ptrSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< SEXP >::type ptr(ptrSEXP );
        DataFrame __result = h5ReadMemDF(ptr);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP activeH5_h5ReadMemDF(SEXP ptrSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(activeH5_h5ReadMemDF_try(ptrSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}

// validate (ensure exported C++ functions exist before calling them)
static int activeH5_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("SEXP(*createFactor)(NumericVector,CharacterVector)");
        signatures.insert("int(*h5CreateFile)(std::string,int)");
        signatures.insert("int(*h5CreateMetaData)(std::string)");
        signatures.insert("int(*h5WriteCharVector)(std::string,SEXP,std::string,int)");
        signatures.insert("int(*h5WriteInt)(std::string,int,std::string,int)");
        signatures.insert("int(*h5WriteFactor)(std::string,SEXP,std::string,int)");
        signatures.insert("int(*h5WriteDoubleMat)(std::string,SEXP,NumericVector,std::string)");
        signatures.insert("int(*h5FlushFile)(std::string)");
        signatures.insert("int(*h5CloseFile)(std::string)");
        signatures.insert("SEXP(*h5ReadCharVector)(std::string,std::string)");
        signatures.insert("SEXP(*h5ReadFactor)(std::string,std::string)");
        signatures.insert("int(*h5ReadInt)(std::string,std::string)");
        signatures.insert("SEXP(*h5ReadDoubleMat)(std::string,std::string)");
        signatures.insert("int(*h5DummyRead)(std::string,std::string)");
        signatures.insert("SEXP(*h5ModelFrame)(std::string,SEXP,std::string)");
        signatures.insert("SEXP(*h5ChunkList)(std::string,std::string)");
        signatures.insert("SEXP(*h5ChunkSel)(std::string,SEXP,std::string)");
        signatures.insert("SEXP(*h5ReadDoubleMat2)(std::string,std::string)");
        signatures.insert("SEXP(*h5ReadDoubleMat3)(std::string,std::string)");
        signatures.insert("SEXP(*h5WriteMemMAT)(NumericMatrix)");
        signatures.insert("SEXP(*h5WriteMemDF)(DataFrame)");
        signatures.insert("NumericMatrix(*h5ReadMemMAT)(SEXP)");
        signatures.insert("DataFrame(*h5ReadMemDF)(SEXP)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP activeH5_RcppExport_registerCCallable() { 
    R_RegisterCCallable("activeH5", "activeH5_createFactor", (DL_FUNC)activeH5_createFactor_try);
    R_RegisterCCallable("activeH5", "activeH5_h5CreateFile", (DL_FUNC)activeH5_h5CreateFile_try);
    R_RegisterCCallable("activeH5", "activeH5_h5CreateMetaData", (DL_FUNC)activeH5_h5CreateMetaData_try);
    R_RegisterCCallable("activeH5", "activeH5_h5WriteCharVector", (DL_FUNC)activeH5_h5WriteCharVector_try);
    R_RegisterCCallable("activeH5", "activeH5_h5WriteInt", (DL_FUNC)activeH5_h5WriteInt_try);
    R_RegisterCCallable("activeH5", "activeH5_h5WriteFactor", (DL_FUNC)activeH5_h5WriteFactor_try);
    R_RegisterCCallable("activeH5", "activeH5_h5WriteDoubleMat", (DL_FUNC)activeH5_h5WriteDoubleMat_try);
    R_RegisterCCallable("activeH5", "activeH5_h5FlushFile", (DL_FUNC)activeH5_h5FlushFile_try);
    R_RegisterCCallable("activeH5", "activeH5_h5CloseFile", (DL_FUNC)activeH5_h5CloseFile_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadCharVector", (DL_FUNC)activeH5_h5ReadCharVector_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadFactor", (DL_FUNC)activeH5_h5ReadFactor_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadInt", (DL_FUNC)activeH5_h5ReadInt_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadDoubleMat", (DL_FUNC)activeH5_h5ReadDoubleMat_try);
    R_RegisterCCallable("activeH5", "activeH5_h5DummyRead", (DL_FUNC)activeH5_h5DummyRead_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ModelFrame", (DL_FUNC)activeH5_h5ModelFrame_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ChunkList", (DL_FUNC)activeH5_h5ChunkList_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ChunkSel", (DL_FUNC)activeH5_h5ChunkSel_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadDoubleMat2", (DL_FUNC)activeH5_h5ReadDoubleMat2_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadDoubleMat3", (DL_FUNC)activeH5_h5ReadDoubleMat3_try);
    R_RegisterCCallable("activeH5", "activeH5_h5WriteMemMAT", (DL_FUNC)activeH5_h5WriteMemMAT_try);
    R_RegisterCCallable("activeH5", "activeH5_h5WriteMemDF", (DL_FUNC)activeH5_h5WriteMemDF_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadMemMAT", (DL_FUNC)activeH5_h5ReadMemMAT_try);
    R_RegisterCCallable("activeH5", "activeH5_h5ReadMemDF", (DL_FUNC)activeH5_h5ReadMemDF_try);
    R_RegisterCCallable("activeH5", "activeH5_RcppExport_validate", (DL_FUNC)activeH5_RcppExport_validate);
    return R_NilValue;
}
####$$$$ activeH5-master\src/RcppExports.o
ELF         >                    
         @     @     U      W      X      Y      Z      \      ^      `      b      d      f      h      j      l      n      p      r      t      v      x      z      |      ~                                                                                                                                                                                                                                                                                                                                                                                  ATHUSH0Hl$H    H\$H    H    H|$H;8t           H0H[]A\HH   HuK    H    H    HH    H|$IH;:t    LHH    H        HT$H5    H    H    HHD$Ht$Hx        U        rHHD$Ht$Hx        H    Hs@ ATHUSH Hl$H    H\$H    H    H|$H;8t           H H[]A\HH   HuK    H    H    HH    H|$IH;:t    LHH    H        HT$H5    H    H    HHD$Ht$Hx        U        rHHD$Ht$Hx        H    Hs@ AV1AUATUH   SH   H    HD$h    L+Ll$`    LI      L;#tL    Ll$`H5    HLd$`Ll$h      H;Ht$xH|$p    H=        H    HHL2    LH    t$xHHD$p       Hl$p    L    F  H;+e  H    L#1   Hl$`Ll$hLd$PHD$X        Ll$PIL      L;#tL    Ld$PH5    Ld$PHLd$X    #  H;H$   H$       H=        H    HHL*    LH    $   HH$          L$       Lt$PL      L;+Lt    H;Ll$PLd$XH9tH    L    H|$PH;;Ht    H           HH   []A\A]A^ IL    zH    `  L9   mfLl$PL    HX  H;+t    H;Hl$PLd$XE@ L       M9fL;+UL    L9#DGL       M9=L;+,L    